{"ast":null,"code":"import { timer, of, from, throwError } from 'rxjs';\nimport { takeUntil, delay, tap, concatMap, takeWhile, map, catchError, retryWhen } from 'rxjs/operators';\nimport ProxyService from '../../../../services/proxy-service';\nimport RecordDA from './data-access/RecordDA';\nimport EVENT_TYPES from './EventTypes';\n\nclass RecordTransmitter {\n  constructor(dicoin) {\n    this.dicoin = dicoin;\n  }\n\n  startRecordTransmission() {\n    this.dicoin.recordTransmisionStarted = true;\n    const retryOptions = {\n      maxRetryAttempts: this.dicoin.transmissionConfig.maxRetries,\n      delayDuration: this.dicoin.transmissionConfig.delayBetweenRetries,\n      excludedStatusCodes: []\n    };\n    this.dicoin.records$.pipe(takeUntil(this.dicoin.stopTransmissionSubject$), // this is only used when the component will be destroyed\n    concatMap(record => of(record).pipe(takeWhile(possibleStopFlagDisguisedAsRecord => possibleStopFlagDisguisedAsRecord !== 'STOPPED' // this happens when the las record has been reached\n    ), delay(10000), // TODO REQUEST\n    concatMap(_ref => {\n      let {\n        localRecord,\n        extendedRecord\n      } = _ref;\n      const {\n        endPoint,\n        user,\n        password,\n        timeout\n      } = this.dicoin.transmissionConfig;\n      const {\n        authorityPayload: fileContent,\n        _id: fileName\n      } = extendedRecord;\n      const sendTs = Date.now();\n      return from(ProxyService.send(endPoint, user, password, fileName, JSON.stringify(fileContent), timeout)).pipe(catchError(proxyError => {\n        RecordTransmitter.logRecordTransmitter('=== THROW ERR proxyError ===========', localRecord.stats.retryAttempt);\n        const dataReturn = {\n          localRecord,\n          extendedRecord,\n          sendTs,\n          // TODO: Cambiar esto por lo real\n          response: {\n            statusCode: proxyError.status,\n            ts: Date.now(),\n            message: proxyError.statusText,\n            latency: proxyError.latency\n          }\n        };\n\n        if (localRecord.stats.retryAttempt < this.dicoin.transmissionConfig.maxRetries) {\n          throw dataReturn;\n        }\n\n        return of(dataReturn);\n      }), map(proxyResponse => {\n        const dataReturn = {\n          localRecord,\n          extendedRecord,\n          sendTs,\n          // TODO: Cambiar esto por lo real\n          response: {\n            statusCode: proxyResponse.data.statusDTO.codigo,\n            ts: Date.now(),\n            message: proxyResponse.data.statusDTO.descripcion,\n            latency: proxyResponse.data.latency\n          }\n        };\n        const success = proxyResponse.data && proxyResponse.data.statusDTO && proxyResponse.data.statusDTO.codigo >= 0;\n\n        if (!success && localRecord.stats.retryAttempt <= this.dicoin.transmissionConfig.maxRetries) {\n          RecordTransmitter.log('=== THROW ERR proxyResponse ===========', proxyResponse);\n          throw dataReturn;\n        }\n\n        return dataReturn;\n      }), map(_ref2 => {\n        let {\n          response\n        } = _ref2;\n        const retryAttempt = localRecord.stats.retryAttempt + 1;\n        const {\n          statusCode,\n          message,\n          ts: responseTs\n        } = response;\n        const state = statusCode >= 0 ? 'SENT' : localRecord.stats.attempts < retryOptions.maxRetryAttempts ? 'WARNING' : 'ERROR'; // Update Local Data\n\n        localRecord.state = state;\n        localRecord.stats.attempts.push({\n          code: statusCode,\n          message,\n          timestamp: sendTs,\n          latency: response.latency\n        });\n        localRecord.stats.retryAttempt = retryAttempt;\n        localRecord.stats.sentTimestamp = sendTs; // Update DB\n\n        extendedRecord.state = state;\n        extendedRecord.stats.attempts.push({\n          code: statusCode,\n          message,\n          timestamp: sendTs,\n          latency: response.latency\n        });\n        extendedRecord.stats.retryAttempt = retryAttempt;\n        extendedRecord.stats.sentTimestamp = sendTs;\n        RecordDA.insertRecord(extendedRecord);\n        const currentRecordIndex = this.dicoin.trip.records.findIndex(rec => rec._id === extendedRecord._id);\n        this.dicoin.trip.records[currentRecordIndex] = localRecord;\n        return localRecord;\n      }), retryWhen(attempts$ => this.retryStrategy(attempts$, retryOptions)), catchError(x => {\n        RecordTransmitter.log('=== CATCH_ERROR ===========', x);\n        return of(record);\n      }));\n    }), tap(x => {\n      RecordTransmitter.log('=======================');\n      RecordTransmitter.log(x);\n      RecordTransmitter.log('=======================');\n    }), tap(transmittedRecord => {\n      const currentRecordIndex = this.dicoin.trip.records.findIndex(rec => rec._id === transmittedRecord._id);\n      this.dicoin.trip.records[currentRecordIndex] = transmittedRecord;\n      this.dicoin.emitEvent(EVENT_TYPES.RECORD_UPDATED, {\n        record: transmittedRecord,\n        records: this.dicoin.trip.records\n      });\n    })))).subscribe(record => {\n      RecordTransmitter.log('record transmission:', JSON.stringify(record));\n    }, err => {\n      RecordTransmitter.log('RECORD TRANSMISSION ERROR = ', err);\n    }, () => {\n      RecordTransmitter.log('RECORD TRANSMISSION STOPPED');\n      this.dicoin.recordTransmisionStarted = false;\n      this.dicoin.emitEvent(EVENT_TYPES.RECORD_TRANSMISSION_STOPPED);\n    });\n  }\n\n  retryStrategy(attempts$, _ref3) {\n    let {\n      maxRetryAttempts = this.dicoin.transmissionConfig.maxRetries,\n      delayDuration = this.dicoin.transmissionConfig.delayBetweenRetries,\n      excludedStatusCodes = []\n    } = _ref3;\n    return attempts$.pipe(concatMap((_ref4, i) => {\n      let {\n        response,\n        localRecord,\n        extendedRecord,\n        sendTs\n      } = _ref4;\n      const retryAttempt = i + 1;\n\n      if (retryAttempt > maxRetryAttempts || excludedStatusCodes.find(e => e === localRecord.status) || localRecord.state === 'SENT') {\n        console.log('LOOP_INFINITO', extendedRecord._id, {\n          retryAttempt,\n          maxRetryAttempts,\n          delayDuration,\n          cond1: retryAttempt > maxRetryAttempts,\n          cond2: excludedStatusCodes.find(e => e === localRecord.status),\n          state: localRecord.state\n        });\n        return throwError({\n          response,\n          localRecord,\n          extendedRecord,\n          sendTs\n        });\n      }\n\n      const {\n        statusCode,\n        body = {},\n        ts: responseTs,\n        message\n      } = response;\n      const state = localRecord.stats.attempts < maxRetryAttempts ? 'WARNING' : 'ERROR'; // Update Local Data\n\n      if (localRecord.state !== 'SENT') {\n        localRecord.state = state;\n        localRecord.stats.attempts.push({\n          code: statusCode,\n          message,\n          timestamp: sendTs,\n          latency: responseTs - sendTs\n        });\n        localRecord.stats.retryAttempt = retryAttempt;\n        localRecord.stats.sentTimestamp = sendTs;\n      } // Update DB\n\n\n      if (extendedRecord.state !== 'SENT') {\n        extendedRecord.state = state;\n        extendedRecord.stats.attempts.push({\n          code: statusCode,\n          message,\n          timestamp: sendTs,\n          latency: responseTs - sendTs\n        });\n        extendedRecord.stats.retryAttempt = retryAttempt;\n        extendedRecord.stats.sentTimestamp = sendTs;\n        RecordDA.insertRecord(extendedRecord);\n      }\n\n      const currentRecordIndex = this.dicoin.trip.records.findIndex(rec => rec._id === extendedRecord._id);\n      this.dicoin.trip.records[currentRecordIndex] = localRecord;\n      RecordTransmitter.log(`Send record Attempt ${retryAttempt}: retrying in ${delayDuration}ms`);\n      this.dicoin.emitEvent(EVENT_TYPES.RECORD_UPDATED, {\n        record: localRecord,\n        records: this.dicoin.trip.records\n      });\n      return timer(delayDuration);\n    }));\n  }\n\n  sendTripOnBatch(fileName, fileContent) {\n    const {\n      endPoint,\n      user,\n      password,\n      timeout\n    } = this.dicoin.transmissionConfig;\n    const sendTs = Date.now();\n    from(ProxyService.send(endPoint, user, password, fileName, JSON.stringify(fileContent), timeout)).pipe(catchError(proxyError => {\n      const dataReturn = {\n        sendTs,\n        response: {\n          statusCode: proxyError.status,\n          ts: Date.now(),\n          message: proxyError.statusText,\n          latency: proxyError.latency\n        }\n      };\n      throw dataReturn;\n    }), map(proxyResponse => {\n      const dataReturn = {\n        sendTs,\n        response: {\n          statusCode: proxyResponse.data.statusDTO.codigo,\n          ts: Date.now(),\n          message: proxyResponse.data.statusDTO.descripcion,\n          latency: proxyResponse.data.latency\n        }\n      };\n      const success = proxyResponse.data && proxyResponse.data.statusDTO && proxyResponse.data.statusDTO.codigo >= 0;\n\n      if (!success) {\n        throw dataReturn;\n      }\n\n      return dataReturn;\n    }), tap(transmittedRecord => {\n      this.dicoin.emitEvent(EVENT_TYPES.TRIP_REPORTED, {}); // REPORT TRANSMITTED\n    }), catchError(error => {\n      this.dicoin.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n        message: `No se pudo reportar: ${error.response.statusCode} ${error.response.message}`\n      });\n      return of('Error');\n    })).subscribe(record => {\n      RecordTransmitter.log('record transmission:', JSON.stringify(record));\n    }, err => {\n      RecordTransmitter.log('RECORD TRANSMISSION ERROR = ', err);\n    }, () => {\n      RecordTransmitter.log('RECORD TRANSMISSION STOPPED');\n      this.dicoin.recordTransmisionStarted = false;\n      this.dicoin.emitEvent(EVENT_TYPES.RECORD_TRANSMISSION_STOPPED);\n    });\n  }\n  /*\n   *************************************************\n   ****************** TOOLS ************************\n   *************************************************\n   */\n\n\n  static log() {\n    for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {\n      data[_key] = arguments[_key];\n    }\n\n    console.log('Dicoin.RecordTransmitter:', ...data);\n  }\n\n}\n/**\n * @returns {RecordTransmitter}\n */\n\n\nexport default RecordTransmitter;","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/src/app/main/travels/tools/dicoin-engine/RecordTransmitter.js"],"names":["timer","of","from","throwError","takeUntil","delay","tap","concatMap","takeWhile","map","catchError","retryWhen","ProxyService","RecordDA","EVENT_TYPES","RecordTransmitter","constructor","dicoin","startRecordTransmission","recordTransmisionStarted","retryOptions","maxRetryAttempts","transmissionConfig","maxRetries","delayDuration","delayBetweenRetries","excludedStatusCodes","records$","pipe","stopTransmissionSubject$","record","possibleStopFlagDisguisedAsRecord","localRecord","extendedRecord","endPoint","user","password","timeout","authorityPayload","fileContent","_id","fileName","sendTs","Date","now","send","JSON","stringify","proxyError","logRecordTransmitter","stats","retryAttempt","dataReturn","response","statusCode","status","ts","message","statusText","latency","proxyResponse","data","statusDTO","codigo","descripcion","success","log","responseTs","state","attempts","push","code","timestamp","sentTimestamp","insertRecord","currentRecordIndex","trip","records","findIndex","rec","attempts$","retryStrategy","x","transmittedRecord","emitEvent","RECORD_UPDATED","subscribe","err","RECORD_TRANSMISSION_STOPPED","i","find","e","console","cond1","cond2","body","sendTripOnBatch","TRIP_REPORTED","error","ERROR_REPORTED"],"mappings":"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","sourcesContent":["import { timer, of, from, throwError } from 'rxjs';\nimport {\n  takeUntil,\n  delay,\n  tap,\n  concatMap,\n  takeWhile,\n  map,\n  catchError,\n  retryWhen,\n} from 'rxjs/operators';\nimport ProxyService from '../../../../services/proxy-service';\nimport RecordDA from './data-access/RecordDA';\n\nimport EVENT_TYPES from './EventTypes';\n\nclass RecordTransmitter {\n  constructor(dicoin) {\n    this.dicoin = dicoin;\n  }\n\n  startRecordTransmission() {\n    this.dicoin.recordTransmisionStarted = true;\n    const retryOptions = {\n      maxRetryAttempts: this.dicoin.transmissionConfig.maxRetries,\n      delayDuration: this.dicoin.transmissionConfig.delayBetweenRetries,\n      excludedStatusCodes: [],\n    };\n    this.dicoin.records$\n      .pipe(\n        takeUntil(this.dicoin.stopTransmissionSubject$), // this is only used when the component will be destroyed\n        concatMap((record) =>\n          of(record).pipe(\n            takeWhile(\n              (possibleStopFlagDisguisedAsRecord) => possibleStopFlagDisguisedAsRecord !== 'STOPPED'\n              // this happens when the las record has been reached\n            ),\n            delay(10000),\n            // TODO REQUEST\n            concatMap(({ localRecord, extendedRecord }) => {\n              const { endPoint, user, password, timeout } = this.dicoin.transmissionConfig;\n              const { authorityPayload: fileContent, _id: fileName } = extendedRecord;\n              const sendTs = Date.now();\n              return from(\n                ProxyService.send(\n                  endPoint,\n                  user,\n                  password,\n                  fileName,\n                  JSON.stringify(fileContent),\n                  timeout\n                )\n              ).pipe(\n                catchError((proxyError) => {\n                  RecordTransmitter.logRecordTransmitter(\n                    '=== THROW ERR proxyError ===========',\n                    localRecord.stats.retryAttempt\n                  );\n                  const dataReturn = {\n                    localRecord,\n                    extendedRecord,\n                    sendTs,\n                    // TODO: Cambiar esto por lo real\n                    response: {\n                      statusCode: proxyError.status,\n                      ts: Date.now(),\n                      message: proxyError.statusText,\n                      latency: proxyError.latency,\n                    },\n                  };\n                  if (localRecord.stats.retryAttempt < this.dicoin.transmissionConfig.maxRetries) {\n                    throw dataReturn;\n                  }\n                  return of(dataReturn);\n                }),\n                map((proxyResponse) => {\n                  const dataReturn = {\n                    localRecord,\n                    extendedRecord,\n                    sendTs,\n                    // TODO: Cambiar esto por lo real\n                    response: {\n                      statusCode: proxyResponse.data.statusDTO.codigo,\n                      ts: Date.now(),\n                      message: proxyResponse.data.statusDTO.descripcion,\n                      latency: proxyResponse.data.latency,\n                    },\n                  };\n                  const success =\n                    proxyResponse.data &&\n                    proxyResponse.data.statusDTO &&\n                    proxyResponse.data.statusDTO.codigo >= 0;\n                  if (\n                    !success &&\n                    localRecord.stats.retryAttempt <= this.dicoin.transmissionConfig.maxRetries\n                  ) {\n                    RecordTransmitter.log('=== THROW ERR proxyResponse ===========', proxyResponse);\n                    throw dataReturn;\n                  }\n                  return dataReturn;\n                }),\n                map(({ response }) => {\n                  const retryAttempt = localRecord.stats.retryAttempt + 1;\n                  const { statusCode, message, ts: responseTs } = response;\n                  const state =\n                    statusCode >= 0\n                      ? 'SENT'\n                      : localRecord.stats.attempts < retryOptions.maxRetryAttempts\n                      ? 'WARNING'\n                      : 'ERROR';\n                  // Update Local Data\n                  localRecord.state = state;\n                  localRecord.stats.attempts.push({\n                    code: statusCode,\n                    message,\n                    timestamp: sendTs,\n                    latency: response.latency,\n                  });\n                  localRecord.stats.retryAttempt = retryAttempt;\n                  localRecord.stats.sentTimestamp = sendTs;\n                  // Update DB\n                  extendedRecord.state = state;\n                  extendedRecord.stats.attempts.push({\n                    code: statusCode,\n                    message,\n                    timestamp: sendTs,\n                    latency: response.latency,\n                  });\n                  extendedRecord.stats.retryAttempt = retryAttempt;\n                  extendedRecord.stats.sentTimestamp = sendTs;\n                  RecordDA.insertRecord(extendedRecord);\n                  const currentRecordIndex = this.dicoin.trip.records.findIndex(\n                    (rec) => rec._id === extendedRecord._id\n                  );\n                  this.dicoin.trip.records[currentRecordIndex] = localRecord;\n                  return localRecord;\n                }),\n                retryWhen((attempts$) => this.retryStrategy(attempts$, retryOptions)),\n                catchError((x) => {\n                  RecordTransmitter.log('=== CATCH_ERROR ===========', x);\n                  return of(record);\n                })\n              );\n            }),\n            tap((x) => {\n              RecordTransmitter.log('=======================');\n              RecordTransmitter.log(x);\n              RecordTransmitter.log('=======================');\n            }),\n            tap((transmittedRecord) => {\n              const currentRecordIndex = this.dicoin.trip.records.findIndex(\n                (rec) => rec._id === transmittedRecord._id\n              );\n              this.dicoin.trip.records[currentRecordIndex] = transmittedRecord;\n              this.dicoin.emitEvent(EVENT_TYPES.RECORD_UPDATED, {\n                record: transmittedRecord,\n                records: this.dicoin.trip.records,\n              });\n            })\n          )\n        )\n      )\n      .subscribe(\n        (record) => {\n          RecordTransmitter.log('record transmission:', JSON.stringify(record));\n        },\n        (err) => {\n          RecordTransmitter.log('RECORD TRANSMISSION ERROR = ', err);\n        },\n        () => {\n          RecordTransmitter.log('RECORD TRANSMISSION STOPPED');\n          this.dicoin.recordTransmisionStarted = false;\n          this.dicoin.emitEvent(EVENT_TYPES.RECORD_TRANSMISSION_STOPPED);\n        }\n      );\n  }\n\n  retryStrategy(\n    attempts$,\n    {\n      maxRetryAttempts = this.dicoin.transmissionConfig.maxRetries,\n      delayDuration = this.dicoin.transmissionConfig.delayBetweenRetries,\n      excludedStatusCodes = [],\n    }\n  ) {\n    return attempts$.pipe(\n      concatMap(({ response, localRecord, extendedRecord, sendTs }, i) => {\n        const retryAttempt = i + 1;\n\n        if (\n          retryAttempt > maxRetryAttempts ||\n          excludedStatusCodes.find((e) => e === localRecord.status) ||\n          localRecord.state === 'SENT'\n        ) {\n          console.log('LOOP_INFINITO', extendedRecord._id, {\n            retryAttempt,\n            maxRetryAttempts,\n            delayDuration,\n            cond1: retryAttempt > maxRetryAttempts,\n            cond2: excludedStatusCodes.find((e) => e === localRecord.status),\n            state: localRecord.state,\n          });\n          return throwError({ response, localRecord, extendedRecord, sendTs });\n        }\n\n        const { statusCode, body = {}, ts: responseTs, message } = response;\n        const state = localRecord.stats.attempts < maxRetryAttempts ? 'WARNING' : 'ERROR';\n\n        // Update Local Data\n        if (localRecord.state !== 'SENT') {\n          localRecord.state = state;\n          localRecord.stats.attempts.push({\n            code: statusCode,\n            message,\n            timestamp: sendTs,\n            latency: responseTs - sendTs,\n          });\n          localRecord.stats.retryAttempt = retryAttempt;\n          localRecord.stats.sentTimestamp = sendTs;\n        }\n\n        // Update DB\n        if (extendedRecord.state !== 'SENT') {\n          extendedRecord.state = state;\n          extendedRecord.stats.attempts.push({\n            code: statusCode,\n            message,\n            timestamp: sendTs,\n            latency: responseTs - sendTs,\n          });\n          extendedRecord.stats.retryAttempt = retryAttempt;\n          extendedRecord.stats.sentTimestamp = sendTs;\n          RecordDA.insertRecord(extendedRecord);\n        }\n        const currentRecordIndex = this.dicoin.trip.records.findIndex(\n          (rec) => rec._id === extendedRecord._id\n        );\n        this.dicoin.trip.records[currentRecordIndex] = localRecord;\n\n        RecordTransmitter.log(\n          `Send record Attempt ${retryAttempt}: retrying in ${delayDuration}ms`\n        );\n        this.dicoin.emitEvent(EVENT_TYPES.RECORD_UPDATED, {\n          record: localRecord,\n          records: this.dicoin.trip.records,\n        });\n        return timer(delayDuration);\n      })\n    );\n  }\n\n  sendTripOnBatch(fileName, fileContent) {\n    const { endPoint, user, password, timeout } = this.dicoin.transmissionConfig;\n    const sendTs = Date.now();\n    from(\n      ProxyService.send(endPoint, user, password, fileName, JSON.stringify(fileContent), timeout)\n    )\n      .pipe(\n        catchError((proxyError) => {\n          const dataReturn = {\n            sendTs,\n            response: {\n              statusCode: proxyError.status,\n              ts: Date.now(),\n              message: proxyError.statusText,\n              latency: proxyError.latency,\n            },\n          };\n          throw dataReturn;\n        }),\n        map((proxyResponse) => {\n          const dataReturn = {\n            sendTs,\n            response: {\n              statusCode: proxyResponse.data.statusDTO.codigo,\n              ts: Date.now(),\n              message: proxyResponse.data.statusDTO.descripcion,\n              latency: proxyResponse.data.latency,\n            },\n          };\n          const success =\n            proxyResponse.data &&\n            proxyResponse.data.statusDTO &&\n            proxyResponse.data.statusDTO.codigo >= 0;\n          if (!success) {\n            throw dataReturn;\n          }\n          return dataReturn;\n        }),\n        tap((transmittedRecord) => {\n          this.dicoin.emitEvent(EVENT_TYPES.TRIP_REPORTED, {});\n          // REPORT TRANSMITTED\n        }),\n        catchError((error) => {\n          this.dicoin.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n            message: `No se pudo reportar: ${error.response.statusCode} ${error.response.message}`,\n          });\n          return of('Error');\n        })\n      )\n      .subscribe(\n        (record) => {\n          RecordTransmitter.log('record transmission:', JSON.stringify(record));\n        },\n        (err) => {\n          RecordTransmitter.log('RECORD TRANSMISSION ERROR = ', err);\n        },\n        () => {\n          RecordTransmitter.log('RECORD TRANSMISSION STOPPED');\n          this.dicoin.recordTransmisionStarted = false;\n          this.dicoin.emitEvent(EVENT_TYPES.RECORD_TRANSMISSION_STOPPED);\n        }\n      );\n  }\n  /*\n   *************************************************\n   ****************** TOOLS ************************\n   *************************************************\n   */\n\n  static log(...data) {\n    console.log('Dicoin.RecordTransmitter:', ...data);\n  }\n}\n\n/**\n * @returns {RecordTransmitter}\n */\nexport default RecordTransmitter;\n"]},"metadata":{},"sourceType":"module"}