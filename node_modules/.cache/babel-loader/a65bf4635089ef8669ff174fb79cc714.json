{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst async_1 = __importDefault(require(\"async\"));\n\nconst idb_wrapper_1 = __importDefault(require(\"idb-wrapper\"));\n\nconst utils = __importStar(require(\"./utils\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst selector_1 = require(\"./selector\"); // Create a database backed by IndexedDb. options must contain namespace: <string to uniquely identify database>\n\n\nclass IndexedDb {\n  constructor(options, success, error) {\n    this.collections = {}; // Create database\n\n    try {\n      this.store = new idb_wrapper_1.default({\n        dbVersion: 1,\n        storeName: \"minimongo_\" + options.namespace,\n        keyPath: [\"col\", \"doc._id\"],\n        autoIncrement: false,\n        onStoreReady: () => {\n          if (success) {\n            return success(this);\n          }\n        },\n        onError: error,\n        indexes: [{\n          name: \"col\",\n          keyPath: \"col\",\n          unique: false,\n          multiEntry: false\n        }, {\n          name: \"col-state\",\n          keyPath: [\"col\", \"state\"],\n          unique: false,\n          multiEntry: false\n        }]\n      });\n    } catch (ex) {\n      if (error) {\n        error(ex);\n      }\n\n      return;\n    }\n  }\n\n  addCollection(name, success, error) {\n    const collection = new IndexedDbCollection(name, this.store);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success) {\n      return success();\n    }\n  }\n\n  removeCollection(name, success, error) {\n    delete this[name];\n    delete this.collections[name]; // Remove all documents\n\n    return this.store.query(matches => {\n      const keys = lodash_1.default.map(matches, m => [m.col, m.doc._id]);\n\n      if (keys.length > 0) {\n        return this.store.removeBatch(keys, function () {\n          if (success != null) {\n            return success();\n          }\n        }, error);\n      } else {\n        if (success != null) {\n          return success();\n        }\n      }\n    }, {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: name\n      }),\n      onError: error\n    });\n  }\n\n  getCollectionNames() {\n    return lodash_1.default.keys(this.collections);\n  }\n\n}\n\nexports.default = IndexedDb; // Stores data in indexeddb store\n\nclass IndexedDbCollection {\n  constructor(name, store) {\n    this.name = name;\n    this.store = store;\n  }\n\n  find(selector, options) {\n    return {\n      fetch: (success, error) => {\n        return this._findFetch(selector, options, success, error);\n      }\n    };\n  }\n\n  findOne(selector, options, success, error) {\n    if (lodash_1.default.isFunction(options)) {\n      ;\n      [options, success, error] = [{}, options, success];\n    }\n\n    this.find(selector, options).fetch(function (results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  }\n\n  _findFetch(selector, options, success, error) {\n    // Get all docs from collection\n    return this.store.query(function (matches) {\n      // Filter removed docs\n      matches = lodash_1.default.filter(matches, m => m.state !== \"removed\");\n\n      if (success != null) {\n        return success((0, utils_1.processFind)(lodash_1.default.map(matches, \"doc\"), selector, options));\n      }\n    }, {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: this.name\n      }),\n      onError: error\n    });\n  }\n\n  upsert(docs, bases, success, error) {\n    let items;\n    [items, success, error] = utils.regularizeUpsert(docs, bases, success, error); // Get bases\n\n    const keys = lodash_1.default.map(items, item => [this.name, item.doc._id]);\n    return this.store.getBatch(keys, records => {\n      const puts = lodash_1.default.map(items, (item, i) => {\n        // Prefer explicit base\n        let base;\n\n        if (item.base !== undefined) {\n          ;\n          ({\n            base\n          } = item);\n        } else if (records[i] && records[i].doc && records[i].state === \"cached\") {\n          base = records[i].doc;\n        } else if (records[i] && records[i].doc && records[i].state === \"upserted\") {\n          ;\n          ({\n            base\n          } = records[i]);\n        } else {\n          base = null;\n        }\n\n        return {\n          col: this.name,\n          state: \"upserted\",\n          doc: item.doc,\n          base\n        };\n      });\n      return this.store.putBatch(puts, function () {\n        if (success) {\n          return success(docs);\n        }\n      }, error);\n    }, error);\n  }\n\n  remove(id, success, error) {\n    // Special case for filter-type remove\n    if (lodash_1.default.isObject(id)) {\n      this.find(id).fetch(rows => {\n        return async_1.default.each(rows, (row, cb) => {\n          this.remove(row._id, () => cb(), cb);\n        }, () => success());\n      }, error);\n      return;\n    } // Find record\n\n\n    return this.store.get([this.name, id], record => {\n      // If not found, create placeholder record\n      if (record == null) {\n        record = {\n          col: this.name,\n          doc: {\n            _id: id\n          }\n        };\n      } // Set removed\n\n\n      record.state = \"removed\"; // Update\n\n      return this.store.put(record, function () {\n        if (success) {\n          return success();\n        }\n      }, error);\n    });\n  }\n\n  cache(docs, selector, options, success, error) {\n    const step2 = () => {\n      // Rows have been cached, now look for stale ones to remove\n      let sort;\n      const docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n\n      if (options.sort) {\n        sort = (0, selector_1.compileSort)(options.sort);\n      } // Perform query, removing rows missing in docs from local db\n\n\n      return this.find(selector, options).fetch(results => {\n        const removes = [];\n        const keys = lodash_1.default.map(results, result => [this.name, result._id]);\n\n        if (keys.length === 0) {\n          if (success != null) {\n            success();\n          }\n\n          return;\n        }\n\n        return this.store.getBatch(keys, records => {\n          for (let i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n            const record = records[i];\n            const result = results[i]; // If not present in docs and is present locally and not upserted/deleted\n\n            if (!docsMap[result._id] && record && record.state === \"cached\") {\n              // If at limit\n              if (options.limit && docs.length === options.limit) {\n                // If past end on sorted limited, ignore\n                if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n                  continue;\n                } // If no sort, ignore\n\n\n                if (!options.sort) {\n                  continue;\n                }\n              } // Exclude any excluded _ids from being cached/uncached\n\n\n              if (options && options.exclude && options.exclude.includes(result._id)) {\n                continue;\n              } // Item is gone from server, remove locally\n\n\n              removes.push([this.name, result._id]);\n            }\n          } // If removes, handle them\n\n\n          if (removes.length > 0) {\n            return this.store.removeBatch(removes, function () {\n              if (success != null) {\n                return success();\n              }\n            }, error);\n          } else {\n            if (success != null) {\n              return success();\n            }\n          }\n        }, error);\n      }, error);\n    };\n\n    if (docs.length === 0) {\n      return step2();\n    } // Create keys to get items\n\n\n    const keys = lodash_1.default.map(docs, doc => [this.name, doc._id]); // Create batch of puts\n\n    const puts = [];\n    return this.store.getBatch(keys, records => {\n      // Add all non-local that are not upserted or removed\n      for (let i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n        const record = records[i];\n        const doc = docs[i]; // Check if not present or not upserted/deleted\n\n        if (record == null || record.state === \"cached\") {\n          if (options && options.exclude && options.exclude.includes(doc._id)) {\n            continue;\n          } // If _rev present, make sure that not overwritten by lower or equal _rev\n\n\n          if (!record || !doc._rev || !record.doc._rev || doc._rev > record.doc._rev) {\n            puts.push({\n              col: this.name,\n              state: \"cached\",\n              doc\n            });\n          }\n        }\n      } // Put batch\n\n\n      if (puts.length > 0) {\n        return this.store.putBatch(puts, step2, error);\n      } else {\n        return step2();\n      }\n    }, error);\n  }\n\n  pendingUpserts(success, error) {\n    return this.store.query(function (matches) {\n      const upserts = lodash_1.default.map(matches, m => ({\n        doc: m.doc,\n        base: m.base || null\n      }));\n\n      if (success != null) {\n        return success(upserts);\n      }\n    }, {\n      index: \"col-state\",\n      keyRange: this.store.makeKeyRange({\n        only: [this.name, \"upserted\"]\n      }),\n      onError: error\n    });\n  }\n\n  pendingRemoves(success, error) {\n    return this.store.query(function (matches) {\n      if (success != null) {\n        return success(lodash_1.default.map(lodash_1.default.map(matches, \"doc\"), \"_id\"));\n      }\n    }, {\n      index: \"col-state\",\n      keyRange: this.store.makeKeyRange({\n        only: [this.name, \"removed\"]\n      }),\n      onError: error\n    });\n  }\n\n  resolveUpserts(upserts, success, error) {\n    // Get items\n    const keys = lodash_1.default.map(upserts, upsert => [this.name, upsert.doc._id]);\n    return this.store.getBatch(keys, records => {\n      const puts = [];\n\n      for (let i = 0, end = upserts.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n        const record = records[i]; // Only safely remove upsert if doc is the same\n\n        if (record && record.state === \"upserted\") {\n          if (lodash_1.default.isEqual(record.doc, upserts[i].doc)) {\n            record.state = \"cached\";\n            puts.push(record);\n          } else {\n            record.base = upserts[i].doc;\n            puts.push(record);\n          }\n        }\n      } // Put all changed items\n\n\n      if (puts.length > 0) {\n        return this.store.putBatch(puts, function () {\n          if (success) {\n            return success();\n          }\n        }, error);\n      } else {\n        if (success) {\n          return success();\n        }\n      }\n    }, error);\n  }\n\n  resolveRemove(id, success, error) {\n    return this.store.get([this.name, id], record => {\n      // Check if exists\n      if (!record) {\n        if (success != null) {\n          success();\n        }\n\n        return;\n      } // Only remove if removed\n\n\n      if (record.state === \"removed\") {\n        return this.store.remove([this.name, id], function () {\n          if (success != null) {\n            return success();\n          }\n        }, error);\n      }\n    });\n  } // Add but do not overwrite or record as upsert\n\n\n  seed(docs, success, error) {\n    if (!lodash_1.default.isArray(docs)) {\n      docs = [docs];\n    } // Create keys to get items\n\n\n    const keys = lodash_1.default.map(docs, doc => [this.name, doc._id]); // Create batch of puts\n\n    const puts = [];\n    return this.store.getBatch(keys, records => {\n      // Add all non-local that are not upserted or removed\n      for (let i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n        const record = records[i];\n        const doc = docs[i]; // Check if not present\n\n        if (record == null) {\n          puts.push({\n            col: this.name,\n            state: \"cached\",\n            doc\n          });\n        }\n      } // Put batch\n\n\n      if (puts.length > 0) {\n        return this.store.putBatch(puts, () => {\n          if (success != null) {\n            return success();\n          }\n        }, error);\n      } else {\n        if (success != null) {\n          return success();\n        }\n      }\n    }, error);\n  } // Add but do not overwrite upsert/removed and do not record as upsert\n\n\n  cacheOne(doc, success, error) {\n    return this.cacheList([doc], success, error);\n  }\n\n  cacheList(docs, success, error) {\n    // Create keys to get items\n    const keys = lodash_1.default.map(docs, doc => [this.name, doc._id]); // Create batch of puts\n\n    const puts = [];\n    return this.store.getBatch(keys, records => {\n      for (let i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n        let record = records[i];\n        const doc = docs[i]; // If _rev present, make sure that not overwritten by lower equal _rev\n\n        if (record && doc._rev && record.doc._rev && doc._rev <= record.doc._rev) {\n          continue;\n        }\n\n        if (record == null) {\n          record = {\n            col: this.name,\n            state: \"cached\",\n            doc\n          };\n        }\n\n        if (record.state === \"cached\") {\n          record.doc = doc;\n          puts.push(record);\n        }\n      } // Put batch\n\n\n      if (puts.length > 0) {\n        return this.store.putBatch(puts, () => {\n          if (success != null) {\n            return success();\n          }\n        }, error);\n      } else {\n        if (success != null) {\n          return success();\n        }\n      }\n    }, error);\n  }\n\n  uncache(selector, success, error) {\n    const compiledSelector = utils.compileDocumentSelector(selector); // Get all docs from collection\n\n    return this.store.query(matches => {\n      // Filter ones to remove\n      matches = lodash_1.default.filter(matches, m => m.state === \"cached\" && compiledSelector(m.doc));\n      const keys = lodash_1.default.map(matches, m => [this.name, m.doc._id]);\n\n      if (keys.length > 0) {\n        return this.store.removeBatch(keys, () => {\n          if (success != null) {\n            return success();\n          }\n        }, error);\n      } else {\n        if (success != null) {\n          return success();\n        }\n      }\n    }, {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: this.name\n      }),\n      onError: error\n    });\n  }\n\n  uncacheList(ids, success, error) {\n    const idIndex = lodash_1.default.keyBy(ids); // Android 2.x requires error callback\n\n    error = error || function () {}; // Get all docs from collection\n\n\n    return this.store.query(matches => {\n      // Filter ones to remove\n      matches = lodash_1.default.filter(matches, m => m.state === \"cached\" && idIndex[m.doc._id]);\n      const keys = lodash_1.default.map(matches, m => [this.name, m.doc._id]);\n\n      if (keys.length > 0) {\n        return this.store.removeBatch(keys, () => {\n          if (success != null) {\n            return success();\n          }\n        }, error);\n      } else {\n        if (success != null) {\n          return success();\n        }\n      }\n    }, {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: this.name\n      }),\n      onError: error\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/minimongo/lib/IndexedDb.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__importDefault","exports","lodash_1","require","async_1","idb_wrapper_1","utils","utils_1","selector_1","IndexedDb","constructor","options","success","error","collections","store","default","dbVersion","storeName","namespace","keyPath","autoIncrement","onStoreReady","onError","indexes","name","unique","multiEntry","ex","addCollection","collection","IndexedDbCollection","removeCollection","query","matches","keys","map","col","doc","_id","length","removeBatch","index","keyRange","makeKeyRange","only","getCollectionNames","find","selector","fetch","_findFetch","findOne","isFunction","results","filter","state","processFind","upsert","docs","bases","items","regularizeUpsert","item","getBatch","records","puts","i","base","putBatch","remove","id","isObject","rows","each","row","cb","record","put","cache","step2","sort","docsMap","fromPairs","zip","compileSort","removes","end","asc","limit","last","exclude","includes","push","_rev","pendingUpserts","upserts","pendingRemoves","resolveUpserts","isEqual","resolveRemove","seed","isArray","cacheOne","cacheList","uncache","compiledSelector","compileDocumentSelector","uncacheList","ids","idIndex","keyBy"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst async_1 = __importDefault(require(\"async\"));\nconst idb_wrapper_1 = __importDefault(require(\"idb-wrapper\"));\nconst utils = __importStar(require(\"./utils\"));\nconst utils_1 = require(\"./utils\");\nconst selector_1 = require(\"./selector\");\n// Create a database backed by IndexedDb. options must contain namespace: <string to uniquely identify database>\nclass IndexedDb {\n    constructor(options, success, error) {\n        this.collections = {};\n        // Create database\n        try {\n            this.store = new idb_wrapper_1.default({\n                dbVersion: 1,\n                storeName: \"minimongo_\" + options.namespace,\n                keyPath: [\"col\", \"doc._id\"],\n                autoIncrement: false,\n                onStoreReady: () => {\n                    if (success) {\n                        return success(this);\n                    }\n                },\n                onError: error,\n                indexes: [\n                    { name: \"col\", keyPath: \"col\", unique: false, multiEntry: false },\n                    { name: \"col-state\", keyPath: [\"col\", \"state\"], unique: false, multiEntry: false }\n                ]\n            });\n        }\n        catch (ex) {\n            if (error) {\n                error(ex);\n            }\n            return;\n        }\n    }\n    addCollection(name, success, error) {\n        const collection = new IndexedDbCollection(name, this.store);\n        this[name] = collection;\n        this.collections[name] = collection;\n        if (success) {\n            return success();\n        }\n    }\n    removeCollection(name, success, error) {\n        delete this[name];\n        delete this.collections[name];\n        // Remove all documents\n        return this.store.query((matches) => {\n            const keys = lodash_1.default.map(matches, (m) => [m.col, m.doc._id]);\n            if (keys.length > 0) {\n                return this.store.removeBatch(keys, function () {\n                    if (success != null) {\n                        return success();\n                    }\n                }, error);\n            }\n            else {\n                if (success != null) {\n                    return success();\n                }\n            }\n        }, { index: \"col\", keyRange: this.store.makeKeyRange({ only: name }), onError: error });\n    }\n    getCollectionNames() {\n        return lodash_1.default.keys(this.collections);\n    }\n}\nexports.default = IndexedDb;\n// Stores data in indexeddb store\nclass IndexedDbCollection {\n    constructor(name, store) {\n        this.name = name;\n        this.store = store;\n    }\n    find(selector, options) {\n        return {\n            fetch: (success, error) => {\n                return this._findFetch(selector, options, success, error);\n            }\n        };\n    }\n    findOne(selector, options, success, error) {\n        if (lodash_1.default.isFunction(options)) {\n            ;\n            [options, success, error] = [{}, options, success];\n        }\n        this.find(selector, options).fetch(function (results) {\n            if (success != null) {\n                return success(results.length > 0 ? results[0] : null);\n            }\n        }, error);\n    }\n    _findFetch(selector, options, success, error) {\n        // Get all docs from collection\n        return this.store.query(function (matches) {\n            // Filter removed docs\n            matches = lodash_1.default.filter(matches, (m) => m.state !== \"removed\");\n            if (success != null) {\n                return success((0, utils_1.processFind)(lodash_1.default.map(matches, \"doc\"), selector, options));\n            }\n        }, { index: \"col\", keyRange: this.store.makeKeyRange({ only: this.name }), onError: error });\n    }\n    upsert(docs, bases, success, error) {\n        let items;\n        [items, success, error] = utils.regularizeUpsert(docs, bases, success, error);\n        // Get bases\n        const keys = lodash_1.default.map(items, (item) => [this.name, item.doc._id]);\n        return this.store.getBatch(keys, (records) => {\n            const puts = lodash_1.default.map(items, (item, i) => {\n                // Prefer explicit base\n                let base;\n                if (item.base !== undefined) {\n                    ;\n                    ({ base } = item);\n                }\n                else if (records[i] && records[i].doc && records[i].state === \"cached\") {\n                    base = records[i].doc;\n                }\n                else if (records[i] && records[i].doc && records[i].state === \"upserted\") {\n                    ;\n                    ({ base } = records[i]);\n                }\n                else {\n                    base = null;\n                }\n                return {\n                    col: this.name,\n                    state: \"upserted\",\n                    doc: item.doc,\n                    base\n                };\n            });\n            return this.store.putBatch(puts, function () {\n                if (success) {\n                    return success(docs);\n                }\n            }, error);\n        }, error);\n    }\n    remove(id, success, error) {\n        // Special case for filter-type remove\n        if (lodash_1.default.isObject(id)) {\n            this.find(id).fetch((rows) => {\n                return async_1.default.each(rows, ((row, cb) => {\n                    this.remove(row._id, () => cb(), cb);\n                }), () => success());\n            }, error);\n            return;\n        }\n        // Find record\n        return this.store.get([this.name, id], (record) => {\n            // If not found, create placeholder record\n            if (record == null) {\n                record = {\n                    col: this.name,\n                    doc: { _id: id }\n                };\n            }\n            // Set removed\n            record.state = \"removed\";\n            // Update\n            return this.store.put(record, function () {\n                if (success) {\n                    return success();\n                }\n            }, error);\n        });\n    }\n    cache(docs, selector, options, success, error) {\n        const step2 = () => {\n            // Rows have been cached, now look for stale ones to remove\n            let sort;\n            const docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n            if (options.sort) {\n                sort = (0, selector_1.compileSort)(options.sort);\n            }\n            // Perform query, removing rows missing in docs from local db\n            return this.find(selector, options).fetch((results) => {\n                const removes = [];\n                const keys = lodash_1.default.map(results, (result) => [this.name, result._id]);\n                if (keys.length === 0) {\n                    if (success != null) {\n                        success();\n                    }\n                    return;\n                }\n                return this.store.getBatch(keys, (records) => {\n                    for (let i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                        const record = records[i];\n                        const result = results[i];\n                        // If not present in docs and is present locally and not upserted/deleted\n                        if (!docsMap[result._id] && record && record.state === \"cached\") {\n                            // If at limit\n                            if (options.limit && docs.length === options.limit) {\n                                // If past end on sorted limited, ignore\n                                if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n                                    continue;\n                                }\n                                // If no sort, ignore\n                                if (!options.sort) {\n                                    continue;\n                                }\n                            }\n                            // Exclude any excluded _ids from being cached/uncached\n                            if (options && options.exclude && options.exclude.includes(result._id)) {\n                                continue;\n                            }\n                            // Item is gone from server, remove locally\n                            removes.push([this.name, result._id]);\n                        }\n                    }\n                    // If removes, handle them\n                    if (removes.length > 0) {\n                        return this.store.removeBatch(removes, function () {\n                            if (success != null) {\n                                return success();\n                            }\n                        }, error);\n                    }\n                    else {\n                        if (success != null) {\n                            return success();\n                        }\n                    }\n                }, error);\n            }, error);\n        };\n        if (docs.length === 0) {\n            return step2();\n        }\n        // Create keys to get items\n        const keys = lodash_1.default.map(docs, (doc) => [this.name, doc._id]);\n        // Create batch of puts\n        const puts = [];\n        return this.store.getBatch(keys, (records) => {\n            // Add all non-local that are not upserted or removed\n            for (let i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                const record = records[i];\n                const doc = docs[i];\n                // Check if not present or not upserted/deleted\n                if (record == null || record.state === \"cached\") {\n                    if (options && options.exclude && options.exclude.includes(doc._id)) {\n                        continue;\n                    }\n                    // If _rev present, make sure that not overwritten by lower or equal _rev\n                    if (!record || !doc._rev || !record.doc._rev || doc._rev > record.doc._rev) {\n                        puts.push({ col: this.name, state: \"cached\", doc });\n                    }\n                }\n            }\n            // Put batch\n            if (puts.length > 0) {\n                return this.store.putBatch(puts, step2, error);\n            }\n            else {\n                return step2();\n            }\n        }, error);\n    }\n    pendingUpserts(success, error) {\n        return this.store.query(function (matches) {\n            const upserts = lodash_1.default.map(matches, (m) => ({\n                doc: m.doc,\n                base: m.base || null\n            }));\n            if (success != null) {\n                return success(upserts);\n            }\n        }, { index: \"col-state\", keyRange: this.store.makeKeyRange({ only: [this.name, \"upserted\"] }), onError: error });\n    }\n    pendingRemoves(success, error) {\n        return this.store.query(function (matches) {\n            if (success != null) {\n                return success(lodash_1.default.map(lodash_1.default.map(matches, \"doc\"), \"_id\"));\n            }\n        }, { index: \"col-state\", keyRange: this.store.makeKeyRange({ only: [this.name, \"removed\"] }), onError: error });\n    }\n    resolveUpserts(upserts, success, error) {\n        // Get items\n        const keys = lodash_1.default.map(upserts, (upsert) => [this.name, upsert.doc._id]);\n        return this.store.getBatch(keys, (records) => {\n            const puts = [];\n            for (let i = 0, end = upserts.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                const record = records[i];\n                // Only safely remove upsert if doc is the same\n                if (record && record.state === \"upserted\") {\n                    if (lodash_1.default.isEqual(record.doc, upserts[i].doc)) {\n                        record.state = \"cached\";\n                        puts.push(record);\n                    }\n                    else {\n                        record.base = upserts[i].doc;\n                        puts.push(record);\n                    }\n                }\n            }\n            // Put all changed items\n            if (puts.length > 0) {\n                return this.store.putBatch(puts, function () {\n                    if (success) {\n                        return success();\n                    }\n                }, error);\n            }\n            else {\n                if (success) {\n                    return success();\n                }\n            }\n        }, error);\n    }\n    resolveRemove(id, success, error) {\n        return this.store.get([this.name, id], (record) => {\n            // Check if exists\n            if (!record) {\n                if (success != null) {\n                    success();\n                }\n                return;\n            }\n            // Only remove if removed\n            if (record.state === \"removed\") {\n                return this.store.remove([this.name, id], function () {\n                    if (success != null) {\n                        return success();\n                    }\n                }, error);\n            }\n        });\n    }\n    // Add but do not overwrite or record as upsert\n    seed(docs, success, error) {\n        if (!lodash_1.default.isArray(docs)) {\n            docs = [docs];\n        }\n        // Create keys to get items\n        const keys = lodash_1.default.map(docs, (doc) => [this.name, doc._id]);\n        // Create batch of puts\n        const puts = [];\n        return this.store.getBatch(keys, (records) => {\n            // Add all non-local that are not upserted or removed\n            for (let i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                const record = records[i];\n                const doc = docs[i];\n                // Check if not present\n                if (record == null) {\n                    puts.push({ col: this.name, state: \"cached\", doc });\n                }\n            }\n            // Put batch\n            if (puts.length > 0) {\n                return this.store.putBatch(puts, () => {\n                    if (success != null) {\n                        return success();\n                    }\n                }, error);\n            }\n            else {\n                if (success != null) {\n                    return success();\n                }\n            }\n        }, error);\n    }\n    // Add but do not overwrite upsert/removed and do not record as upsert\n    cacheOne(doc, success, error) {\n        return this.cacheList([doc], success, error);\n    }\n    cacheList(docs, success, error) {\n        // Create keys to get items\n        const keys = lodash_1.default.map(docs, (doc) => [this.name, doc._id]);\n        // Create batch of puts\n        const puts = [];\n        return this.store.getBatch(keys, (records) => {\n            for (let i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                let record = records[i];\n                const doc = docs[i];\n                // If _rev present, make sure that not overwritten by lower equal _rev\n                if (record && doc._rev && record.doc._rev && doc._rev <= record.doc._rev) {\n                    continue;\n                }\n                if (record == null) {\n                    record = {\n                        col: this.name,\n                        state: \"cached\",\n                        doc\n                    };\n                }\n                if (record.state === \"cached\") {\n                    record.doc = doc;\n                    puts.push(record);\n                }\n            }\n            // Put batch\n            if (puts.length > 0) {\n                return this.store.putBatch(puts, () => {\n                    if (success != null) {\n                        return success();\n                    }\n                }, error);\n            }\n            else {\n                if (success != null) {\n                    return success();\n                }\n            }\n        }, error);\n    }\n    uncache(selector, success, error) {\n        const compiledSelector = utils.compileDocumentSelector(selector);\n        // Get all docs from collection\n        return this.store.query((matches) => {\n            // Filter ones to remove\n            matches = lodash_1.default.filter(matches, (m) => m.state === \"cached\" && compiledSelector(m.doc));\n            const keys = lodash_1.default.map(matches, (m) => [this.name, m.doc._id]);\n            if (keys.length > 0) {\n                return this.store.removeBatch(keys, () => {\n                    if (success != null) {\n                        return success();\n                    }\n                }, error);\n            }\n            else {\n                if (success != null) {\n                    return success();\n                }\n            }\n        }, { index: \"col\", keyRange: this.store.makeKeyRange({ only: this.name }), onError: error });\n    }\n    uncacheList(ids, success, error) {\n        const idIndex = lodash_1.default.keyBy(ids);\n        // Android 2.x requires error callback\n        error = error || function () { };\n        // Get all docs from collection\n        return this.store.query((matches) => {\n            // Filter ones to remove\n            matches = lodash_1.default.filter(matches, (m) => m.state === \"cached\" && idIndex[m.doc._id]);\n            const keys = lodash_1.default.map(matches, (m) => [this.name, m.doc._id]);\n            if (keys.length > 0) {\n                return this.store.removeBatch(keys, () => {\n                    if (success != null) {\n                        return success();\n                    }\n                }, error);\n            }\n            else {\n                if (success != null) {\n                    return success();\n                }\n            }\n        }, { index: \"col\", keyRange: this.store.makeKeyRange({ only: this.name }), onError: error });\n    }\n}\n"]},"metadata":{},"sourceType":"script"}