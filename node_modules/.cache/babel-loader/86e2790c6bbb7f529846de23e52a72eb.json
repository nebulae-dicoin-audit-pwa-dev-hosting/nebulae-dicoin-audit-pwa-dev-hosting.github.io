{"ast":null,"code":"import { feature, featureCollection, point } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\n\nfunction lineIntersect(line1, line2) {\n  var unique = {};\n  var results = []; // First, normalize geometries to features\n  // Then, handle simple 2-vertex segments\n\n  if (line1.type === \"LineString\") {\n    line1 = feature(line1);\n  }\n\n  if (line2.type === \"LineString\") {\n    line2 = feature(line2);\n  }\n\n  if (line1.type === \"Feature\" && line2.type === \"Feature\" && line1.geometry !== null && line2.geometry !== null && line1.geometry.type === \"LineString\" && line2.geometry.type === \"LineString\" && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {\n    var intersect = intersects(line1, line2);\n\n    if (intersect) {\n      results.push(intersect);\n    }\n\n    return featureCollection(results);\n  } // Handles complex GeoJSON Geometries\n\n\n  var tree = rbush();\n  tree.load(lineSegment(line2));\n  featureEach(lineSegment(line1), function (segment) {\n    featureEach(tree.search(segment), function (match) {\n      var intersect = intersects(segment, match);\n\n      if (intersect) {\n        // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n        var key = getCoords(intersect).join(\",\");\n\n        if (!unique[key]) {\n          unique[key] = true;\n          results.push(intersect);\n        }\n      }\n    });\n  });\n  return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\n\n\nfunction intersects(line1, line2) {\n  var coords1 = getCoords(line1);\n  var coords2 = getCoords(line2);\n\n  if (coords1.length !== 2) {\n    throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n  }\n\n  if (coords2.length !== 2) {\n    throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n  }\n\n  var x1 = coords1[0][0];\n  var y1 = coords1[0][1];\n  var x2 = coords1[1][0];\n  var y2 = coords1[1][1];\n  var x3 = coords2[0][0];\n  var y3 = coords2[0][1];\n  var x4 = coords2[1][0];\n  var y4 = coords2[1][1];\n  var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n  var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n  var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n\n  if (denom === 0) {\n    if (numeA === 0 && numeB === 0) {\n      return null;\n    }\n\n    return null;\n  }\n\n  var uA = numeA / denom;\n  var uB = numeB / denom;\n\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n    var x = x1 + uA * (x2 - x1);\n    var y = y1 + uA * (y2 - y1);\n    return point([x, y]);\n  }\n\n  return null;\n}\n\nexport default lineIntersect;","map":null,"metadata":{},"sourceType":"module"}