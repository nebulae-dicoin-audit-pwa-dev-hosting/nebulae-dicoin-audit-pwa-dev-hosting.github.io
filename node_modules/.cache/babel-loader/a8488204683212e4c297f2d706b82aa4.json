{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar async_1 = __importDefault(require(\"async\"));\n\nvar utils = __importStar(require(\"./utils\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar selector_1 = require(\"./selector\");\n\nvar MemoryDb = /*#__PURE__*/function () {\n  // Options are:\n  //  safety: How to protect the in-memory copies: \"clone\" (default) returns a fresh copy but is slow. \"freeze\" returns a frozen version\n  function MemoryDb(options, success) {\n    _classCallCheck(this, MemoryDb);\n\n    this.collections = {};\n    this.options = lodash_1.default.defaults(options, {\n      safety: \"clone\"\n    });\n\n    if (success) {\n      success(this);\n    }\n  }\n\n  _createClass(MemoryDb, [{\n    key: \"addCollection\",\n    value: function addCollection(name, success, error) {\n      var collection = new Collection(name, this.options);\n      this[name] = collection;\n      this.collections[name] = collection;\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"removeCollection\",\n    value: function removeCollection(name, success, error) {\n      delete this[name];\n      delete this.collections[name];\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"getCollectionNames\",\n    value: function getCollectionNames() {\n      return lodash_1.default.keys(this.collections);\n    }\n  }]);\n\n  return MemoryDb;\n}();\n\nexports.default = MemoryDb; // Stores data in memory\n\nvar Collection = /*#__PURE__*/function () {\n  function Collection(name, options) {\n    var _this = this;\n\n    _classCallCheck(this, Collection);\n\n    // Applies safety (either freezing or cloning to object or array)\n    this._applySafety = function (items) {\n      if (!items) {\n        return items;\n      }\n\n      if (lodash_1.default.isArray(items)) {\n        return lodash_1.default.map(items, _this._applySafety);\n      }\n\n      if (_this.options.safety === \"clone\" || !_this.options.safety) {\n        return JSON.parse(JSON.stringify(items));\n      }\n\n      if (_this.options.safety === \"freeze\") {\n        Object.freeze(items);\n        return items;\n      }\n\n      throw new Error(\"Unsupported safety \".concat(_this.options.safety));\n    };\n\n    this.name = name;\n    this.items = {};\n    this.upserts = {}; // Pending upserts by _id. Still in items\n\n    this.removes = {}; // Pending removes by _id. No longer in items\n\n    this.options = options || {};\n  }\n\n  _createClass(Collection, [{\n    key: \"find\",\n    value: function find(selector, options) {\n      var _this2 = this;\n\n      return {\n        fetch: function fetch(success, error) {\n          return _this2._findFetch(selector, options, success, error);\n        }\n      };\n    }\n  }, {\n    key: \"findOne\",\n    value: function findOne(selector, options, success, error) {\n      var _this3 = this;\n\n      if (lodash_1.default.isFunction(options)) {\n        ;\n        var _ref = [{}, options, success];\n        options = _ref[0];\n        success = _ref[1];\n        error = _ref[2];\n      }\n\n      return this.find(selector, options).fetch(function (results) {\n        if (success != null) {\n          return success(_this3._applySafety(results.length > 0 ? results[0] : null));\n        }\n      }, error);\n    }\n  }, {\n    key: \"_findFetch\",\n    value: function _findFetch(selector, options, success, error) {\n      var _this4 = this;\n\n      // Defer to allow other processes to run\n      return setTimeout(function () {\n        // Shortcut if _id is specified\n        var allItems;\n\n        if (selector && selector._id && lodash_1.default.isString(selector._id)) {\n          allItems = lodash_1.default.compact([_this4.items[selector._id]]);\n        } else {\n          allItems = lodash_1.default.values(_this4.items);\n        }\n\n        var results = (0, utils_1.processFind)(allItems, selector, options);\n\n        if (success != null) {\n          return success(_this4._applySafety(results));\n        }\n      }, 0);\n    }\n  }, {\n    key: \"upsert\",\n    value: function upsert(docs, bases, success, error) {\n      var items;\n\n      var _utils$regularizeUpse = utils.regularizeUpsert(docs, bases, success, error);\n\n      var _utils$regularizeUpse2 = _slicedToArray(_utils$regularizeUpse, 3);\n\n      items = _utils$regularizeUpse2[0];\n      success = _utils$regularizeUpse2[1];\n      error = _utils$regularizeUpse2[2];\n      // Keep independent copies to prevent modification\n      items = JSON.parse(JSON.stringify(items));\n\n      var _iterator = _createForOfIteratorHelper(items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n\n          // Fill in base if undefined\n          if (item.base === undefined) {\n            // Use existing base\n            if (this.upserts[item.doc._id]) {\n              item.base = this.upserts[item.doc._id].base;\n            } else {\n              item.base = this.items[item.doc._id] || null;\n            }\n          } // Replace/add\n\n\n          this.items[item.doc._id] = item.doc;\n          this.upserts[item.doc._id] = item;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (lodash_1.default.isArray(docs)) {\n        if (success) {\n          return success(this._applySafety(lodash_1.default.map(items, \"doc\")));\n        }\n      } else {\n        if (success) {\n          return success(this._applySafety(lodash_1.default.map(items, \"doc\")[0]));\n        }\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(id, success, error) {\n      var _this5 = this;\n\n      // Special case for filter-type remove\n      if (lodash_1.default.isObject(id)) {\n        this.find(id).fetch(function (rows) {\n          return async_1.default.each(rows, function (row, cb) {\n            return _this5.remove(row._id, function () {\n              return cb();\n            }, cb);\n          }, function () {\n            return success();\n          });\n        }, error);\n        return;\n      }\n\n      if (lodash_1.default.has(this.items, id)) {\n        this.removes[id] = this.items[id];\n        delete this.items[id];\n        delete this.upserts[id];\n      } else {\n        this.removes[id] = {\n          _id: id\n        };\n      }\n\n      if (success != null) {\n        return success();\n      }\n    } // Options are find options with optional \"exclude\" which is list of _ids to exclude\n\n  }, {\n    key: \"cache\",\n    value: function cache(docs, selector, options, success, error) {\n      var _this6 = this;\n\n      // Add all non-local that are not upserted or removed\n      var sort;\n\n      var _iterator2 = _createForOfIteratorHelper(docs),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var doc = _step2.value;\n\n          // Exclude any excluded _ids from being cached/uncached\n          if (options && options.exclude && options.exclude.includes(doc._id)) {\n            continue;\n          }\n\n          this.cacheOne(doc, function () {}, function () {});\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n\n      if (options.sort) {\n        sort = (0, selector_1.compileSort)(options.sort);\n      } // Perform query, removing rows missing in docs from local db\n\n\n      return this.find(selector, options).fetch(function (results) {\n        var _iterator3 = _createForOfIteratorHelper(results),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var result = _step3.value;\n\n            if (!docsMap[result._id] && !lodash_1.default.has(_this6.upserts, result._id)) {\n              // If at limit\n              if (options.limit && docs.length === options.limit) {\n                // If past end on sorted limited, ignore\n                if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n                  continue;\n                } // If no sort, ignore\n\n\n                if (!options.sort) {\n                  continue;\n                }\n              } // Exclude any excluded _ids from being cached/uncached\n\n\n              if (options && options.exclude && options.exclude.includes(result._id)) {\n                continue;\n              }\n\n              delete _this6.items[result._id];\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        if (success != null) {\n          return success();\n        }\n      }, error);\n    }\n  }, {\n    key: \"pendingUpserts\",\n    value: function pendingUpserts(success) {\n      return success(lodash_1.default.values(this.upserts));\n    }\n  }, {\n    key: \"pendingRemoves\",\n    value: function pendingRemoves(success) {\n      return success(lodash_1.default.map(this.removes, \"_id\"));\n    }\n  }, {\n    key: \"resolveUpserts\",\n    value: function resolveUpserts(upserts, success) {\n      var _iterator4 = _createForOfIteratorHelper(upserts),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var upsert = _step4.value;\n          var id = upsert.doc._id;\n\n          if (this.upserts[id]) {\n            // Only safely remove upsert if doc is unchanged\n            if (lodash_1.default.isEqual(upsert.doc, this.upserts[id].doc)) {\n              delete this.upserts[id];\n            } else {\n              // Just update base\n              this.upserts[id].base = upsert.doc;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"resolveRemove\",\n    value: function resolveRemove(id, success) {\n      delete this.removes[id];\n\n      if (success != null) {\n        return success();\n      }\n    } // Add but do not overwrite or record as upsert\n\n  }, {\n    key: \"seed\",\n    value: function seed(docs, success) {\n      if (!lodash_1.default.isArray(docs)) {\n        docs = [docs];\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(docs),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var doc = _step5.value;\n\n          if (!lodash_1.default.has(this.items, doc._id) && !lodash_1.default.has(this.removes, doc._id)) {\n            this.items[doc._id] = doc;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      if (success != null) {\n        return success();\n      }\n    } // Add but do not overwrite upserts or removes\n\n  }, {\n    key: \"cacheOne\",\n    value: function cacheOne(doc, success, error) {\n      return this.cacheList([doc], success, error);\n    } // Add but do not overwrite upserts or removes\n\n  }, {\n    key: \"cacheList\",\n    value: function cacheList(docs, success, error) {\n      var _iterator6 = _createForOfIteratorHelper(docs),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var doc = _step6.value;\n\n          if (!lodash_1.default.has(this.upserts, doc._id) && !lodash_1.default.has(this.removes, doc._id)) {\n            var existing = this.items[doc._id]; // If _rev present, make sure that not overwritten by lower or equal _rev\n\n            if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n              this.items[doc._id] = doc;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"uncache\",\n    value: function uncache(selector, success, error) {\n      var _this7 = this;\n\n      var compiledSelector = utils.compileDocumentSelector(selector);\n      var items = lodash_1.default.filter(lodash_1.default.values(this.items), function (item) {\n        return _this7.upserts[item._id] != null || !compiledSelector(item);\n      });\n      this.items = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(items, \"_id\"), items));\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"uncacheList\",\n    value: function uncacheList(ids, success, error) {\n      var _this8 = this;\n\n      var idIndex = lodash_1.default.keyBy(ids);\n      var items = lodash_1.default.filter(lodash_1.default.values(this.items), function (item) {\n        return _this8.upserts[item._id] != null || !idIndex[item._id];\n      });\n      this.items = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(items, \"_id\"), items));\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }]);\n\n  return Collection;\n}();","map":null,"metadata":{},"sourceType":"script"}