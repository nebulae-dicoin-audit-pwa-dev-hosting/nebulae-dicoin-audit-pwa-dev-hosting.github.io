{"ast":null,"code":"import { Subject, timer } from 'rxjs';\nimport { takeUntil, tap } from 'rxjs/operators';\nimport _ from 'lodash';\nimport pako from 'pako';\nimport Trip from './Trip';\nimport TransmissionConfig from './TransmissionConfig';\nimport RecordGenerationRules from './RecordGenerationRules';\nimport RecordTransmitter from './RecordTransmitter';\nimport EVENT_TYPES from './EventTypes';\nimport { MinimongoDB } from './MinimongoDB/MinimongoDB';\nimport TripDA from './data-access/TripDA';\nimport RecordDA from './data-access/RecordDA';\n\nclass Dicoin {\n  constructor() {\n    this.eventListeners = {};\n    this.records$ = new Subject();\n    this.stopSubject$ = new Subject();\n    this.stopTransmissionSubject$ = new Subject();\n    this.recordTransmitter = new RecordTransmitter(this);\n    this.db = new MinimongoDB(['Trip', 'Record'], () => {\n      this.emitEvent(EVENT_TYPES.DB_STARTED);\n    });\n  }\n\n  tripErrorReporter(msg) {\n    this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n      message: msg\n    });\n  }\n\n  clearTrip() {\n    this.trip.records = [];\n    this.tripStarted = false;\n    this.recordTransmisionStarted = false;\n    this.trip = null;\n    this.transmissionConfig = null;\n    this.recordGenerationRules = null;\n    this.emitEvent(EVENT_TYPES.TRIP_REMOVED, {});\n    TripDA.removeTrip();\n    RecordDA.removeRecords();\n  }\n  /*\n   *******************************\n   *** RECOVER PERSISTED STATE ***\n   *******************************\n   */\n\n\n  async recoverPersistedState() {\n    // obtengo el trip\n    const prevTrip = await TripDA.getPrevTrip().then(r => r);\n\n    if (prevTrip) {\n      const {\n        routeCode,\n        route,\n        vehiclePlate,\n        driverDocument,\n        companyId,\n        state,\n        tempState,\n        recordSeq,\n        transmissionConfig,\n        recordGenerationRules,\n        _id\n      } = prevTrip; // creo el trip\n\n      this.trip = new Trip(routeCode, route, vehiclePlate, driverDocument, companyId, msg => {\n        this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n          message: msg\n        });\n      });\n      this.trip.tempState = tempState;\n      this.trip.state = state || {};\n      this.trip.state.endTimestamp = prevTrip.endTimestamp;\n      this.tripStarted = true; // seteo el Id del trip  y recordSeq\n\n      this.trip._id = _id;\n      this.trip.recordSeq = recordSeq; // seteo las reglas y configuraciones\n\n      const {\n        online,\n        endPoint,\n        user,\n        password,\n        maxRetries,\n        delayBetweenRetries\n      } = transmissionConfig || {};\n      const {\n        distanceThreshold,\n        timeThreshold,\n        speedThreshold,\n        useDoorStateAsTrigger\n      } = recordGenerationRules || {};\n      this.transmissionConfig = new TransmissionConfig(online, endPoint, user, password, maxRetries, delayBetweenRetries, msg => {\n        this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n          message: msg\n        });\n      });\n\n      if (prevTrip.tripState !== 'FINALIZED') {\n        this.startRecordGenerationByTime();\n      }\n\n      if (this.transmissionConfig.online) {\n        this.recordTransmitter.startRecordTransmission();\n      }\n\n      this.emitEvent(EVENT_TYPES.TRIP_TYPE_REPORTED, {\n        online\n      });\n      this.recordGenerationRules = new RecordGenerationRules(distanceThreshold, timeThreshold, speedThreshold, useDoorStateAsTrigger, (recordGenerationRules || {}).accumulatorTimeThreshold || 2000, msg => {\n        this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n          message: msg\n        });\n      });\n      this.trip.transmissionConfig = this.transmissionConfig;\n      this.trip.recordGenerationRules = this.recordGenerationRules;\n      this.emitEvent(EVENT_TYPES.TRIP_LOADED, {\n        tempState: this.trip.tempState,\n        state: this.trip.state,\n        tripState: prevTrip.tripState,\n        reason: prevTrip.reason\n      }); // obtengo los records de ese trip\n\n      const prevRecords = await RecordDA.getPrevRecords(prevTrip._id).then(r => r);\n\n      if (prevRecords && prevRecords.length > 0) {\n        this.trip.records = [];\n\n        for (const currentRecord of prevRecords) {\n          let normalizedRecord = currentRecord;\n\n          if (currentRecord.type === 'RECORD') {\n            normalizedRecord = {\n              _id: currentRecord._id,\n              state: currentRecord.state,\n              type: currentRecord.type,\n              recordSeq: currentRecord.recordSeq,\n              endState: currentRecord.endState,\n              endTimestamp: currentRecord.tripState.endTimestamp,\n              timestamp: currentRecord.timestamp,\n              tripTempState: {\n                geolocationPosition: currentRecord.payload.geolocationPosition,\n                frontDoorOpen: currentRecord.payload.frontDoorOpen,\n                backDoorOpen: currentRecord.payload.backDoorOpen,\n                frontDoorInput: currentRecord.payload.frontDoorInput,\n                frontDoorOutput: currentRecord.payload.frontDoorOutput,\n                backDoorInput: currentRecord.payload.backDoorInput,\n                backDoorOutput: currentRecord.payload.backDoorOutput,\n                traveledDistance: currentRecord.tripState.tempStateTraveledDistance,\n                timestamp: currentRecord.tripState.timestamp\n              },\n              stats: currentRecord.stats\n            };\n          } else {\n            normalizedRecord = {\n              _id: currentRecord._id,\n              type: currentRecord.type,\n              timestamp: currentRecord.timestamp,\n              note: currentRecord.payload.note\n            };\n          }\n\n          if (currentRecord.type === 'RECORD' && currentRecord.state !== 'SENT' && normalizedRecord.stats.retryAttempt < this.transmissionConfig.maxRetries) {\n            this.records$.next({\n              localRecord: normalizedRecord,\n              extendedRecord: currentRecord\n            });\n          }\n\n          this.trip.records.push(normalizedRecord);\n        }\n\n        this.emitEvent(EVENT_TYPES.RECORD_GENERATED, {\n          records: this.trip.records\n        });\n      }\n    }\n  }\n\n  async reportTripState() {\n    const prevTrip = await TripDA.getPrevTrip().then(r => r);\n\n    if (prevTrip) {\n      const prevRecords = await RecordDA.getPrevRecords(prevTrip._id).then(r => r);\n\n      if (prevRecords && prevRecords.length > 0) {\n        const recordsLength = prevRecords.length;\n        const firstRecord = prevRecords[0];\n        const lastRecord = prevRecords[recordsLength - 1];\n        const base = { ...firstRecord.authorityPayload,\n          stats: undefined,\n          eventos: [],\n          estado: lastRecord.authorityPayload.estado,\n          fin_viaje: lastRecord.authorityPayload.fin_viaje\n        };\n\n        for (const record of prevRecords) {\n          const {\n            authorityPayload: {\n              eventos\n            }\n          } = record;\n          base.eventos = [...base.eventos, ...eventos];\n        }\n\n        this.recordTransmitter.sendTripOnBatch(firstRecord._id, base);\n      }\n    }\n  }\n\n  async generateContentReport() {\n    const prevTrip = await TripDA.getPrevTrip().then(r => r);\n\n    if (prevTrip) {\n      const prevRecords = await RecordDA.getPrevRecords(prevTrip._id).then(r => r);\n\n      if (prevRecords && prevRecords.length > 0) {\n        const dataAsString = JSON.stringify(prevRecords);\n        const dataDeflated = pako.deflate(dataAsString);\n        const dataAsBase64 = Buffer.from(dataDeflated).toString('base64');\n        const blobFile = new Blob([dataAsBase64], {\n          type: 'text/plain'\n        });\n        this.emitEvent(EVENT_TYPES.TRIP_REPORT_GENERATED, {\n          reportContent: blobFile,\n          fileName: `${prevTrip._id}.neb`\n        });\n      }\n    }\n  }\n  /*\n   ***************************************************************************\n   *** START/STOP TRIP + ADD/REMOVE/SEND EVENT-LISTENER  + GET-STATE-CLONE ***\n   ***************************************************************************\n   */\n\n  /**\n   * Starts a new Trip\n   * @param {Trip} trip\n   * @param {RecordGenerationRules} recordGenerationRules\n   * @param {TransmissionConfig} transmissionConfig\n   */\n\n\n  async startTrip(trip, transmissionConfig, recordGenerationRules) {\n    if (this.tripStarted) {\n      this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n        message: 'ERROR_TRIP_ALREADY_STARTED'\n      });\n    } else if (this.recordTransmisionStarted) {\n      this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n        message: 'ERROR_RECORDS_PENDING_FOR_TRANSMISSIONT'\n      });\n    } else {\n      const args = Array.from(arguments);\n\n      if (args.lenngth < 3 || args.some(arg => arg === undefined || arg === null)) {\n        this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n          message: 'ERROR_MISSING_ARGUMENTS'\n        });\n      } else {\n        this.trip = _.cloneDeep(trip);\n        this.trip._id = this.buildTripId();\n        this.transmissionConfig = _.cloneDeep(transmissionConfig);\n        this.recordGenerationRules = _.cloneDeep(recordGenerationRules);\n        this.trip.transmissionConfig = this.transmissionConfig;\n        this.trip.recordGenerationRules = this.recordGenerationRules;\n        this.tripStarted = true;\n        const wasTripPersisted = await this.buildTripAndPersist().then(r => r);\n\n        if (!wasTripPersisted) {\n          this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n            message: 'ERROR_TRIṔ_COULD_NOT_BE_PERSISTED'\n          });\n        } else {\n          this.startRecordGenerationByTime();\n\n          if (this.transmissionConfig.online) {\n            this.recordTransmitter.startRecordTransmission();\n          }\n\n          this.emitEvent(EVENT_TYPES.TRIP_STARTED, {\n            tempState: this.trip.tempState,\n            state: this.trip.state\n          });\n        }\n      }\n    }\n  }\n\n  buildTripId() {\n    const companyId = this.trip.companyId.replace('-', '');\n    const plate = this.trip.vehiclePlate;\n    const currentDate = new Date(this.trip.state.timestamp);\n    const mm = currentDate.getMonth() + 1;\n    const dd = currentDate.getDate();\n    const year = currentDate.getFullYear();\n    const hour = currentDate.getHours();\n    const minutes = currentDate.getMinutes();\n    const seconds = currentDate.getSeconds();\n    const milisegundos = currentDate.getMilliseconds(); // return `0-${companyId}-${plate}-${(dd > 9 ? '' : '0') + dd}${(mm > 9 ? '' : '0') + mm}${year}-${\n    //   (hour > 9 ? '' : '0') + hour\n    // }${(minutes > 9 ? '' : '0') + minutes}${(seconds > 9 ? '' : '0') + seconds}-${milisegundos}`;\n\n    return `0-${companyId}-${(dd > 9 ? '' : '0') + dd}${(mm > 9 ? '' : '0') + mm}${year}-${(hour > 9 ? '' : '0') + hour}${(minutes > 9 ? '' : '0') + minutes}${(seconds > 9 ? '' : '0') + seconds}-00${milisegundos}`;\n  }\n\n  async buildTripAndPersist() {\n    const currentTrip = {\n      _id: this.trip._id,\n      routeCode: this.trip.routeCode,\n      route: this.trip.route,\n      vehiclePlate: this.trip.vehiclePlate,\n      driverDocument: this.trip.driverDocument,\n      companyId: this.trip.companyId,\n      state: this.trip.state,\n      tempState: this.trip.tempState,\n      recordSeq: this.trip.recordSeq,\n      transmissionConfig: this.trip.transmissionConfig,\n      recordGenerationRules: this.trip.recordGenerationRules\n    };\n    const insertResult = await TripDA.insertTrip(currentTrip).then(r => r);\n    return insertResult;\n  }\n\n  stopTrip(reason) {\n    let stopTransmission = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let finalize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (this.trip && this.trip._id && this.trip.tempState && this.trip.state && this.trip.tempState.geolocationPosition && this.trip.records) {\n      const endTimestamp = Date.now();\n\n      if (finalize) {\n        const {\n          record,\n          extendedRecord\n        } = this.trip.generateFinalRecord(endTimestamp, reason);\n        this.records$.next({\n          localRecord: record,\n          extendedRecord\n        });\n        this.emitEvent(EVENT_TYPES.RECORD_GENERATED, {\n          records: this.trip.records,\n          record\n        });\n        this.records$.next('STOPPED');\n        this.trip.reportTripStoped(reason, endTimestamp);\n        this.tripStarted = false;\n      }\n\n      this.stopSubject$.next({});\n      this.emitEvent(EVENT_TYPES.TRIP_STOPPED, {\n        tempState: this.trip.tempState,\n        state: this.trip.state\n      });\n      if (stopTransmission) this.stopTransmissionSubject$.next({});\n      Dicoin.log('stopped');\n    }\n  }\n\n  addListener(key, onEvent) {\n    this.eventListeners[key] = onEvent;\n  }\n\n  removeListener(key) {\n    delete this.eventListeners[key];\n  }\n\n  emitEvent(type, payload) {\n    Object.values(this.eventListeners).forEach(onEvent => onEvent({\n      type,\n      payload\n    }));\n  }\n\n  getStateClone() {\n    return _.cloneDeep({\n      trip: this.trip,\n      transmissionConfig: this.transmissionConfig,\n      recordGenerationRules: this.recordGenerationRules\n    });\n  }\n  /*\n   ************************\n   *** RECORD GENERATOR ***\n   ************************\n   */\n\n\n  startRecordGenerationByTime() {\n    timer(1000, 1000).pipe(tap(() => this.evalTimeOnlyAndGenerateRecord()), takeUntil(this.stopSubject$)).subscribe(evt => {// Dicoin.log('startRecordGenerationByTime evt = ', evt);\n    }, err => console.error('RecordGenerationByTime.ERR', err), () => {\n      Dicoin.log('STOPPED RecordGenerationByTime');\n      this.tripStarted = false;\n    });\n  }\n\n  evalAndGenerateRecord() {\n    let doorStateChanged = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      distanceThreshold,\n      timeThreshold,\n      speedThreshold,\n      useDoorStateAsTrigger\n    } = this.recordGenerationRules;\n    const tripTempState = this.trip.tempState;\n    let {\n      speed\n    } = (tripTempState.geolocationPosition || {}).coords || {};\n    speed = speed === undefined ? speed : Dicoin.metersPerSecondToKilometersPerHour(speed);\n    const triggeredbyDoors = doorStateChanged && useDoorStateAsTrigger;\n    const triggeredbyDistance = tripTempState.traveledDistance >= distanceThreshold;\n    const triggeredbyTime = Date.now() - tripTempState.timestamp >= timeThreshold;\n    const triggeredbySpeed = speed <= speedThreshold;\n\n    if (triggeredbyDoors || triggeredbyDistance || triggeredbyTime || triggeredbySpeed) {\n      this.generateRecord({\n        triggeredbyDoors,\n        triggeredbyDistance,\n        triggeredbyTime,\n        triggeredbySpeed\n      });\n    }\n  }\n\n  evalTimeOnlyAndGenerateRecord() {\n    const {\n      timeThreshold\n    } = this.recordGenerationRules;\n    const tripTempState = this.trip.tempState;\n    const triggeredbyTime = Date.now() - tripTempState.timestamp >= timeThreshold;\n\n    if (triggeredbyTime) {\n      this.evalAndGenerateRecord();\n      this.emitEvent(EVENT_TYPES.TRIP_STATE_CHANGED, {\n        tempState: this.trip.tempState,\n        state: this.trip.state\n      });\n    }\n  }\n\n  generateRecord(reasons) {\n    Dicoin.log('generateRecord', `reason=${JSON.stringify(reasons)}`);\n\n    if (this.trip.tempState.geolocationPosition) {\n      const {\n        record,\n        extendedRecord\n      } = this.trip.generateRecord();\n      this.records$.next({\n        localRecord: record,\n        extendedRecord\n      });\n      this.emitEvent(EVENT_TYPES.RECORD_GENERATED, {\n        records: this.trip.records,\n        record\n      });\n    }\n  }\n\n  getRecordAttemptsLatencyAverage(record) {\n    const attepms = record.stats.attempts || [];\n    const attempsLength = attepms.length;\n    const latencyTotal = attepms.reduce((acc, val) => acc + (val.latency || 0), 0);\n    return latencyTotal && attempsLength ? latencyTotal / attempsLength : 0;\n  }\n\n  getRecordAttemptsLatencySum(record) {\n    const attepms = record.stats.attempts || [];\n    if (attepms.length === 0) return '--';\n    const latencyTotal = attepms.reduce((acc, val) => acc + (val.latency || 0), 0);\n    return latencyTotal;\n  }\n\n  addNote(noteContent) {\n    const note = this.trip.addNote(noteContent);\n    this.emitEvent(EVENT_TYPES.NOTE_ADDED, {\n      records: this.trip.records,\n      note\n    });\n  }\n  /*\n   *************************************************\n   ********** TRIP REPORT FORWARDS *****************\n   *************************************************\n   */\n\n\n  reportGeolocationPosition(geolocationPosition) {\n    this.trip.reportGeolocationPosition(geolocationPosition); // this.evalAndGenerateRecord();\n\n    this.emitEvent(EVENT_TYPES.TRIP_STATE_CHANGED, {\n      tempState: this.trip.tempState,\n      state: this.trip.state\n    });\n  }\n\n  reportDoorsStatus(frontDoorOpen, backDoorOpen) {\n    if (this.trip.state.frontDoorOpen !== frontDoorOpen || this.trip.state.backDoorOpen !== backDoorOpen) this.trip.reportDoorsStatus(frontDoorOpen, backDoorOpen);\n    this.evalAndGenerateRecord(true);\n    this.emitEvent(EVENT_TYPES.TRIP_STATE_CHANGED, {\n      tempState: this.trip.tempState,\n      state: this.trip.state\n    });\n  }\n\n  reportPassengerFlow(frontDoorInput, frontDoorOutput, backDoorInput, backDoorOutput) {\n    this.trip.reportPassengerFlow(frontDoorInput, frontDoorOutput, backDoorInput, backDoorOutput);\n    this.emitEvent(EVENT_TYPES.TRIP_STATE_CHANGED, {\n      tempState: this.trip.tempState,\n      state: this.trip.state\n    });\n  }\n  /*\n   *************************************************\n   ****************** TOOLS ************************\n   *************************************************\n   */\n\n\n  static log() {\n    for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {\n      data[_key] = arguments[_key];\n    }\n\n    console.log('Dicoin:', ...data);\n  }\n\n  static metersPerSecondToKilometersPerHour(metersPerSecond) {\n    return parseInt(3.6 * metersPerSecond, 10);\n  }\n\n}\n/**\n * @returns {Dicoin}\n */\n\n\nexport default Dicoin;","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/src/app/main/travels/tools/dicoin-engine/Dicoin.js"],"names":["Subject","timer","takeUntil","tap","_","pako","Trip","TransmissionConfig","RecordGenerationRules","RecordTransmitter","EVENT_TYPES","MinimongoDB","TripDA","RecordDA","Dicoin","constructor","eventListeners","records$","stopSubject$","stopTransmissionSubject$","recordTransmitter","db","emitEvent","DB_STARTED","tripErrorReporter","msg","ERROR_REPORTED","message","clearTrip","trip","records","tripStarted","recordTransmisionStarted","transmissionConfig","recordGenerationRules","TRIP_REMOVED","removeTrip","removeRecords","recoverPersistedState","prevTrip","getPrevTrip","then","r","routeCode","route","vehiclePlate","driverDocument","companyId","state","tempState","recordSeq","_id","endTimestamp","online","endPoint","user","password","maxRetries","delayBetweenRetries","distanceThreshold","timeThreshold","speedThreshold","useDoorStateAsTrigger","tripState","startRecordGenerationByTime","startRecordTransmission","TRIP_TYPE_REPORTED","accumulatorTimeThreshold","TRIP_LOADED","reason","prevRecords","getPrevRecords","length","currentRecord","normalizedRecord","type","endState","timestamp","tripTempState","geolocationPosition","payload","frontDoorOpen","backDoorOpen","frontDoorInput","frontDoorOutput","backDoorInput","backDoorOutput","traveledDistance","tempStateTraveledDistance","stats","note","retryAttempt","next","localRecord","extendedRecord","push","RECORD_GENERATED","reportTripState","recordsLength","firstRecord","lastRecord","base","authorityPayload","undefined","eventos","estado","fin_viaje","record","sendTripOnBatch","generateContentReport","dataAsString","JSON","stringify","dataDeflated","deflate","dataAsBase64","Buffer","from","toString","blobFile","Blob","TRIP_REPORT_GENERATED","reportContent","fileName","startTrip","args","Array","arguments","lenngth","some","arg","cloneDeep","buildTripId","wasTripPersisted","buildTripAndPersist","TRIP_STARTED","replace","plate","currentDate","Date","mm","getMonth","dd","getDate","year","getFullYear","hour","getHours","minutes","getMinutes","seconds","getSeconds","milisegundos","getMilliseconds","currentTrip","insertResult","insertTrip","stopTrip","stopTransmission","finalize","now","generateFinalRecord","reportTripStoped","TRIP_STOPPED","log","addListener","key","onEvent","removeListener","Object","values","forEach","getStateClone","pipe","evalTimeOnlyAndGenerateRecord","subscribe","evt","err","console","error","evalAndGenerateRecord","doorStateChanged","speed","coords","metersPerSecondToKilometersPerHour","triggeredbyDoors","triggeredbyDistance","triggeredbyTime","triggeredbySpeed","generateRecord","TRIP_STATE_CHANGED","reasons","getRecordAttemptsLatencyAverage","attepms","attempts","attempsLength","latencyTotal","reduce","acc","val","latency","getRecordAttemptsLatencySum","addNote","noteContent","NOTE_ADDED","reportGeolocationPosition","reportDoorsStatus","reportPassengerFlow","data","metersPerSecond","parseInt"],"mappings":"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","sourcesContent":["import { Subject, timer } from 'rxjs';\nimport { takeUntil, tap } from 'rxjs/operators';\nimport _ from 'lodash';\nimport pako from 'pako';\nimport Trip from './Trip';\nimport TransmissionConfig from './TransmissionConfig';\nimport RecordGenerationRules from './RecordGenerationRules';\nimport RecordTransmitter from './RecordTransmitter';\nimport EVENT_TYPES from './EventTypes';\nimport { MinimongoDB } from './MinimongoDB/MinimongoDB';\nimport TripDA from './data-access/TripDA';\nimport RecordDA from './data-access/RecordDA';\n\nclass Dicoin {\n  constructor() {\n    this.eventListeners = {};\n    this.records$ = new Subject();\n    this.stopSubject$ = new Subject();\n    this.stopTransmissionSubject$ = new Subject();\n    this.recordTransmitter = new RecordTransmitter(this);\n    this.db = new MinimongoDB(['Trip', 'Record'], () => {\n      this.emitEvent(EVENT_TYPES.DB_STARTED);\n    });\n  }\n\n  tripErrorReporter(msg) {\n    this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n      message: msg,\n    });\n  }\n\n  clearTrip() {\n    this.trip.records = [];\n    this.tripStarted = false;\n    this.recordTransmisionStarted = false;\n    this.trip = null;\n    this.transmissionConfig = null;\n    this.recordGenerationRules = null;\n    this.emitEvent(EVENT_TYPES.TRIP_REMOVED, {});\n    TripDA.removeTrip();\n    RecordDA.removeRecords();\n  }\n\n  /*\n   *******************************\n   *** RECOVER PERSISTED STATE ***\n   *******************************\n   */\n  async recoverPersistedState() {\n    // obtengo el trip\n    const prevTrip = await TripDA.getPrevTrip().then((r) => r);\n    if (prevTrip) {\n      const {\n        routeCode,\n        route,\n        vehiclePlate,\n        driverDocument,\n        companyId,\n        state,\n        tempState,\n        recordSeq,\n        transmissionConfig,\n        recordGenerationRules,\n        _id,\n      } = prevTrip;\n      // creo el trip\n      this.trip = new Trip(routeCode, route, vehiclePlate, driverDocument, companyId, (msg) => {\n        this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n          message: msg,\n        });\n      });\n      this.trip.tempState = tempState;\n      this.trip.state = state || {};\n      this.trip.state.endTimestamp = prevTrip.endTimestamp;\n      this.tripStarted = true;\n      // seteo el Id del trip  y recordSeq\n      this.trip._id = _id;\n      this.trip.recordSeq = recordSeq;\n      // seteo las reglas y configuraciones\n      const { online, endPoint, user, password, maxRetries, delayBetweenRetries } =\n        transmissionConfig || {};\n      const { distanceThreshold, timeThreshold, speedThreshold, useDoorStateAsTrigger } =\n        recordGenerationRules || {};\n      this.transmissionConfig = new TransmissionConfig(\n        online,\n        endPoint,\n        user,\n        password,\n        maxRetries,\n        delayBetweenRetries,\n        (msg) => {\n          this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n            message: msg,\n          });\n        }\n      );\n      if (prevTrip.tripState !== 'FINALIZED') {\n        this.startRecordGenerationByTime();\n      }\n      if (this.transmissionConfig.online) {\n        this.recordTransmitter.startRecordTransmission();\n      }\n      this.emitEvent(EVENT_TYPES.TRIP_TYPE_REPORTED, { online });\n      this.recordGenerationRules = new RecordGenerationRules(\n        distanceThreshold,\n        timeThreshold,\n        speedThreshold,\n        useDoorStateAsTrigger,\n        (recordGenerationRules || {}).accumulatorTimeThreshold || 2000,\n        (msg) => {\n          this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n            message: msg,\n          });\n        }\n      );\n      this.trip.transmissionConfig = this.transmissionConfig;\n      this.trip.recordGenerationRules = this.recordGenerationRules;\n\n      this.emitEvent(EVENT_TYPES.TRIP_LOADED, {\n        tempState: this.trip.tempState,\n        state: this.trip.state,\n        tripState: prevTrip.tripState,\n        reason: prevTrip.reason,\n      });\n\n      // obtengo los records de ese trip\n      const prevRecords = await RecordDA.getPrevRecords(prevTrip._id).then((r) => r);\n      if (prevRecords && prevRecords.length > 0) {\n        this.trip.records = [];\n\n        for (const currentRecord of prevRecords) {\n          let normalizedRecord = currentRecord;\n          if (currentRecord.type === 'RECORD') {\n            normalizedRecord = {\n              _id: currentRecord._id,\n              state: currentRecord.state,\n              type: currentRecord.type,\n              recordSeq: currentRecord.recordSeq,\n              endState: currentRecord.endState,\n              endTimestamp: currentRecord.tripState.endTimestamp,\n              timestamp: currentRecord.timestamp,\n              tripTempState: {\n                geolocationPosition: currentRecord.payload.geolocationPosition,\n                frontDoorOpen: currentRecord.payload.frontDoorOpen,\n                backDoorOpen: currentRecord.payload.backDoorOpen,\n                frontDoorInput: currentRecord.payload.frontDoorInput,\n                frontDoorOutput: currentRecord.payload.frontDoorOutput,\n                backDoorInput: currentRecord.payload.backDoorInput,\n                backDoorOutput: currentRecord.payload.backDoorOutput,\n                traveledDistance: currentRecord.tripState.tempStateTraveledDistance,\n                timestamp: currentRecord.tripState.timestamp,\n              },\n              stats: currentRecord.stats,\n            };\n          } else {\n            normalizedRecord = {\n              _id: currentRecord._id,\n              type: currentRecord.type,\n              timestamp: currentRecord.timestamp,\n              note: currentRecord.payload.note,\n            };\n          }\n          if (\n            currentRecord.type === 'RECORD' &&\n            currentRecord.state !== 'SENT' &&\n            normalizedRecord.stats.retryAttempt < this.transmissionConfig.maxRetries\n          ) {\n            this.records$.next({ localRecord: normalizedRecord, extendedRecord: currentRecord });\n          }\n          this.trip.records.push(normalizedRecord);\n        }\n        this.emitEvent(EVENT_TYPES.RECORD_GENERATED, { records: this.trip.records });\n      }\n    }\n  }\n\n  async reportTripState() {\n    const prevTrip = await TripDA.getPrevTrip().then((r) => r);\n    if (prevTrip) {\n      const prevRecords = await RecordDA.getPrevRecords(prevTrip._id).then((r) => r);\n      if (prevRecords && prevRecords.length > 0) {\n        const recordsLength = prevRecords.length;\n        const firstRecord = prevRecords[0];\n        const lastRecord = prevRecords[recordsLength - 1];\n        const base = {\n          ...firstRecord.authorityPayload,\n          stats: undefined,\n          eventos: [],\n          estado: lastRecord.authorityPayload.estado,\n          fin_viaje: lastRecord.authorityPayload.fin_viaje,\n        };\n        for (const record of prevRecords) {\n          const {\n            authorityPayload: { eventos },\n          } = record;\n          base.eventos = [...base.eventos, ...eventos];\n        }\n        this.recordTransmitter.sendTripOnBatch(firstRecord._id, base);\n      }\n    }\n  }\n\n  async generateContentReport() {\n    const prevTrip = await TripDA.getPrevTrip().then((r) => r);\n    if (prevTrip) {\n      const prevRecords = await RecordDA.getPrevRecords(prevTrip._id).then((r) => r);\n      if (prevRecords && prevRecords.length > 0) {\n        const dataAsString = JSON.stringify(prevRecords);\n        const dataDeflated = pako.deflate(dataAsString);\n        const dataAsBase64 = Buffer.from(dataDeflated).toString('base64');\n        const blobFile = new Blob([dataAsBase64], {\n          type: 'text/plain',\n        });\n        this.emitEvent(EVENT_TYPES.TRIP_REPORT_GENERATED, {\n          reportContent: blobFile,\n          fileName: `${prevTrip._id}.neb`,\n        });\n      }\n    }\n  }\n\n  /*\n   ***************************************************************************\n   *** START/STOP TRIP + ADD/REMOVE/SEND EVENT-LISTENER  + GET-STATE-CLONE ***\n   ***************************************************************************\n   */\n\n  /**\n   * Starts a new Trip\n   * @param {Trip} trip\n   * @param {RecordGenerationRules} recordGenerationRules\n   * @param {TransmissionConfig} transmissionConfig\n   */\n  async startTrip(trip, transmissionConfig, recordGenerationRules) {\n    if (this.tripStarted) {\n      this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n        message: 'ERROR_TRIP_ALREADY_STARTED',\n      });\n    } else if (this.recordTransmisionStarted) {\n      this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n        message: 'ERROR_RECORDS_PENDING_FOR_TRANSMISSIONT',\n      });\n    } else {\n      const args = Array.from(arguments);\n      if (args.lenngth < 3 || args.some((arg) => arg === undefined || arg === null)) {\n        this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n          message: 'ERROR_MISSING_ARGUMENTS',\n        });\n      } else {\n        this.trip = _.cloneDeep(trip);\n        this.trip._id = this.buildTripId();\n        this.transmissionConfig = _.cloneDeep(transmissionConfig);\n        this.recordGenerationRules = _.cloneDeep(recordGenerationRules);\n        this.trip.transmissionConfig = this.transmissionConfig;\n        this.trip.recordGenerationRules = this.recordGenerationRules;\n        this.tripStarted = true;\n        const wasTripPersisted = await this.buildTripAndPersist().then((r) => r);\n        if (!wasTripPersisted) {\n          this.emitEvent(EVENT_TYPES.ERROR_REPORTED, {\n            message: 'ERROR_TRIṔ_COULD_NOT_BE_PERSISTED',\n          });\n        } else {\n          this.startRecordGenerationByTime();\n          if (this.transmissionConfig.online) {\n            this.recordTransmitter.startRecordTransmission();\n          }\n\n          this.emitEvent(EVENT_TYPES.TRIP_STARTED, {\n            tempState: this.trip.tempState,\n            state: this.trip.state,\n          });\n        }\n      }\n    }\n  }\n\n  buildTripId() {\n    const companyId = this.trip.companyId.replace('-', '');\n    const plate = this.trip.vehiclePlate;\n    const currentDate = new Date(this.trip.state.timestamp);\n\n    const mm = currentDate.getMonth() + 1;\n    const dd = currentDate.getDate();\n    const year = currentDate.getFullYear();\n    const hour = currentDate.getHours();\n    const minutes = currentDate.getMinutes();\n    const seconds = currentDate.getSeconds();\n    const milisegundos = currentDate.getMilliseconds();\n    // return `0-${companyId}-${plate}-${(dd > 9 ? '' : '0') + dd}${(mm > 9 ? '' : '0') + mm}${year}-${\n    //   (hour > 9 ? '' : '0') + hour\n    // }${(minutes > 9 ? '' : '0') + minutes}${(seconds > 9 ? '' : '0') + seconds}-${milisegundos}`;\n\n    return `0-${companyId}-${(dd > 9 ? '' : '0') + dd}${(mm > 9 ? '' : '0') + mm}${year}-${\n      (hour > 9 ? '' : '0') + hour\n    }${(minutes > 9 ? '' : '0') + minutes}${(seconds > 9 ? '' : '0') + seconds}-00${milisegundos}`;\n  }\n\n  async buildTripAndPersist() {\n    const currentTrip = {\n      _id: this.trip._id,\n      routeCode: this.trip.routeCode,\n      route: this.trip.route,\n      vehiclePlate: this.trip.vehiclePlate,\n      driverDocument: this.trip.driverDocument,\n      companyId: this.trip.companyId,\n      state: this.trip.state,\n      tempState: this.trip.tempState,\n      recordSeq: this.trip.recordSeq,\n      transmissionConfig: this.trip.transmissionConfig,\n      recordGenerationRules: this.trip.recordGenerationRules,\n    };\n    const insertResult = await TripDA.insertTrip(currentTrip).then((r) => r);\n    return insertResult;\n  }\n\n  stopTrip(reason, stopTransmission = false, finalize = false) {\n    if (\n      this.trip &&\n      this.trip._id &&\n      this.trip.tempState &&\n      this.trip.state &&\n      this.trip.tempState.geolocationPosition &&\n      this.trip.records\n    ) {\n      const endTimestamp = Date.now();\n      if (finalize) {\n        const { record, extendedRecord } = this.trip.generateFinalRecord(endTimestamp, reason);\n        this.records$.next({ localRecord: record, extendedRecord });\n        this.emitEvent(EVENT_TYPES.RECORD_GENERATED, { records: this.trip.records, record });\n        this.records$.next('STOPPED');\n        this.trip.reportTripStoped(reason, endTimestamp);\n        this.tripStarted = false;\n      }\n      this.stopSubject$.next({});\n      this.emitEvent(EVENT_TYPES.TRIP_STOPPED, {\n        tempState: this.trip.tempState,\n        state: this.trip.state,\n      });\n      if (stopTransmission) this.stopTransmissionSubject$.next({});\n      Dicoin.log('stopped');\n    }\n  }\n\n  addListener(key, onEvent) {\n    this.eventListeners[key] = onEvent;\n  }\n\n  removeListener(key) {\n    delete this.eventListeners[key];\n  }\n\n  emitEvent(type, payload) {\n    Object.values(this.eventListeners).forEach((onEvent) => onEvent({ type, payload }));\n  }\n\n  getStateClone() {\n    return _.cloneDeep({\n      trip: this.trip,\n      transmissionConfig: this.transmissionConfig,\n      recordGenerationRules: this.recordGenerationRules,\n    });\n  }\n\n  /*\n   ************************\n   *** RECORD GENERATOR ***\n   ************************\n   */\n  startRecordGenerationByTime() {\n    timer(1000, 1000)\n      .pipe(\n        tap(() => this.evalTimeOnlyAndGenerateRecord()),\n        takeUntil(this.stopSubject$)\n      )\n      .subscribe(\n        (evt) => {\n          // Dicoin.log('startRecordGenerationByTime evt = ', evt);\n        },\n        (err) => console.error('RecordGenerationByTime.ERR', err),\n        () => {\n          Dicoin.log('STOPPED RecordGenerationByTime');\n          this.tripStarted = false;\n        }\n      );\n  }\n\n  evalAndGenerateRecord(doorStateChanged = false) {\n    const { distanceThreshold, timeThreshold, speedThreshold, useDoorStateAsTrigger } =\n      this.recordGenerationRules;\n\n    const tripTempState = this.trip.tempState;\n    let { speed } = (tripTempState.geolocationPosition || {}).coords || {};\n    speed = speed === undefined ? speed : Dicoin.metersPerSecondToKilometersPerHour(speed);\n\n    const triggeredbyDoors = doorStateChanged && useDoorStateAsTrigger;\n    const triggeredbyDistance = tripTempState.traveledDistance >= distanceThreshold;\n    const triggeredbyTime = Date.now() - tripTempState.timestamp >= timeThreshold;\n    const triggeredbySpeed = speed <= speedThreshold;\n\n    if (triggeredbyDoors || triggeredbyDistance || triggeredbyTime || triggeredbySpeed) {\n      this.generateRecord({\n        triggeredbyDoors,\n        triggeredbyDistance,\n        triggeredbyTime,\n        triggeredbySpeed,\n      });\n    }\n  }\n\n  evalTimeOnlyAndGenerateRecord() {\n    const { timeThreshold } = this.recordGenerationRules;\n    const tripTempState = this.trip.tempState;\n    const triggeredbyTime = Date.now() - tripTempState.timestamp >= timeThreshold;\n    if (triggeredbyTime) {\n      this.evalAndGenerateRecord();\n      this.emitEvent(EVENT_TYPES.TRIP_STATE_CHANGED, {\n        tempState: this.trip.tempState,\n        state: this.trip.state,\n      });\n    }\n  }\n\n  generateRecord(reasons) {\n    Dicoin.log('generateRecord', `reason=${JSON.stringify(reasons)}`);\n    if (this.trip.tempState.geolocationPosition) {\n      const { record, extendedRecord } = this.trip.generateRecord();\n      this.records$.next({ localRecord: record, extendedRecord });\n      this.emitEvent(EVENT_TYPES.RECORD_GENERATED, { records: this.trip.records, record });\n    }\n  }\n\n  getRecordAttemptsLatencyAverage(record) {\n    const attepms = record.stats.attempts || [];\n    const attempsLength = attepms.length;\n    const latencyTotal = attepms.reduce((acc, val) => acc + (val.latency || 0), 0);\n    return latencyTotal && attempsLength ? latencyTotal / attempsLength : 0;\n  }\n\n  getRecordAttemptsLatencySum(record) {\n    const attepms = record.stats.attempts || [];\n    if (attepms.length === 0) return '--';\n    const latencyTotal = attepms.reduce((acc, val) => acc + (val.latency || 0), 0);\n    return latencyTotal;\n  }\n\n  addNote(noteContent) {\n    const note = this.trip.addNote(noteContent);\n    this.emitEvent(EVENT_TYPES.NOTE_ADDED, { records: this.trip.records, note });\n  }\n\n  /*\n   *************************************************\n   ********** TRIP REPORT FORWARDS *****************\n   *************************************************\n   */\n\n  reportGeolocationPosition(geolocationPosition) {\n    this.trip.reportGeolocationPosition(geolocationPosition);\n    // this.evalAndGenerateRecord();\n    this.emitEvent(EVENT_TYPES.TRIP_STATE_CHANGED, {\n      tempState: this.trip.tempState,\n      state: this.trip.state,\n    });\n  }\n\n  reportDoorsStatus(frontDoorOpen, backDoorOpen) {\n    if (\n      this.trip.state.frontDoorOpen !== frontDoorOpen ||\n      this.trip.state.backDoorOpen !== backDoorOpen\n    )\n      this.trip.reportDoorsStatus(frontDoorOpen, backDoorOpen);\n    this.evalAndGenerateRecord(true);\n    this.emitEvent(EVENT_TYPES.TRIP_STATE_CHANGED, {\n      tempState: this.trip.tempState,\n      state: this.trip.state,\n    });\n  }\n\n  reportPassengerFlow(frontDoorInput, frontDoorOutput, backDoorInput, backDoorOutput) {\n    this.trip.reportPassengerFlow(frontDoorInput, frontDoorOutput, backDoorInput, backDoorOutput);\n    this.emitEvent(EVENT_TYPES.TRIP_STATE_CHANGED, {\n      tempState: this.trip.tempState,\n      state: this.trip.state,\n    });\n  }\n\n  /*\n   *************************************************\n   ****************** TOOLS ************************\n   *************************************************\n   */\n\n  static log(...data) {\n    console.log('Dicoin:', ...data);\n  }\n\n  static metersPerSecondToKilometersPerHour(metersPerSecond) {\n    return parseInt(3.6 * metersPerSecond, 10);\n  }\n}\n\n/**\n * @returns {Dicoin}\n */\nexport default Dicoin;\n"]},"metadata":{},"sourceType":"module"}