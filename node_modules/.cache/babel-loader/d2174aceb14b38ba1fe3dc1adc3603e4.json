{"ast":null,"code":"import { singleton } from '../MinimongoDB/MinimongoDB';\nconst minimongoDB = singleton();\nconst CollectionName = 'Record';\n\nclass RecordDA {\n  constructor() {}\n\n  static insertRecord(doc) {\n    const collection = minimongoDB.db[CollectionName];\n    collection.findOne({\n      _id: doc._id\n    }, {}, function (res) {\n      let documentToUpdate = doc;\n\n      if (res) {\n        documentToUpdate = { ...res,\n          ...doc\n        };\n      }\n\n      return collection.upsert({ ...documentToUpdate\n      }, () => {\n        return documentToUpdate;\n      }, () => {\n        return null;\n      });\n    });\n  }\n\n  static removeRecords() {\n    const collection = minimongoDB.db[CollectionName];\n    return collection.find({}).fetch(rows => {\n      for (const record of rows) {\n        collection.remove(record._id, r => {\n          collection.resolveRemove(record._id, () => {});\n        });\n      }\n    });\n  }\n\n  static getPrevRecords(serviceId) {\n    const collection = minimongoDB.db[CollectionName];\n    return new Promise((resolve, reject) => {\n      collection.find({\n        serviceId\n      }).fetch(rows => {\n        resolve(rows);\n      });\n    });\n  }\n\n}\n/**\n * @returns {RecordDA}\n */\n\n\nexport default RecordDA;","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/src/app/main/travels/tools/dicoin-engine/data-access/RecordDA.js"],"names":["singleton","minimongoDB","CollectionName","RecordDA","constructor","insertRecord","doc","collection","db","findOne","_id","res","documentToUpdate","upsert","removeRecords","find","fetch","rows","record","remove","r","resolveRemove","getPrevRecords","serviceId","Promise","resolve","reject"],"mappings":"AAAA,SAASA,SAAT,QAA0B,4BAA1B;AAEA,MAAMC,WAAW,GAAGD,SAAS,EAA7B;AACA,MAAME,cAAc,GAAG,QAAvB;;AACA,MAAMC,QAAN,CAAe;AACbC,EAAAA,WAAW,GAAG,CAAE;;AAEG,SAAZC,YAAY,CAACC,GAAD,EAAM;AACvB,UAAMC,UAAU,GAAGN,WAAW,CAACO,EAAZ,CAAeN,cAAf,CAAnB;AACAK,IAAAA,UAAU,CAACE,OAAX,CAAmB;AAAEC,MAAAA,GAAG,EAAEJ,GAAG,CAACI;AAAX,KAAnB,EAAqC,EAArC,EAAyC,UAAUC,GAAV,EAAe;AACtD,UAAIC,gBAAgB,GAAGN,GAAvB;;AACA,UAAIK,GAAJ,EAAS;AACPC,QAAAA,gBAAgB,GAAG,EACjB,GAAGD,GADc;AAEjB,aAAGL;AAFc,SAAnB;AAID;;AACD,aAAOC,UAAU,CAACM,MAAX,CACL,EAAE,GAAGD;AAAL,OADK,EAEL,MAAM;AACJ,eAAOA,gBAAP;AACD,OAJI,EAKL,MAAM;AACJ,eAAO,IAAP;AACD,OAPI,CAAP;AASD,KAjBD;AAkBD;;AAEmB,SAAbE,aAAa,GAAG;AACrB,UAAMP,UAAU,GAAGN,WAAW,CAACO,EAAZ,CAAeN,cAAf,CAAnB;AACA,WAAOK,UAAU,CAACQ,IAAX,CAAgB,EAAhB,EAAoBC,KAApB,CAA2BC,IAAD,IAAU;AACzC,WAAK,MAAMC,MAAX,IAAqBD,IAArB,EAA2B;AACzBV,QAAAA,UAAU,CAACY,MAAX,CAAkBD,MAAM,CAACR,GAAzB,EAA+BU,CAAD,IAAO;AACnCb,UAAAA,UAAU,CAACc,aAAX,CAAyBH,MAAM,CAACR,GAAhC,EAAqC,MAAM,CAAE,CAA7C;AACD,SAFD;AAGD;AACF,KANM,CAAP;AAOD;;AAEoB,SAAdY,cAAc,CAACC,SAAD,EAAY;AAC/B,UAAMhB,UAAU,GAAGN,WAAW,CAACO,EAAZ,CAAeN,cAAf,CAAnB;AACA,WAAO,IAAIsB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCnB,MAAAA,UAAU,CAACQ,IAAX,CAAgB;AAAEQ,QAAAA;AAAF,OAAhB,EAA+BP,KAA/B,CAAsCC,IAAD,IAAU;AAC7CQ,QAAAA,OAAO,CAACR,IAAD,CAAP;AACD,OAFD;AAGD,KAJM,CAAP;AAKD;;AA3CY;AA8Cf;AACA;AACA;;;AACA,eAAed,QAAf","sourcesContent":["import { singleton } from '../MinimongoDB/MinimongoDB';\n\nconst minimongoDB = singleton();\nconst CollectionName = 'Record';\nclass RecordDA {\n  constructor() {}\n\n  static insertRecord(doc) {\n    const collection = minimongoDB.db[CollectionName];\n    collection.findOne({ _id: doc._id }, {}, function (res) {\n      let documentToUpdate = doc;\n      if (res) {\n        documentToUpdate = {\n          ...res,\n          ...doc,\n        };\n      }\n      return collection.upsert(\n        { ...documentToUpdate },\n        () => {\n          return documentToUpdate;\n        },\n        () => {\n          return null;\n        }\n      );\n    });\n  }\n\n  static removeRecords() {\n    const collection = minimongoDB.db[CollectionName];\n    return collection.find({}).fetch((rows) => {\n      for (const record of rows) {\n        collection.remove(record._id, (r) => {\n          collection.resolveRemove(record._id, () => {});\n        });\n      }\n    });\n  }\n\n  static getPrevRecords(serviceId) {\n    const collection = minimongoDB.db[CollectionName];\n    return new Promise((resolve, reject) => {\n      collection.find({ serviceId }).fetch((rows) => {\n        resolve(rows);\n      });\n    });\n  }\n}\n\n/**\n * @returns {RecordDA}\n */\nexport default RecordDA;\n"]},"metadata":{},"sourceType":"module"}