{"ast":null,"code":"import _toConsumableArray from \"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { S as SUPPORT, C as ConfigResolverMap, _ as _objectSpread2, a as _defineProperty, t as toDomEventType, i as isTouch, b as touchIds, E as EngineMap, c as chain, d as toHandlerProp } from './actions-8e8e64ea.esm.js';\nimport './maths-b2a210f4.esm.js';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar sharedConfigResolver = {\n  target: function target(value) {\n    if (value) {\n      return function () {\n        return 'current' in value ? value.current : value;\n      };\n    }\n\n    return undefined;\n  },\n  enabled: function enabled() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return value;\n  },\n  window: function (_window) {\n    function window() {\n      return _window.apply(this, arguments);\n    }\n\n    window.toString = function () {\n      return _window.toString();\n    };\n\n    return window;\n  }(function () {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SUPPORT.isBrowser ? window : undefined;\n    return value;\n  }),\n  eventOptions: function eventOptions() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$passive = _ref2.passive,\n        passive = _ref2$passive === void 0 ? true : _ref2$passive,\n        _ref2$capture = _ref2.capture,\n        capture = _ref2$capture === void 0 ? false : _ref2$capture;\n\n    return {\n      passive: passive,\n      capture: capture\n    };\n  },\n  transform: function transform(value) {\n    return value;\n  }\n};\nvar _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\n\nfunction resolveWith() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var resolvers = arguments.length > 1 ? arguments[1] : undefined;\n  var result = {};\n\n  for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        resolver = _Object$entries$_i[1];\n\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config);\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\n\nfunction parse(config, gestureKey) {\n  var _ref = config,\n      target = _ref.target,\n      eventOptions = _ref.eventOptions,\n      window = _ref.window,\n      enabled = _ref.enabled,\n      transform = _ref.transform,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  var _config = {\n    shared: resolveWith({\n      target: target,\n      eventOptions: eventOptions,\n      window: window,\n      enabled: enabled,\n      transform: transform\n    }, sharedConfigResolver)\n  };\n\n  if (gestureKey) {\n    var resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (var key in rest) {\n      var _resolver = ConfigResolverMap.get(key);\n\n      if (_resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), _resolver);\n      } else if (process.env.NODE_ENV === 'development') {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(\"[@use-gesture]: `domTarget` option has been renamed to `target`.\");\n          }\n\n          console.warn(\"[@use-gesture]: Unknown config key `\".concat(key, \"` was used. Please read the documentation for further information.\"));\n        }\n      }\n    }\n  }\n\n  return _config;\n}\n\nvar EventStore = /*#__PURE__*/function () {\n  function EventStore(ctrl) {\n    _classCallCheck(this, EventStore);\n\n    _defineProperty(this, \"_listeners\", []);\n\n    this._ctrl = ctrl;\n  }\n\n  _createClass(EventStore, [{\n    key: \"add\",\n    value: function add(element, device, action, handler, options) {\n      var type = toDomEventType(device, action);\n\n      var eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options);\n\n      element.addEventListener(type, handler, eventOptions);\n\n      this._listeners.push(function () {\n        return element.removeEventListener(type, handler, eventOptions);\n      });\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this._listeners.forEach(function (remove) {\n        return remove();\n      });\n\n      this._listeners = [];\n    }\n  }]);\n\n  return EventStore;\n}();\n\nvar TimeoutStore = /*#__PURE__*/function () {\n  function TimeoutStore() {\n    _classCallCheck(this, TimeoutStore);\n\n    _defineProperty(this, \"_timeouts\", new Map());\n  }\n\n  _createClass(TimeoutStore, [{\n    key: \"add\",\n    value: function add(key, callback) {\n      var _window2;\n\n      var ms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 140;\n      this.remove(key);\n\n      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        args[_key - 3] = arguments[_key];\n      }\n\n      this._timeouts.set(key, (_window2 = window).setTimeout.apply(_window2, [callback, ms].concat(args)));\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var timeout = this._timeouts.get(key);\n\n      if (timeout) window.clearTimeout(timeout);\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this._timeouts.forEach(function (timeout) {\n        return void window.clearTimeout(timeout);\n      });\n\n      this._timeouts.clear();\n    }\n  }]);\n\n  return TimeoutStore;\n}();\n\nvar Controller = /*#__PURE__*/function () {\n  function Controller(handlers) {\n    _classCallCheck(this, Controller);\n\n    _defineProperty(this, \"gestures\", new Set());\n\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n\n    _defineProperty(this, \"gestureEventStores\", {});\n\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n\n    _defineProperty(this, \"handlers\", {});\n\n    _defineProperty(this, \"config\", {});\n\n    _defineProperty(this, \"pointerIds\", new Set());\n\n    _defineProperty(this, \"touchIds\", new Set());\n\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n\n    resolveGestures(this, handlers);\n  }\n\n  _createClass(Controller, [{\n    key: \"setEventIds\",\n    value: function setEventIds(event) {\n      if (isTouch(event)) {\n        this.touchIds = new Set(touchIds(event));\n      } else if ('pointerId' in event) {\n        if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n      }\n    }\n  }, {\n    key: \"applyHandlers\",\n    value: function applyHandlers(handlers, nativeHandlers) {\n      this.handlers = handlers;\n      this.nativeHandlers = nativeHandlers;\n    }\n  }, {\n    key: \"applyConfig\",\n    value: function applyConfig(config, gestureKey) {\n      this.config = parse(config, gestureKey);\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this._targetEventStore.clean();\n\n      var _iterator = _createForOfIteratorHelper(this.gestures),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          this.gestureEventStores[key].clean();\n          this.gestureTimeoutStores[key].clean();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"effect\",\n    value: function effect() {\n      var _this = this;\n\n      if (this.config.shared.target) this.bind();\n      return function () {\n        return _this._targetEventStore.clean();\n      };\n    }\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var sharedConfig = this.config.shared;\n      var eventOptions = sharedConfig.eventOptions;\n      var props = {};\n      var target;\n\n      if (sharedConfig.target) {\n        target = sharedConfig.target();\n        if (!target) return;\n      }\n\n      var bindFunction = bindToProps(props, eventOptions, !!target);\n\n      if (sharedConfig.enabled) {\n        var _iterator2 = _createForOfIteratorHelper(this.gestures),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var gestureKey = _step2.value;\n\n            if (this.config[gestureKey].enabled) {\n              var Engine = EngineMap.get(gestureKey);\n              new Engine(this, args, gestureKey).bind(bindFunction);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        var _loop = function _loop(eventKey) {\n          bindFunction(eventKey, '', function (event) {\n            return _this2.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, _this2.state.shared), {}, {\n              event: event,\n              args: args\n            }));\n          }, undefined, true);\n        };\n\n        for (var eventKey in this.nativeHandlers) {\n          _loop(eventKey);\n        }\n      }\n\n      for (var handlerProp in props) {\n        props[handlerProp] = chain.apply(void 0, _toConsumableArray(props[handlerProp]));\n      }\n\n      if (!target) return props;\n\n      for (var _handlerProp in props) {\n        var _eventKey = _handlerProp.substr(2).toLowerCase();\n\n        var capture = !!~_eventKey.indexOf('capture');\n        var passive = !!~_eventKey.indexOf('passive');\n        if (capture || passive) _eventKey = _eventKey.replace(/capture|passive/g, '');\n\n        this._targetEventStore.add(target, _eventKey, '', props[_handlerProp], {\n          capture: capture,\n          passive: passive\n        });\n      }\n    }\n  }]);\n\n  return Controller;\n}();\n\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\n\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\n\nvar bindToProps = function bindToProps(props, eventOptions, withPassiveOption) {\n  return function (device, action, handler) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var isNative = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    var _options$capture, _options$passive;\n\n    var capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n    var passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n    var handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n    if (withPassiveOption && passive) handlerProp += 'Passive';\n    props[handlerProp] = props[handlerProp] || [];\n    props[handlerProp].push(handler);\n  };\n};\n\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(_handlers) {\n  var native = {};\n  var handlers = {};\n  var actions = new Set();\n\n  for (var key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n\n  return [handlers, native, actions];\n}\n\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n\n  if (!EngineMap.has(key)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(\"[@use-gesture]: You've created a custom handler that that uses the `\".concat(key, \"` gesture but isn't properly configured.\\n\\nPlease add `\").concat(key, \"Action` when creating your handler.\"));\n    }\n\n    return;\n  }\n\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\n\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  var _sortHandlers = sortHandlers(mergedHandlers),\n      _sortHandlers2 = _slicedToArray(_sortHandlers, 3),\n      handlers = _sortHandlers2[0],\n      nativeHandlers = _sortHandlers2[1],\n      actions = _sortHandlers2[2];\n\n  var internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers: nativeHandlers\n  };\n}\n\nexport { Controller, parseMergedHandlers };","map":null,"metadata":{},"sourceType":"module"}