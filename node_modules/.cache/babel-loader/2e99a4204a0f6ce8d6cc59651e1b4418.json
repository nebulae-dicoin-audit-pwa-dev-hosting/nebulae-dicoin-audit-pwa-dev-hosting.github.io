{"ast":null,"code":"import { singleton } from '../MinimongoDB/MinimongoDB';\nconst minimongoDB = singleton();\nconst CollectionName = 'Trip';\n\nclass TripDA {\n  constructor() {}\n\n  static insertTrip(doc) {\n    const collection = minimongoDB.db[CollectionName];\n    return new Promise((resolve, reject) => {\n      collection.upsert({ ...doc\n      }, r => {\n        resolve(r);\n        return r;\n      }, e => {\n        return e;\n      }, f => {\n        return f;\n      });\n    });\n  }\n\n  static updateTrip(_id, doc) {\n    const collection = minimongoDB.db[CollectionName];\n    return collection.findOne({\n      _id\n    }, {}, function (res) {\n      let documentToUpdate = doc;\n\n      if (res) {\n        documentToUpdate = { ...res,\n          ...doc\n        };\n        return collection.upsert({ ...documentToUpdate\n        }, () => {\n          return documentToUpdate;\n        }, () => {\n          return null;\n        });\n      }\n\n      return null;\n    });\n  }\n\n  static removeTrip() {\n    const collection = minimongoDB.db[CollectionName];\n    return collection.find({}).fetch(rows => {\n      for (const trip of rows) {\n        collection.remove(trip._id, r => {\n          collection.resolveRemove(trip._id, () => {});\n        });\n      }\n    });\n  }\n\n  static finalizeTrip(_id, doc) {\n    const collection = minimongoDB.db[CollectionName];\n    return collection.findOne({\n      _id\n    }, {}, function (res) {\n      if (res) {\n        const documentToUpdate = { ...res,\n          ...doc\n        };\n        return collection.upsert({ ...documentToUpdate\n        }, r => {\n          return documentToUpdate;\n        }, () => {\n          return null;\n        });\n      }\n\n      return null;\n    });\n  }\n\n  static getPrevTrip() {\n    const collection = minimongoDB.db[CollectionName];\n    return new Promise((resolve, reject) => {\n      if (collection) {\n        const query = collection.find({});\n        query.fetch(rows => {\n          resolve(rows[0]);\n        });\n      }\n    });\n  }\n\n  static getTripById(_id) {\n    return new Promise((resolve, reject) => {\n      collection.findOne({\n        _id\n      }, {}, function (trip) {\n        resolve(trip);\n        return trip;\n      });\n    });\n  }\n\n}\n/**\n * @returns {TripDA}\n */\n\n\nexport default TripDA;","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/src/app/main/travels/tools/dicoin-engine/data-access/TripDA.js"],"names":["singleton","minimongoDB","CollectionName","TripDA","constructor","insertTrip","doc","collection","db","Promise","resolve","reject","upsert","r","e","f","updateTrip","_id","findOne","res","documentToUpdate","removeTrip","find","fetch","rows","trip","remove","resolveRemove","finalizeTrip","getPrevTrip","query","getTripById"],"mappings":"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","sourcesContent":["import { singleton } from '../MinimongoDB/MinimongoDB';\n\nconst minimongoDB = singleton();\nconst CollectionName = 'Trip';\nclass TripDA {\n  constructor() {}\n\n  static insertTrip(doc) {\n    const collection = minimongoDB.db[CollectionName];\n    return new Promise((resolve, reject) => {\n      collection.upsert(\n        { ...doc },\n        (r) => {\n          resolve(r);\n          return r;\n        },\n        (e) => {\n          return e;\n        },\n        (f) => {\n          return f;\n        }\n      );\n    });\n  }\n\n  static updateTrip(_id, doc) {\n    const collection = minimongoDB.db[CollectionName];\n    return collection.findOne({ _id }, {}, function (res) {\n      let documentToUpdate = doc;\n      if (res) {\n        documentToUpdate = {\n          ...res,\n          ...doc,\n        };\n        return collection.upsert(\n          { ...documentToUpdate },\n          () => {\n            return documentToUpdate;\n          },\n          () => {\n            return null;\n          }\n        );\n      }\n\n      return null\n\n    });\n  }\n\n  static removeTrip() {\n    const collection = minimongoDB.db[CollectionName];\n    return collection.find({}).fetch((rows) => {\n      for (const trip of rows) {\n        collection.remove(trip._id, (r) => {\n          collection.resolveRemove(trip._id, () => {});\n        });\n      }\n    });\n  }\n\n  static finalizeTrip(_id, doc) {\n    const collection = minimongoDB.db[CollectionName];\n    return collection.findOne({ _id }, {}, function (res) {\n      if (res) {\n        const documentToUpdate = {\n          ...res,\n          ...doc,\n        };\n\n        return collection.upsert(\n          { ...documentToUpdate },\n          (r) => {\n            return documentToUpdate;\n          },\n          () => {\n            return null;\n          }\n        );\n      }\n      return null;\n    });\n  }\n\n  static getPrevTrip() {\n    const collection = minimongoDB.db[CollectionName];\n    return new Promise((resolve, reject) => {\n      if (collection) {\n        const query = collection.find({});\n        query.fetch((rows) => {\n          resolve(rows[0]);\n        });\n      }\n    });\n  }\n\n  static getTripById(_id) {\n    return new Promise((resolve, reject) => {\n      collection.findOne({ _id }, {}, function (trip) {\n        resolve(trip);\n        return trip;\n      });\n    });\n  }\n}\n\n/**\n * @returns {TripDA}\n */\nexport default TripDA;\n"]},"metadata":{},"sourceType":"module"}