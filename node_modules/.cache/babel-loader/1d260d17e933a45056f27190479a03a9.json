{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst async_1 = __importDefault(require(\"async\"));\n\nconst utils = __importStar(require(\"./utils\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst selector_1 = require(\"./selector\");\n\nclass MemoryDb {\n  // Options are:\n  //  safety: How to protect the in-memory copies: \"clone\" (default) returns a fresh copy but is slow. \"freeze\" returns a frozen version\n  constructor(options, success) {\n    this.collections = {};\n    this.options = lodash_1.default.defaults(options, {\n      safety: \"clone\"\n    });\n\n    if (success) {\n      success(this);\n    }\n  }\n\n  addCollection(name, success, error) {\n    const collection = new Collection(name, this.options);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success != null) {\n      return success();\n    }\n  }\n\n  removeCollection(name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n\n    if (success != null) {\n      return success();\n    }\n  }\n\n  getCollectionNames() {\n    return lodash_1.default.keys(this.collections);\n  }\n\n}\n\nexports.default = MemoryDb; // Stores data in memory\n\nclass Collection {\n  constructor(name, options) {\n    // Applies safety (either freezing or cloning to object or array)\n    this._applySafety = items => {\n      if (!items) {\n        return items;\n      }\n\n      if (lodash_1.default.isArray(items)) {\n        return lodash_1.default.map(items, this._applySafety);\n      }\n\n      if (this.options.safety === \"clone\" || !this.options.safety) {\n        return JSON.parse(JSON.stringify(items));\n      }\n\n      if (this.options.safety === \"freeze\") {\n        Object.freeze(items);\n        return items;\n      }\n\n      throw new Error(`Unsupported safety ${this.options.safety}`);\n    };\n\n    this.name = name;\n    this.items = {};\n    this.upserts = {}; // Pending upserts by _id. Still in items\n\n    this.removes = {}; // Pending removes by _id. No longer in items\n\n    this.options = options || {};\n  }\n\n  find(selector, options) {\n    return {\n      fetch: (success, error) => {\n        return this._findFetch(selector, options, success, error);\n      }\n    };\n  }\n\n  findOne(selector, options, success, error) {\n    if (lodash_1.default.isFunction(options)) {\n      ;\n      [options, success, error] = [{}, options, success];\n    }\n\n    return this.find(selector, options).fetch(results => {\n      if (success != null) {\n        return success(this._applySafety(results.length > 0 ? results[0] : null));\n      }\n    }, error);\n  }\n\n  _findFetch(selector, options, success, error) {\n    // Defer to allow other processes to run\n    return setTimeout(() => {\n      // Shortcut if _id is specified\n      let allItems;\n\n      if (selector && selector._id && lodash_1.default.isString(selector._id)) {\n        allItems = lodash_1.default.compact([this.items[selector._id]]);\n      } else {\n        allItems = lodash_1.default.values(this.items);\n      }\n\n      const results = (0, utils_1.processFind)(allItems, selector, options);\n\n      if (success != null) {\n        return success(this._applySafety(results));\n      }\n    }, 0);\n  }\n\n  upsert(docs, bases, success, error) {\n    let items;\n    [items, success, error] = utils.regularizeUpsert(docs, bases, success, error); // Keep independent copies to prevent modification\n\n    items = JSON.parse(JSON.stringify(items));\n\n    for (let item of items) {\n      // Fill in base if undefined\n      if (item.base === undefined) {\n        // Use existing base\n        if (this.upserts[item.doc._id]) {\n          item.base = this.upserts[item.doc._id].base;\n        } else {\n          item.base = this.items[item.doc._id] || null;\n        }\n      } // Replace/add\n\n\n      this.items[item.doc._id] = item.doc;\n      this.upserts[item.doc._id] = item;\n    }\n\n    if (lodash_1.default.isArray(docs)) {\n      if (success) {\n        return success(this._applySafety(lodash_1.default.map(items, \"doc\")));\n      }\n    } else {\n      if (success) {\n        return success(this._applySafety(lodash_1.default.map(items, \"doc\")[0]));\n      }\n    }\n  }\n\n  remove(id, success, error) {\n    // Special case for filter-type remove\n    if (lodash_1.default.isObject(id)) {\n      this.find(id).fetch(rows => {\n        return async_1.default.each(rows, (row, cb) => {\n          return this.remove(row._id, () => cb(), cb);\n        }, () => success());\n      }, error);\n      return;\n    }\n\n    if (lodash_1.default.has(this.items, id)) {\n      this.removes[id] = this.items[id];\n      delete this.items[id];\n      delete this.upserts[id];\n    } else {\n      this.removes[id] = {\n        _id: id\n      };\n    }\n\n    if (success != null) {\n      return success();\n    }\n  } // Options are find options with optional \"exclude\" which is list of _ids to exclude\n\n\n  cache(docs, selector, options, success, error) {\n    // Add all non-local that are not upserted or removed\n    let sort;\n\n    for (let doc of docs) {\n      // Exclude any excluded _ids from being cached/uncached\n      if (options && options.exclude && options.exclude.includes(doc._id)) {\n        continue;\n      }\n\n      this.cacheOne(doc, () => {}, () => {});\n    }\n\n    const docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n\n    if (options.sort) {\n      sort = (0, selector_1.compileSort)(options.sort);\n    } // Perform query, removing rows missing in docs from local db\n\n\n    return this.find(selector, options).fetch(results => {\n      for (let result of results) {\n        if (!docsMap[result._id] && !lodash_1.default.has(this.upserts, result._id)) {\n          // If at limit\n          if (options.limit && docs.length === options.limit) {\n            // If past end on sorted limited, ignore\n            if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n              continue;\n            } // If no sort, ignore\n\n\n            if (!options.sort) {\n              continue;\n            }\n          } // Exclude any excluded _ids from being cached/uncached\n\n\n          if (options && options.exclude && options.exclude.includes(result._id)) {\n            continue;\n          }\n\n          delete this.items[result._id];\n        }\n      }\n\n      if (success != null) {\n        return success();\n      }\n    }, error);\n  }\n\n  pendingUpserts(success) {\n    return success(lodash_1.default.values(this.upserts));\n  }\n\n  pendingRemoves(success) {\n    return success(lodash_1.default.map(this.removes, \"_id\"));\n  }\n\n  resolveUpserts(upserts, success) {\n    for (let upsert of upserts) {\n      const id = upsert.doc._id;\n\n      if (this.upserts[id]) {\n        // Only safely remove upsert if doc is unchanged\n        if (lodash_1.default.isEqual(upsert.doc, this.upserts[id].doc)) {\n          delete this.upserts[id];\n        } else {\n          // Just update base\n          this.upserts[id].base = upsert.doc;\n        }\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  }\n\n  resolveRemove(id, success) {\n    delete this.removes[id];\n\n    if (success != null) {\n      return success();\n    }\n  } // Add but do not overwrite or record as upsert\n\n\n  seed(docs, success) {\n    if (!lodash_1.default.isArray(docs)) {\n      docs = [docs];\n    }\n\n    for (let doc of docs) {\n      if (!lodash_1.default.has(this.items, doc._id) && !lodash_1.default.has(this.removes, doc._id)) {\n        this.items[doc._id] = doc;\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  } // Add but do not overwrite upserts or removes\n\n\n  cacheOne(doc, success, error) {\n    return this.cacheList([doc], success, error);\n  } // Add but do not overwrite upserts or removes\n\n\n  cacheList(docs, success, error) {\n    for (let doc of docs) {\n      if (!lodash_1.default.has(this.upserts, doc._id) && !lodash_1.default.has(this.removes, doc._id)) {\n        const existing = this.items[doc._id]; // If _rev present, make sure that not overwritten by lower or equal _rev\n\n        if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n          this.items[doc._id] = doc;\n        }\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  }\n\n  uncache(selector, success, error) {\n    const compiledSelector = utils.compileDocumentSelector(selector);\n    const items = lodash_1.default.filter(lodash_1.default.values(this.items), item => {\n      return this.upserts[item._id] != null || !compiledSelector(item);\n    });\n    this.items = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(items, \"_id\"), items));\n\n    if (success != null) {\n      return success();\n    }\n  }\n\n  uncacheList(ids, success, error) {\n    const idIndex = lodash_1.default.keyBy(ids);\n    const items = lodash_1.default.filter(lodash_1.default.values(this.items), item => {\n      return this.upserts[item._id] != null || !idIndex[item._id];\n    });\n    this.items = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(items, \"_id\"), items));\n\n    if (success != null) {\n      return success();\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/minimongo/lib/MemoryDb.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__importDefault","exports","lodash_1","require","async_1","utils","utils_1","selector_1","MemoryDb","constructor","options","success","collections","default","defaults","safety","addCollection","name","error","collection","Collection","removeCollection","getCollectionNames","keys","_applySafety","items","isArray","map","JSON","parse","stringify","freeze","Error","upserts","removes","find","selector","fetch","_findFetch","findOne","isFunction","results","length","setTimeout","allItems","_id","isString","compact","values","processFind","upsert","docs","bases","regularizeUpsert","item","base","doc","remove","id","isObject","rows","each","row","cb","has","cache","sort","exclude","includes","cacheOne","docsMap","fromPairs","zip","compileSort","limit","last","pendingUpserts","pendingRemoves","resolveUpserts","isEqual","resolveRemove","seed","cacheList","existing","_rev","uncache","compiledSelector","compileDocumentSelector","filter","uncacheList","ids","idIndex","keyBy"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,KAAmCC,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;AAC5F,MAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;AACtBJ,EAAAA,MAAM,CAACO,cAAP,CAAsBL,CAAtB,EAAyBG,EAAzB,EAA6B;AAAEG,IAAAA,UAAU,EAAE,IAAd;AAAoBC,IAAAA,GAAG,EAAE,YAAW;AAAE,aAAON,CAAC,CAACC,CAAD,CAAR;AAAc;AAApD,GAA7B;AACH,CAHwD,GAGnD,UAASF,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;AACxB,MAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;AACtBF,EAAAA,CAAC,CAACG,EAAD,CAAD,GAAQF,CAAC,CAACC,CAAD,CAAT;AACH,CANqB,CAAtB;;AAOA,IAAIM,kBAAkB,GAAI,QAAQ,KAAKA,kBAAd,KAAsCV,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYS,CAAZ,EAAe;AAC3FX,EAAAA,MAAM,CAACO,cAAP,CAAsBL,CAAtB,EAAyB,SAAzB,EAAoC;AAAEM,IAAAA,UAAU,EAAE,IAAd;AAAoBI,IAAAA,KAAK,EAAED;AAA3B,GAApC;AACH,CAF8D,GAE1D,UAAST,CAAT,EAAYS,CAAZ,EAAe;AAChBT,EAAAA,CAAC,CAAC,SAAD,CAAD,GAAeS,CAAf;AACH,CAJwB,CAAzB;;AAKA,IAAIE,YAAY,GAAI,QAAQ,KAAKA,YAAd,IAA+B,UAAUC,GAAV,EAAe;AAC7D,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B,OAAOD,GAAP;AAC3B,MAAIE,MAAM,GAAG,EAAb;AACA,MAAIF,GAAG,IAAI,IAAX,EAAiB,KAAK,IAAIV,CAAT,IAAcU,GAAd,EAAmB,IAAIV,CAAC,KAAK,SAAN,IAAmBJ,MAAM,CAACiB,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,GAArC,EAA0CV,CAA1C,CAAvB,EAAqEL,eAAe,CAACiB,MAAD,EAASF,GAAT,EAAcV,CAAd,CAAf;;AACzGM,EAAAA,kBAAkB,CAACM,MAAD,EAASF,GAAT,CAAlB;;AACA,SAAOE,MAAP;AACH,CAND;;AAOA,IAAII,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUN,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAd,MAAM,CAACO,cAAP,CAAsBc,OAAtB,EAA+B,YAA/B,EAA6C;AAAET,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMU,QAAQ,GAAGF,eAAe,CAACG,OAAO,CAAC,QAAD,CAAR,CAAhC;;AACA,MAAMC,OAAO,GAAGJ,eAAe,CAACG,OAAO,CAAC,OAAD,CAAR,CAA/B;;AACA,MAAME,KAAK,GAAGZ,YAAY,CAACU,OAAO,CAAC,SAAD,CAAR,CAA1B;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMI,UAAU,GAAGJ,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAMK,QAAN,CAAe;AACX;AACA;AACAC,EAAAA,WAAW,CAACC,OAAD,EAAUC,OAAV,EAAmB;AAC1B,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKF,OAAL,GAAeR,QAAQ,CAACW,OAAT,CAAiBC,QAAjB,CAA0BJ,OAA1B,EAAmC;AAAEK,MAAAA,MAAM,EAAE;AAAV,KAAnC,CAAf;;AACA,QAAIJ,OAAJ,EAAa;AACTA,MAAAA,OAAO,CAAC,IAAD,CAAP;AACH;AACJ;;AACDK,EAAAA,aAAa,CAACC,IAAD,EAAON,OAAP,EAAgBO,KAAhB,EAAuB;AAChC,UAAMC,UAAU,GAAG,IAAIC,UAAJ,CAAeH,IAAf,EAAqB,KAAKP,OAA1B,CAAnB;AACA,SAAKO,IAAL,IAAaE,UAAb;AACA,SAAKP,WAAL,CAAiBK,IAAjB,IAAyBE,UAAzB;;AACA,QAAIR,OAAO,IAAI,IAAf,EAAqB;AACjB,aAAOA,OAAO,EAAd;AACH;AACJ;;AACDU,EAAAA,gBAAgB,CAACJ,IAAD,EAAON,OAAP,EAAgBO,KAAhB,EAAuB;AACnC,WAAO,KAAKD,IAAL,CAAP;AACA,WAAO,KAAKL,WAAL,CAAiBK,IAAjB,CAAP;;AACA,QAAIN,OAAO,IAAI,IAAf,EAAqB;AACjB,aAAOA,OAAO,EAAd;AACH;AACJ;;AACDW,EAAAA,kBAAkB,GAAG;AACjB,WAAOpB,QAAQ,CAACW,OAAT,CAAiBU,IAAjB,CAAsB,KAAKX,WAA3B,CAAP;AACH;;AA3BU;;AA6BfX,OAAO,CAACY,OAAR,GAAkBL,QAAlB,C,CACA;;AACA,MAAMY,UAAN,CAAiB;AACbX,EAAAA,WAAW,CAACQ,IAAD,EAAOP,OAAP,EAAgB;AACvB;AACA,SAAKc,YAAL,GAAqBC,KAAD,IAAW;AAC3B,UAAI,CAACA,KAAL,EAAY;AACR,eAAOA,KAAP;AACH;;AACD,UAAIvB,QAAQ,CAACW,OAAT,CAAiBa,OAAjB,CAAyBD,KAAzB,CAAJ,EAAqC;AACjC,eAAOvB,QAAQ,CAACW,OAAT,CAAiBc,GAAjB,CAAqBF,KAArB,EAA4B,KAAKD,YAAjC,CAAP;AACH;;AACD,UAAI,KAAKd,OAAL,CAAaK,MAAb,KAAwB,OAAxB,IAAmC,CAAC,KAAKL,OAAL,CAAaK,MAArD,EAA6D;AACzD,eAAOa,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeL,KAAf,CAAX,CAAP;AACH;;AACD,UAAI,KAAKf,OAAL,CAAaK,MAAb,KAAwB,QAA5B,EAAsC;AAClCnC,QAAAA,MAAM,CAACmD,MAAP,CAAcN,KAAd;AACA,eAAOA,KAAP;AACH;;AACD,YAAM,IAAIO,KAAJ,CAAW,sBAAqB,KAAKtB,OAAL,CAAaK,MAAO,EAApD,CAAN;AACH,KAfD;;AAgBA,SAAKE,IAAL,GAAYA,IAAZ;AACA,SAAKQ,KAAL,GAAa,EAAb;AACA,SAAKQ,OAAL,GAAe,EAAf,CApBuB,CAoBJ;;AACnB,SAAKC,OAAL,GAAe,EAAf,CArBuB,CAqBJ;;AACnB,SAAKxB,OAAL,GAAeA,OAAO,IAAI,EAA1B;AACH;;AACDyB,EAAAA,IAAI,CAACC,QAAD,EAAW1B,OAAX,EAAoB;AACpB,WAAO;AACH2B,MAAAA,KAAK,EAAE,CAAC1B,OAAD,EAAUO,KAAV,KAAoB;AACvB,eAAO,KAAKoB,UAAL,CAAgBF,QAAhB,EAA0B1B,OAA1B,EAAmCC,OAAnC,EAA4CO,KAA5C,CAAP;AACH;AAHE,KAAP;AAKH;;AACDqB,EAAAA,OAAO,CAACH,QAAD,EAAW1B,OAAX,EAAoBC,OAApB,EAA6BO,KAA7B,EAAoC;AACvC,QAAIhB,QAAQ,CAACW,OAAT,CAAiB2B,UAAjB,CAA4B9B,OAA5B,CAAJ,EAA0C;AACtC;AACA,OAACA,OAAD,EAAUC,OAAV,EAAmBO,KAAnB,IAA4B,CAAC,EAAD,EAAKR,OAAL,EAAcC,OAAd,CAA5B;AACH;;AACD,WAAO,KAAKwB,IAAL,CAAUC,QAAV,EAAoB1B,OAApB,EAA6B2B,KAA7B,CAAoCI,OAAD,IAAa;AACnD,UAAI9B,OAAO,IAAI,IAAf,EAAqB;AACjB,eAAOA,OAAO,CAAC,KAAKa,YAAL,CAAkBiB,OAAO,CAACC,MAAR,GAAiB,CAAjB,GAAqBD,OAAO,CAAC,CAAD,CAA5B,GAAkC,IAApD,CAAD,CAAd;AACH;AACJ,KAJM,EAIJvB,KAJI,CAAP;AAKH;;AACDoB,EAAAA,UAAU,CAACF,QAAD,EAAW1B,OAAX,EAAoBC,OAApB,EAA6BO,KAA7B,EAAoC;AAC1C;AACA,WAAOyB,UAAU,CAAC,MAAM;AACpB;AACA,UAAIC,QAAJ;;AACA,UAAIR,QAAQ,IAAIA,QAAQ,CAACS,GAArB,IAA4B3C,QAAQ,CAACW,OAAT,CAAiBiC,QAAjB,CAA0BV,QAAQ,CAACS,GAAnC,CAAhC,EAAyE;AACrED,QAAAA,QAAQ,GAAG1C,QAAQ,CAACW,OAAT,CAAiBkC,OAAjB,CAAyB,CAAC,KAAKtB,KAAL,CAAWW,QAAQ,CAACS,GAApB,CAAD,CAAzB,CAAX;AACH,OAFD,MAGK;AACDD,QAAAA,QAAQ,GAAG1C,QAAQ,CAACW,OAAT,CAAiBmC,MAAjB,CAAwB,KAAKvB,KAA7B,CAAX;AACH;;AACD,YAAMgB,OAAO,GAAG,CAAC,GAAGnC,OAAO,CAAC2C,WAAZ,EAAyBL,QAAzB,EAAmCR,QAAnC,EAA6C1B,OAA7C,CAAhB;;AACA,UAAIC,OAAO,IAAI,IAAf,EAAqB;AACjB,eAAOA,OAAO,CAAC,KAAKa,YAAL,CAAkBiB,OAAlB,CAAD,CAAd;AACH;AACJ,KAbgB,EAad,CAbc,CAAjB;AAcH;;AACDS,EAAAA,MAAM,CAACC,IAAD,EAAOC,KAAP,EAAczC,OAAd,EAAuBO,KAAvB,EAA8B;AAChC,QAAIO,KAAJ;AACA,KAACA,KAAD,EAAQd,OAAR,EAAiBO,KAAjB,IAA0Bb,KAAK,CAACgD,gBAAN,CAAuBF,IAAvB,EAA6BC,KAA7B,EAAoCzC,OAApC,EAA6CO,KAA7C,CAA1B,CAFgC,CAGhC;;AACAO,IAAAA,KAAK,GAAGG,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeL,KAAf,CAAX,CAAR;;AACA,SAAK,IAAI6B,IAAT,IAAiB7B,KAAjB,EAAwB;AACpB;AACA,UAAI6B,IAAI,CAACC,IAAL,KAAcrE,SAAlB,EAA6B;AACzB;AACA,YAAI,KAAK+C,OAAL,CAAaqB,IAAI,CAACE,GAAL,CAASX,GAAtB,CAAJ,EAAgC;AAC5BS,UAAAA,IAAI,CAACC,IAAL,GAAY,KAAKtB,OAAL,CAAaqB,IAAI,CAACE,GAAL,CAASX,GAAtB,EAA2BU,IAAvC;AACH,SAFD,MAGK;AACDD,UAAAA,IAAI,CAACC,IAAL,GAAY,KAAK9B,KAAL,CAAW6B,IAAI,CAACE,GAAL,CAASX,GAApB,KAA4B,IAAxC;AACH;AACJ,OAVmB,CAWpB;;;AACA,WAAKpB,KAAL,CAAW6B,IAAI,CAACE,GAAL,CAASX,GAApB,IAA2BS,IAAI,CAACE,GAAhC;AACA,WAAKvB,OAAL,CAAaqB,IAAI,CAACE,GAAL,CAASX,GAAtB,IAA6BS,IAA7B;AACH;;AACD,QAAIpD,QAAQ,CAACW,OAAT,CAAiBa,OAAjB,CAAyByB,IAAzB,CAAJ,EAAoC;AAChC,UAAIxC,OAAJ,EAAa;AACT,eAAOA,OAAO,CAAC,KAAKa,YAAL,CAAkBtB,QAAQ,CAACW,OAAT,CAAiBc,GAAjB,CAAqBF,KAArB,EAA4B,KAA5B,CAAlB,CAAD,CAAd;AACH;AACJ,KAJD,MAKK;AACD,UAAId,OAAJ,EAAa;AACT,eAAOA,OAAO,CAAC,KAAKa,YAAL,CAAkBtB,QAAQ,CAACW,OAAT,CAAiBc,GAAjB,CAAqBF,KAArB,EAA4B,KAA5B,EAAmC,CAAnC,CAAlB,CAAD,CAAd;AACH;AACJ;AACJ;;AACDgC,EAAAA,MAAM,CAACC,EAAD,EAAK/C,OAAL,EAAcO,KAAd,EAAqB;AACvB;AACA,QAAIhB,QAAQ,CAACW,OAAT,CAAiB8C,QAAjB,CAA0BD,EAA1B,CAAJ,EAAmC;AAC/B,WAAKvB,IAAL,CAAUuB,EAAV,EAAcrB,KAAd,CAAqBuB,IAAD,IAAU;AAC1B,eAAOxD,OAAO,CAACS,OAAR,CAAgBgD,IAAhB,CAAqBD,IAArB,EAA4B,CAACE,GAAD,EAAMC,EAAN,KAAa;AAC5C,iBAAO,KAAKN,MAAL,CAAYK,GAAG,CAACjB,GAAhB,EAAqB,MAAMkB,EAAE,EAA7B,EAAiCA,EAAjC,CAAP;AACH,SAFM,EAEH,MAAMpD,OAAO,EAFV,CAAP;AAGH,OAJD,EAIGO,KAJH;AAKA;AACH;;AACD,QAAIhB,QAAQ,CAACW,OAAT,CAAiBmD,GAAjB,CAAqB,KAAKvC,KAA1B,EAAiCiC,EAAjC,CAAJ,EAA0C;AACtC,WAAKxB,OAAL,CAAawB,EAAb,IAAmB,KAAKjC,KAAL,CAAWiC,EAAX,CAAnB;AACA,aAAO,KAAKjC,KAAL,CAAWiC,EAAX,CAAP;AACA,aAAO,KAAKzB,OAAL,CAAayB,EAAb,CAAP;AACH,KAJD,MAKK;AACD,WAAKxB,OAAL,CAAawB,EAAb,IAAmB;AAAEb,QAAAA,GAAG,EAAEa;AAAP,OAAnB;AACH;;AACD,QAAI/C,OAAO,IAAI,IAAf,EAAqB;AACjB,aAAOA,OAAO,EAAd;AACH;AACJ,GAhHY,CAiHb;;;AACAsD,EAAAA,KAAK,CAACd,IAAD,EAAOf,QAAP,EAAiB1B,OAAjB,EAA0BC,OAA1B,EAAmCO,KAAnC,EAA0C;AAC3C;AACA,QAAIgD,IAAJ;;AACA,SAAK,IAAIV,GAAT,IAAgBL,IAAhB,EAAsB;AAClB;AACA,UAAIzC,OAAO,IAAIA,OAAO,CAACyD,OAAnB,IAA8BzD,OAAO,CAACyD,OAAR,CAAgBC,QAAhB,CAAyBZ,GAAG,CAACX,GAA7B,CAAlC,EAAqE;AACjE;AACH;;AACD,WAAKwB,QAAL,CAAcb,GAAd,EAAmB,MAAM,CAAG,CAA5B,EAA8B,MAAM,CAAG,CAAvC;AACH;;AACD,UAAMc,OAAO,GAAGpE,QAAQ,CAACW,OAAT,CAAiB0D,SAAjB,CAA2BrE,QAAQ,CAACW,OAAT,CAAiB2D,GAAjB,CAAqBtE,QAAQ,CAACW,OAAT,CAAiBc,GAAjB,CAAqBwB,IAArB,EAA2B,KAA3B,CAArB,EAAwDA,IAAxD,CAA3B,CAAhB;;AACA,QAAIzC,OAAO,CAACwD,IAAZ,EAAkB;AACdA,MAAAA,IAAI,GAAG,CAAC,GAAG3D,UAAU,CAACkE,WAAf,EAA4B/D,OAAO,CAACwD,IAApC,CAAP;AACH,KAb0C,CAc3C;;;AACA,WAAO,KAAK/B,IAAL,CAAUC,QAAV,EAAoB1B,OAApB,EAA6B2B,KAA7B,CAAoCI,OAAD,IAAa;AACnD,WAAK,IAAI7C,MAAT,IAAmB6C,OAAnB,EAA4B;AACxB,YAAI,CAAC6B,OAAO,CAAC1E,MAAM,CAACiD,GAAR,CAAR,IAAwB,CAAC3C,QAAQ,CAACW,OAAT,CAAiBmD,GAAjB,CAAqB,KAAK/B,OAA1B,EAAmCrC,MAAM,CAACiD,GAA1C,CAA7B,EAA6E;AACzE;AACA,cAAInC,OAAO,CAACgE,KAAR,IAAiBvB,IAAI,CAACT,MAAL,KAAgBhC,OAAO,CAACgE,KAA7C,EAAoD;AAChD;AACA,gBAAIhE,OAAO,CAACwD,IAAR,IAAgBA,IAAI,CAACtE,MAAD,EAASM,QAAQ,CAACW,OAAT,CAAiB8D,IAAjB,CAAsBxB,IAAtB,CAAT,CAAJ,IAA6C,CAAjE,EAAoE;AAChE;AACH,aAJ+C,CAKhD;;;AACA,gBAAI,CAACzC,OAAO,CAACwD,IAAb,EAAmB;AACf;AACH;AACJ,WAXwE,CAYzE;;;AACA,cAAIxD,OAAO,IAAIA,OAAO,CAACyD,OAAnB,IAA8BzD,OAAO,CAACyD,OAAR,CAAgBC,QAAhB,CAAyBxE,MAAM,CAACiD,GAAhC,CAAlC,EAAwE;AACpE;AACH;;AACD,iBAAO,KAAKpB,KAAL,CAAW7B,MAAM,CAACiD,GAAlB,CAAP;AACH;AACJ;;AACD,UAAIlC,OAAO,IAAI,IAAf,EAAqB;AACjB,eAAOA,OAAO,EAAd;AACH;AACJ,KAxBM,EAwBJO,KAxBI,CAAP;AAyBH;;AACD0D,EAAAA,cAAc,CAACjE,OAAD,EAAU;AACpB,WAAOA,OAAO,CAACT,QAAQ,CAACW,OAAT,CAAiBmC,MAAjB,CAAwB,KAAKf,OAA7B,CAAD,CAAd;AACH;;AACD4C,EAAAA,cAAc,CAAClE,OAAD,EAAU;AACpB,WAAOA,OAAO,CAACT,QAAQ,CAACW,OAAT,CAAiBc,GAAjB,CAAqB,KAAKO,OAA1B,EAAmC,KAAnC,CAAD,CAAd;AACH;;AACD4C,EAAAA,cAAc,CAAC7C,OAAD,EAAUtB,OAAV,EAAmB;AAC7B,SAAK,IAAIuC,MAAT,IAAmBjB,OAAnB,EAA4B;AACxB,YAAMyB,EAAE,GAAGR,MAAM,CAACM,GAAP,CAAWX,GAAtB;;AACA,UAAI,KAAKZ,OAAL,CAAayB,EAAb,CAAJ,EAAsB;AAClB;AACA,YAAIxD,QAAQ,CAACW,OAAT,CAAiBkE,OAAjB,CAAyB7B,MAAM,CAACM,GAAhC,EAAqC,KAAKvB,OAAL,CAAayB,EAAb,EAAiBF,GAAtD,CAAJ,EAAgE;AAC5D,iBAAO,KAAKvB,OAAL,CAAayB,EAAb,CAAP;AACH,SAFD,MAGK;AACD;AACA,eAAKzB,OAAL,CAAayB,EAAb,EAAiBH,IAAjB,GAAwBL,MAAM,CAACM,GAA/B;AACH;AACJ;AACJ;;AACD,QAAI7C,OAAO,IAAI,IAAf,EAAqB;AACjB,aAAOA,OAAO,EAAd;AACH;AACJ;;AACDqE,EAAAA,aAAa,CAACtB,EAAD,EAAK/C,OAAL,EAAc;AACvB,WAAO,KAAKuB,OAAL,CAAawB,EAAb,CAAP;;AACA,QAAI/C,OAAO,IAAI,IAAf,EAAqB;AACjB,aAAOA,OAAO,EAAd;AACH;AACJ,GAxLY,CAyLb;;;AACAsE,EAAAA,IAAI,CAAC9B,IAAD,EAAOxC,OAAP,EAAgB;AAChB,QAAI,CAACT,QAAQ,CAACW,OAAT,CAAiBa,OAAjB,CAAyByB,IAAzB,CAAL,EAAqC;AACjCA,MAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACH;;AACD,SAAK,IAAIK,GAAT,IAAgBL,IAAhB,EAAsB;AAClB,UAAI,CAACjD,QAAQ,CAACW,OAAT,CAAiBmD,GAAjB,CAAqB,KAAKvC,KAA1B,EAAiC+B,GAAG,CAACX,GAArC,CAAD,IAA8C,CAAC3C,QAAQ,CAACW,OAAT,CAAiBmD,GAAjB,CAAqB,KAAK9B,OAA1B,EAAmCsB,GAAG,CAACX,GAAvC,CAAnD,EAAgG;AAC5F,aAAKpB,KAAL,CAAW+B,GAAG,CAACX,GAAf,IAAsBW,GAAtB;AACH;AACJ;;AACD,QAAI7C,OAAO,IAAI,IAAf,EAAqB;AACjB,aAAOA,OAAO,EAAd;AACH;AACJ,GAtMY,CAuMb;;;AACA0D,EAAAA,QAAQ,CAACb,GAAD,EAAM7C,OAAN,EAAeO,KAAf,EAAsB;AAC1B,WAAO,KAAKgE,SAAL,CAAe,CAAC1B,GAAD,CAAf,EAAsB7C,OAAtB,EAA+BO,KAA/B,CAAP;AACH,GA1MY,CA2Mb;;;AACAgE,EAAAA,SAAS,CAAC/B,IAAD,EAAOxC,OAAP,EAAgBO,KAAhB,EAAuB;AAC5B,SAAK,IAAIsC,GAAT,IAAgBL,IAAhB,EAAsB;AAClB,UAAI,CAACjD,QAAQ,CAACW,OAAT,CAAiBmD,GAAjB,CAAqB,KAAK/B,OAA1B,EAAmCuB,GAAG,CAACX,GAAvC,CAAD,IAAgD,CAAC3C,QAAQ,CAACW,OAAT,CAAiBmD,GAAjB,CAAqB,KAAK9B,OAA1B,EAAmCsB,GAAG,CAACX,GAAvC,CAArD,EAAkG;AAC9F,cAAMsC,QAAQ,GAAG,KAAK1D,KAAL,CAAW+B,GAAG,CAACX,GAAf,CAAjB,CAD8F,CAE9F;;AACA,YAAI,CAACsC,QAAD,IAAa,CAAC3B,GAAG,CAAC4B,IAAlB,IAA0B,CAACD,QAAQ,CAACC,IAApC,IAA4C5B,GAAG,CAAC4B,IAAJ,GAAWD,QAAQ,CAACC,IAApE,EAA0E;AACtE,eAAK3D,KAAL,CAAW+B,GAAG,CAACX,GAAf,IAAsBW,GAAtB;AACH;AACJ;AACJ;;AACD,QAAI7C,OAAO,IAAI,IAAf,EAAqB;AACjB,aAAOA,OAAO,EAAd;AACH;AACJ;;AACD0E,EAAAA,OAAO,CAACjD,QAAD,EAAWzB,OAAX,EAAoBO,KAApB,EAA2B;AAC9B,UAAMoE,gBAAgB,GAAGjF,KAAK,CAACkF,uBAAN,CAA8BnD,QAA9B,CAAzB;AACA,UAAMX,KAAK,GAAGvB,QAAQ,CAACW,OAAT,CAAiB2E,MAAjB,CAAwBtF,QAAQ,CAACW,OAAT,CAAiBmC,MAAjB,CAAwB,KAAKvB,KAA7B,CAAxB,EAA8D6B,IAAD,IAAU;AACjF,aAAO,KAAKrB,OAAL,CAAaqB,IAAI,CAACT,GAAlB,KAA0B,IAA1B,IAAkC,CAACyC,gBAAgB,CAAChC,IAAD,CAA1D;AACH,KAFa,CAAd;AAGA,SAAK7B,KAAL,GAAavB,QAAQ,CAACW,OAAT,CAAiB0D,SAAjB,CAA2BrE,QAAQ,CAACW,OAAT,CAAiB2D,GAAjB,CAAqBtE,QAAQ,CAACW,OAAT,CAAiBc,GAAjB,CAAqBF,KAArB,EAA4B,KAA5B,CAArB,EAAyDA,KAAzD,CAA3B,CAAb;;AACA,QAAId,OAAO,IAAI,IAAf,EAAqB;AACjB,aAAOA,OAAO,EAAd;AACH;AACJ;;AACD8E,EAAAA,WAAW,CAACC,GAAD,EAAM/E,OAAN,EAAeO,KAAf,EAAsB;AAC7B,UAAMyE,OAAO,GAAGzF,QAAQ,CAACW,OAAT,CAAiB+E,KAAjB,CAAuBF,GAAvB,CAAhB;AACA,UAAMjE,KAAK,GAAGvB,QAAQ,CAACW,OAAT,CAAiB2E,MAAjB,CAAwBtF,QAAQ,CAACW,OAAT,CAAiBmC,MAAjB,CAAwB,KAAKvB,KAA7B,CAAxB,EAA8D6B,IAAD,IAAU;AACjF,aAAO,KAAKrB,OAAL,CAAaqB,IAAI,CAACT,GAAlB,KAA0B,IAA1B,IAAkC,CAAC8C,OAAO,CAACrC,IAAI,CAACT,GAAN,CAAjD;AACH,KAFa,CAAd;AAGA,SAAKpB,KAAL,GAAavB,QAAQ,CAACW,OAAT,CAAiB0D,SAAjB,CAA2BrE,QAAQ,CAACW,OAAT,CAAiB2D,GAAjB,CAAqBtE,QAAQ,CAACW,OAAT,CAAiBc,GAAjB,CAAqBF,KAArB,EAA4B,KAA5B,CAArB,EAAyDA,KAAzD,CAA3B,CAAb;;AACA,QAAId,OAAO,IAAI,IAAf,EAAqB;AACjB,aAAOA,OAAO,EAAd;AACH;AACJ;;AA7OY","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst async_1 = __importDefault(require(\"async\"));\nconst utils = __importStar(require(\"./utils\"));\nconst utils_1 = require(\"./utils\");\nconst selector_1 = require(\"./selector\");\nclass MemoryDb {\n    // Options are:\n    //  safety: How to protect the in-memory copies: \"clone\" (default) returns a fresh copy but is slow. \"freeze\" returns a frozen version\n    constructor(options, success) {\n        this.collections = {};\n        this.options = lodash_1.default.defaults(options, { safety: \"clone\" });\n        if (success) {\n            success(this);\n        }\n    }\n    addCollection(name, success, error) {\n        const collection = new Collection(name, this.options);\n        this[name] = collection;\n        this.collections[name] = collection;\n        if (success != null) {\n            return success();\n        }\n    }\n    removeCollection(name, success, error) {\n        delete this[name];\n        delete this.collections[name];\n        if (success != null) {\n            return success();\n        }\n    }\n    getCollectionNames() {\n        return lodash_1.default.keys(this.collections);\n    }\n}\nexports.default = MemoryDb;\n// Stores data in memory\nclass Collection {\n    constructor(name, options) {\n        // Applies safety (either freezing or cloning to object or array)\n        this._applySafety = (items) => {\n            if (!items) {\n                return items;\n            }\n            if (lodash_1.default.isArray(items)) {\n                return lodash_1.default.map(items, this._applySafety);\n            }\n            if (this.options.safety === \"clone\" || !this.options.safety) {\n                return JSON.parse(JSON.stringify(items));\n            }\n            if (this.options.safety === \"freeze\") {\n                Object.freeze(items);\n                return items;\n            }\n            throw new Error(`Unsupported safety ${this.options.safety}`);\n        };\n        this.name = name;\n        this.items = {};\n        this.upserts = {}; // Pending upserts by _id. Still in items\n        this.removes = {}; // Pending removes by _id. No longer in items\n        this.options = options || {};\n    }\n    find(selector, options) {\n        return {\n            fetch: (success, error) => {\n                return this._findFetch(selector, options, success, error);\n            }\n        };\n    }\n    findOne(selector, options, success, error) {\n        if (lodash_1.default.isFunction(options)) {\n            ;\n            [options, success, error] = [{}, options, success];\n        }\n        return this.find(selector, options).fetch((results) => {\n            if (success != null) {\n                return success(this._applySafety(results.length > 0 ? results[0] : null));\n            }\n        }, error);\n    }\n    _findFetch(selector, options, success, error) {\n        // Defer to allow other processes to run\n        return setTimeout(() => {\n            // Shortcut if _id is specified\n            let allItems;\n            if (selector && selector._id && lodash_1.default.isString(selector._id)) {\n                allItems = lodash_1.default.compact([this.items[selector._id]]);\n            }\n            else {\n                allItems = lodash_1.default.values(this.items);\n            }\n            const results = (0, utils_1.processFind)(allItems, selector, options);\n            if (success != null) {\n                return success(this._applySafety(results));\n            }\n        }, 0);\n    }\n    upsert(docs, bases, success, error) {\n        let items;\n        [items, success, error] = utils.regularizeUpsert(docs, bases, success, error);\n        // Keep independent copies to prevent modification\n        items = JSON.parse(JSON.stringify(items));\n        for (let item of items) {\n            // Fill in base if undefined\n            if (item.base === undefined) {\n                // Use existing base\n                if (this.upserts[item.doc._id]) {\n                    item.base = this.upserts[item.doc._id].base;\n                }\n                else {\n                    item.base = this.items[item.doc._id] || null;\n                }\n            }\n            // Replace/add\n            this.items[item.doc._id] = item.doc;\n            this.upserts[item.doc._id] = item;\n        }\n        if (lodash_1.default.isArray(docs)) {\n            if (success) {\n                return success(this._applySafety(lodash_1.default.map(items, \"doc\")));\n            }\n        }\n        else {\n            if (success) {\n                return success(this._applySafety(lodash_1.default.map(items, \"doc\")[0]));\n            }\n        }\n    }\n    remove(id, success, error) {\n        // Special case for filter-type remove\n        if (lodash_1.default.isObject(id)) {\n            this.find(id).fetch((rows) => {\n                return async_1.default.each(rows, ((row, cb) => {\n                    return this.remove(row._id, () => cb(), cb);\n                }), () => success());\n            }, error);\n            return;\n        }\n        if (lodash_1.default.has(this.items, id)) {\n            this.removes[id] = this.items[id];\n            delete this.items[id];\n            delete this.upserts[id];\n        }\n        else {\n            this.removes[id] = { _id: id };\n        }\n        if (success != null) {\n            return success();\n        }\n    }\n    // Options are find options with optional \"exclude\" which is list of _ids to exclude\n    cache(docs, selector, options, success, error) {\n        // Add all non-local that are not upserted or removed\n        let sort;\n        for (let doc of docs) {\n            // Exclude any excluded _ids from being cached/uncached\n            if (options && options.exclude && options.exclude.includes(doc._id)) {\n                continue;\n            }\n            this.cacheOne(doc, () => { }, () => { });\n        }\n        const docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n        if (options.sort) {\n            sort = (0, selector_1.compileSort)(options.sort);\n        }\n        // Perform query, removing rows missing in docs from local db\n        return this.find(selector, options).fetch((results) => {\n            for (let result of results) {\n                if (!docsMap[result._id] && !lodash_1.default.has(this.upserts, result._id)) {\n                    // If at limit\n                    if (options.limit && docs.length === options.limit) {\n                        // If past end on sorted limited, ignore\n                        if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n                            continue;\n                        }\n                        // If no sort, ignore\n                        if (!options.sort) {\n                            continue;\n                        }\n                    }\n                    // Exclude any excluded _ids from being cached/uncached\n                    if (options && options.exclude && options.exclude.includes(result._id)) {\n                        continue;\n                    }\n                    delete this.items[result._id];\n                }\n            }\n            if (success != null) {\n                return success();\n            }\n        }, error);\n    }\n    pendingUpserts(success) {\n        return success(lodash_1.default.values(this.upserts));\n    }\n    pendingRemoves(success) {\n        return success(lodash_1.default.map(this.removes, \"_id\"));\n    }\n    resolveUpserts(upserts, success) {\n        for (let upsert of upserts) {\n            const id = upsert.doc._id;\n            if (this.upserts[id]) {\n                // Only safely remove upsert if doc is unchanged\n                if (lodash_1.default.isEqual(upsert.doc, this.upserts[id].doc)) {\n                    delete this.upserts[id];\n                }\n                else {\n                    // Just update base\n                    this.upserts[id].base = upsert.doc;\n                }\n            }\n        }\n        if (success != null) {\n            return success();\n        }\n    }\n    resolveRemove(id, success) {\n        delete this.removes[id];\n        if (success != null) {\n            return success();\n        }\n    }\n    // Add but do not overwrite or record as upsert\n    seed(docs, success) {\n        if (!lodash_1.default.isArray(docs)) {\n            docs = [docs];\n        }\n        for (let doc of docs) {\n            if (!lodash_1.default.has(this.items, doc._id) && !lodash_1.default.has(this.removes, doc._id)) {\n                this.items[doc._id] = doc;\n            }\n        }\n        if (success != null) {\n            return success();\n        }\n    }\n    // Add but do not overwrite upserts or removes\n    cacheOne(doc, success, error) {\n        return this.cacheList([doc], success, error);\n    }\n    // Add but do not overwrite upserts or removes\n    cacheList(docs, success, error) {\n        for (let doc of docs) {\n            if (!lodash_1.default.has(this.upserts, doc._id) && !lodash_1.default.has(this.removes, doc._id)) {\n                const existing = this.items[doc._id];\n                // If _rev present, make sure that not overwritten by lower or equal _rev\n                if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n                    this.items[doc._id] = doc;\n                }\n            }\n        }\n        if (success != null) {\n            return success();\n        }\n    }\n    uncache(selector, success, error) {\n        const compiledSelector = utils.compileDocumentSelector(selector);\n        const items = lodash_1.default.filter(lodash_1.default.values(this.items), (item) => {\n            return this.upserts[item._id] != null || !compiledSelector(item);\n        });\n        this.items = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(items, \"_id\"), items));\n        if (success != null) {\n            return success();\n        }\n    }\n    uncacheList(ids, success, error) {\n        const idIndex = lodash_1.default.keyBy(ids);\n        const items = lodash_1.default.filter(lodash_1.default.values(this.items), (item) => {\n            return this.upserts[item._id] != null || !idIndex[item._id];\n        });\n        this.items = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(items, \"_id\"), items));\n        if (success != null) {\n            return success();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script"}