{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HybridCollection = void 0;\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst utils = __importStar(require(\"./utils\"));\n/** Bridges a local and remote database, querying from the local first and then\n * getting the remote. Also uploads changes from local to remote.\n */\n\n\nclass HybridDb {\n  constructor(localDb, remoteDb) {\n    this.localDb = localDb;\n    this.remoteDb = remoteDb;\n    this.collections = {};\n  }\n\n  addCollection(name, options, success, error) {\n    // Shift options over if not present\n    if (lodash_1.default.isFunction(options)) {\n      ;\n      [options, success, error] = [{}, options, success];\n    }\n\n    const collection = new HybridCollection(name, this.localDb[name], this.remoteDb[name], options);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success != null) {\n      return success();\n    }\n  }\n\n  removeCollection(name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n\n    if (success != null) {\n      return success();\n    }\n  }\n\n  upload(success, error) {\n    const cols = Object.values(this.collections);\n\n    function uploadCols(cols, success, error) {\n      const col = lodash_1.default.first(cols);\n\n      if (col) {\n        col.upload(() => uploadCols(lodash_1.default.tail(cols), success, error), err => error(err));\n      } else {\n        success();\n      }\n    }\n\n    return uploadCols(cols, success, error);\n  }\n\n  getCollectionNames() {\n    return lodash_1.default.keys(this.collections);\n  }\n\n}\n\nexports.default = HybridDb;\n\nclass HybridCollection {\n  // Options includes\n  constructor(name, localCol, remoteCol, options) {\n    this.name = name;\n    this.localCol = localCol;\n    this.remoteCol = remoteCol; // Default options\n\n    this.options = options || {};\n    lodash_1.default.defaults(this.options, {\n      cacheFind: true,\n      cacheFindOne: true,\n      interim: true,\n      useLocalOnRemoteError: true,\n      shortcut: false,\n      timeout: 0,\n      sortUpserts: null // Compare function to sort upserts sent to server\n\n    });\n  }\n\n  find(selector) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return {\n      fetch: (success, error) => {\n        return this._findFetch(selector, options, success, error);\n      }\n    };\n  }\n\n  findOne(selector, options, success, error) {\n    if (lodash_1.default.isFunction(options)) {\n      ;\n      [options, success, error] = [{}, options, success];\n    } // Merge options\n\n\n    lodash_1.default.defaults(options, this.options); // Happens after initial find\n\n    const step2 = localDoc => {\n      const findOptions = lodash_1.default.cloneDeep(options);\n      findOptions.interim = false;\n      findOptions.cacheFind = options.cacheFindOne;\n\n      if (selector._id) {\n        findOptions.limit = 1;\n      } else {\n        // Without _id specified, interaction between local and remote changes is complex\n        // For example, if the one result returned by remote is locally deleted, we have no fallback\n        // So instead we do a find with no limit and then take the first result, which is very inefficient\n        delete findOptions.limit;\n      }\n\n      return this.find(selector, findOptions).fetch(function (data) {\n        // Return first entry or null\n        if (data.length > 0) {\n          // Check that different from existing\n          if (!lodash_1.default.isEqual(localDoc, data[0])) {\n            return success(data[0]);\n          }\n        } else {\n          // If nothing found, always report it, as interim find doesn't return null\n          return success(null);\n        }\n      }, error);\n    }; // If interim or shortcut, get local first\n\n\n    if (options.interim || options.shortcut) {\n      return this.localCol.findOne(selector, options, function (localDoc) {\n        // If found, return\n        if (localDoc) {\n          success(lodash_1.default.cloneDeep(localDoc)); // If shortcut, we're done\n\n          if (options.shortcut) {\n            return;\n          }\n        }\n\n        return step2(localDoc);\n      }, error);\n    } else {\n      return step2(null);\n    }\n  }\n\n  _findFetch(selector, options, success, error) {\n    // Merge options\n    lodash_1.default.defaults(options, this.options); // Get pending removes and upserts immediately to avoid odd race conditions\n\n    return this.localCol.pendingUpserts(upserts => {\n      return this.localCol.pendingRemoves(removes => {\n        const step2 = localData => {\n          // Setup remote options\n          const remoteOptions = lodash_1.default.cloneDeep(options); // If caching, get all fields\n\n          if (options.cacheFind) {\n            delete remoteOptions.fields;\n          } // Add localData to options for remote find for quickfind protocol\n\n\n          remoteOptions.localData = localData; // Setup timer variables\n\n          let timer = null;\n          let timedOut = false;\n\n          const remoteSuccess = remoteData => {\n            // Cancel timer\n            if (timer) {\n              clearTimeout(timer);\n            } // Ignore if timed out, caching asynchronously\n\n\n            if (timedOut) {\n              if (options.cacheFind) {\n                this.localCol.cache(remoteData, selector, options, function () {}, error);\n              }\n\n              return;\n            }\n\n            if (options.cacheFind) {\n              // Cache locally\n              const cacheSuccess = () => {\n                // Get local data again\n                function localSuccess2(localData2) {\n                  // Check if different or not interim\n                  if (!options.interim || !lodash_1.default.isEqual(localData, localData2)) {\n                    // Send again\n                    return success(localData2);\n                  }\n                }\n\n                return this.localCol.find(selector, options).fetch(localSuccess2, error);\n              }; // Exclude any recent upserts/removes to prevent race condition\n\n\n              const cacheOptions = lodash_1.default.extend({}, options, {\n                exclude: removes.concat(lodash_1.default.map(upserts, u => u.doc._id))\n              });\n              return this.localCol.cache(remoteData, selector, cacheOptions, cacheSuccess, error);\n            } else {\n              // Remove local remotes\n              let data = remoteData;\n\n              if (removes.length > 0) {\n                const removesMap = lodash_1.default.fromPairs(lodash_1.default.map(removes, id => [id, id]));\n                data = lodash_1.default.filter(remoteData, doc => !lodash_1.default.has(removesMap, doc._id));\n              } // Add upserts\n\n\n              if (upserts.length > 0) {\n                // Remove upserts from data\n                const upsertsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(upserts, u => u.doc._id), lodash_1.default.map(upserts, u => u.doc._id)));\n                data = lodash_1.default.filter(data, doc => !lodash_1.default.has(upsertsMap, doc._id)); // Add upserts\n\n                data = data.concat(lodash_1.default.map(upserts, \"doc\")); // Refilter/sort/limit\n\n                data = (0, utils_1.processFind)(data, selector, options);\n              } // Check if different or not interim\n\n\n              if (!options.interim || !lodash_1.default.isEqual(localData, data)) {\n                // Send again\n                return success(data);\n              }\n            }\n          };\n\n          const remoteError = err => {\n            // Cancel timer\n            if (timer) {\n              clearTimeout(timer);\n            }\n\n            if (timedOut) {\n              return;\n            } // If no interim, do local find\n\n\n            if (!options.interim) {\n              if (options.useLocalOnRemoteError) {\n                return success(localData);\n              } else {\n                if (error) {\n                  return error(err);\n                }\n              }\n            } else {\n              // Otherwise do nothing\n              return;\n            }\n          }; // Start timer if remote\n\n\n          if (options.timeout) {\n            timer = setTimeout(() => {\n              timer = null;\n              timedOut = true; // If no interim, do local find\n\n              if (!options.interim) {\n                if (options.useLocalOnRemoteError) {\n                  return this.localCol.find(selector, options).fetch(success, error);\n                } else {\n                  if (error) {\n                    return error(new Error(\"Remote timed out\"));\n                  }\n                }\n              } else {\n                // Otherwise do nothing\n                return;\n              }\n            }, options.timeout);\n          }\n\n          return this.remoteCol.find(selector, remoteOptions).fetch(remoteSuccess, remoteError);\n        };\n\n        function localSuccess(localData) {\n          // If interim, return data immediately\n          if (options.interim) {\n            success(localData);\n          }\n\n          return step2(localData);\n        } // Always get local data first\n\n\n        return this.localCol.find(selector, options).fetch(localSuccess, error);\n      }, error);\n    }, error);\n  }\n\n  upsert(docs, bases, success, error) {\n    let items;\n    [items, success, error] = utils.regularizeUpsert(docs, bases, success, error);\n    return this.localCol.upsert(lodash_1.default.map(items, \"doc\"), lodash_1.default.map(items, \"base\"), result => success === null || success === void 0 ? void 0 : success(docs), error);\n  }\n\n  remove(id, success, error) {\n    return this.localCol.remove(id, function () {\n      if (success != null) {\n        return success();\n      }\n    }, error);\n  }\n\n  upload(success, error) {\n    const uploadUpserts = (upserts, success, error) => {\n      const upsert = lodash_1.default.first(upserts);\n\n      if (upsert) {\n        return this.remoteCol.upsert(upsert.doc, upsert.base, remoteDoc => {\n          return this.localCol.resolveUpserts([upsert], () => {\n            // Cache new value if present\n            if (remoteDoc) {\n              return this.localCol.cacheOne(remoteDoc, () => uploadUpserts(lodash_1.default.tail(upserts), success, error), error);\n            } else {\n              // Remove local\n              return this.localCol.remove(upsert.doc._id, () => {\n                // Resolve remove\n                return this.localCol.resolveRemove(upsert.doc._id, () => uploadUpserts(lodash_1.default.tail(upserts), success, error), error);\n              }, error);\n            }\n          }, error);\n        }, err => {\n          // If 410 error or 403, remove document\n          if (err.status === 410 || err.status === 403) {\n            return this.localCol.remove(upsert.doc._id, () => {\n              // Resolve remove\n              return this.localCol.resolveRemove(upsert.doc._id, function () {\n                // Continue if was 410\n                if (err.status === 410) {\n                  return uploadUpserts(lodash_1.default.tail(upserts), success, error);\n                } else {\n                  return error(err);\n                }\n              }, error);\n            }, error);\n          } else {\n            return error(err);\n          }\n        });\n      } else {\n        return success();\n      }\n    };\n\n    const uploadRemoves = (removes, success, error) => {\n      const remove = lodash_1.default.first(removes);\n\n      if (remove) {\n        return this.remoteCol.remove(remove, () => {\n          return this.localCol.resolveRemove(remove, () => uploadRemoves(lodash_1.default.tail(removes), success, error), error);\n        }, err => {\n          // If 403 or 410, remove document\n          if (err.status === 410 || err.status === 403) {\n            return this.localCol.resolveRemove(remove, function () {\n              // Continue if was 410\n              if (err.status === 410) {\n                return uploadRemoves(lodash_1.default.tail(removes), success, error);\n              } else {\n                return error(err);\n              }\n            }, error);\n          } else {\n            return error(err);\n          }\n        });\n      } else {\n        success();\n      }\n    }; // Get pending upserts\n\n\n    this.localCol.pendingUpserts(upserts => {\n      // Sort upserts if sort defined\n      if (this.options.sortUpserts) {\n        upserts.sort((u1, u2) => this.options.sortUpserts(u1.doc, u2.doc));\n      }\n\n      return uploadUpserts(upserts, () => {\n        return this.localCol.pendingRemoves(removes => uploadRemoves(removes, success, error), error);\n      }, error);\n    }, error);\n  }\n\n}\n\nexports.HybridCollection = HybridCollection;","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/minimongo/lib/HybridDb.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__importDefault","exports","HybridCollection","lodash_1","require","utils_1","utils","HybridDb","constructor","localDb","remoteDb","collections","addCollection","name","options","success","error","default","isFunction","collection","removeCollection","upload","cols","values","uploadCols","col","first","tail","err","getCollectionNames","keys","localCol","remoteCol","defaults","cacheFind","cacheFindOne","interim","useLocalOnRemoteError","shortcut","timeout","sortUpserts","find","selector","fetch","_findFetch","findOne","step2","localDoc","findOptions","cloneDeep","_id","limit","data","length","isEqual","pendingUpserts","upserts","pendingRemoves","removes","localData","remoteOptions","fields","timer","timedOut","remoteSuccess","remoteData","clearTimeout","cache","cacheSuccess","localSuccess2","localData2","cacheOptions","extend","exclude","concat","map","u","doc","removesMap","fromPairs","id","filter","has","upsertsMap","zip","processFind","remoteError","setTimeout","Error","localSuccess","upsert","docs","bases","items","regularizeUpsert","remove","uploadUpserts","base","remoteDoc","resolveUpserts","cacheOne","resolveRemove","status","uploadRemoves","sort","u1","u2"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HybridCollection = void 0;\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst utils_1 = require(\"./utils\");\nconst utils = __importStar(require(\"./utils\"));\n/** Bridges a local and remote database, querying from the local first and then\n * getting the remote. Also uploads changes from local to remote.\n */\nclass HybridDb {\n    constructor(localDb, remoteDb) {\n        this.localDb = localDb;\n        this.remoteDb = remoteDb;\n        this.collections = {};\n    }\n    addCollection(name, options, success, error) {\n        // Shift options over if not present\n        if (lodash_1.default.isFunction(options)) {\n            ;\n            [options, success, error] = [{}, options, success];\n        }\n        const collection = new HybridCollection(name, this.localDb[name], this.remoteDb[name], options);\n        this[name] = collection;\n        this.collections[name] = collection;\n        if (success != null) {\n            return success();\n        }\n    }\n    removeCollection(name, success, error) {\n        delete this[name];\n        delete this.collections[name];\n        if (success != null) {\n            return success();\n        }\n    }\n    upload(success, error) {\n        const cols = Object.values(this.collections);\n        function uploadCols(cols, success, error) {\n            const col = lodash_1.default.first(cols);\n            if (col) {\n                col.upload(() => uploadCols(lodash_1.default.tail(cols), success, error), (err) => error(err));\n            }\n            else {\n                success();\n            }\n        }\n        return uploadCols(cols, success, error);\n    }\n    getCollectionNames() {\n        return lodash_1.default.keys(this.collections);\n    }\n}\nexports.default = HybridDb;\nclass HybridCollection {\n    // Options includes\n    constructor(name, localCol, remoteCol, options) {\n        this.name = name;\n        this.localCol = localCol;\n        this.remoteCol = remoteCol;\n        // Default options\n        this.options = options || {};\n        lodash_1.default.defaults(this.options, {\n            cacheFind: true,\n            cacheFindOne: true,\n            interim: true,\n            useLocalOnRemoteError: true,\n            shortcut: false,\n            timeout: 0,\n            sortUpserts: null // Compare function to sort upserts sent to server\n        });\n    }\n    find(selector, options = {}) {\n        return {\n            fetch: (success, error) => {\n                return this._findFetch(selector, options, success, error);\n            }\n        };\n    }\n    findOne(selector, options, success, error) {\n        if (lodash_1.default.isFunction(options)) {\n            ;\n            [options, success, error] = [{}, options, success];\n        }\n        // Merge options\n        lodash_1.default.defaults(options, this.options);\n        // Happens after initial find\n        const step2 = (localDoc) => {\n            const findOptions = lodash_1.default.cloneDeep(options);\n            findOptions.interim = false;\n            findOptions.cacheFind = options.cacheFindOne;\n            if (selector._id) {\n                findOptions.limit = 1;\n            }\n            else {\n                // Without _id specified, interaction between local and remote changes is complex\n                // For example, if the one result returned by remote is locally deleted, we have no fallback\n                // So instead we do a find with no limit and then take the first result, which is very inefficient\n                delete findOptions.limit;\n            }\n            return this.find(selector, findOptions).fetch(function (data) {\n                // Return first entry or null\n                if (data.length > 0) {\n                    // Check that different from existing\n                    if (!lodash_1.default.isEqual(localDoc, data[0])) {\n                        return success(data[0]);\n                    }\n                }\n                else {\n                    // If nothing found, always report it, as interim find doesn't return null\n                    return success(null);\n                }\n            }, error);\n        };\n        // If interim or shortcut, get local first\n        if (options.interim || options.shortcut) {\n            return this.localCol.findOne(selector, options, function (localDoc) {\n                // If found, return\n                if (localDoc) {\n                    success(lodash_1.default.cloneDeep(localDoc));\n                    // If shortcut, we're done\n                    if (options.shortcut) {\n                        return;\n                    }\n                }\n                return step2(localDoc);\n            }, error);\n        }\n        else {\n            return step2(null);\n        }\n    }\n    _findFetch(selector, options, success, error) {\n        // Merge options\n        lodash_1.default.defaults(options, this.options);\n        // Get pending removes and upserts immediately to avoid odd race conditions\n        return this.localCol.pendingUpserts((upserts) => {\n            return this.localCol.pendingRemoves((removes) => {\n                const step2 = (localData) => {\n                    // Setup remote options\n                    const remoteOptions = lodash_1.default.cloneDeep(options);\n                    // If caching, get all fields\n                    if (options.cacheFind) {\n                        delete remoteOptions.fields;\n                    }\n                    // Add localData to options for remote find for quickfind protocol\n                    remoteOptions.localData = localData;\n                    // Setup timer variables\n                    let timer = null;\n                    let timedOut = false;\n                    const remoteSuccess = (remoteData) => {\n                        // Cancel timer\n                        if (timer) {\n                            clearTimeout(timer);\n                        }\n                        // Ignore if timed out, caching asynchronously\n                        if (timedOut) {\n                            if (options.cacheFind) {\n                                this.localCol.cache(remoteData, selector, options, function () { }, error);\n                            }\n                            return;\n                        }\n                        if (options.cacheFind) {\n                            // Cache locally\n                            const cacheSuccess = () => {\n                                // Get local data again\n                                function localSuccess2(localData2) {\n                                    // Check if different or not interim\n                                    if (!options.interim || !lodash_1.default.isEqual(localData, localData2)) {\n                                        // Send again\n                                        return success(localData2);\n                                    }\n                                }\n                                return this.localCol.find(selector, options).fetch(localSuccess2, error);\n                            };\n                            // Exclude any recent upserts/removes to prevent race condition\n                            const cacheOptions = lodash_1.default.extend({}, options, {\n                                exclude: removes.concat(lodash_1.default.map(upserts, (u) => u.doc._id))\n                            });\n                            return this.localCol.cache(remoteData, selector, cacheOptions, cacheSuccess, error);\n                        }\n                        else {\n                            // Remove local remotes\n                            let data = remoteData;\n                            if (removes.length > 0) {\n                                const removesMap = lodash_1.default.fromPairs(lodash_1.default.map(removes, (id) => [id, id]));\n                                data = lodash_1.default.filter(remoteData, (doc) => !lodash_1.default.has(removesMap, doc._id));\n                            }\n                            // Add upserts\n                            if (upserts.length > 0) {\n                                // Remove upserts from data\n                                const upsertsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(upserts, (u) => u.doc._id), lodash_1.default.map(upserts, (u) => u.doc._id)));\n                                data = lodash_1.default.filter(data, (doc) => !lodash_1.default.has(upsertsMap, doc._id));\n                                // Add upserts\n                                data = data.concat(lodash_1.default.map(upserts, \"doc\"));\n                                // Refilter/sort/limit\n                                data = (0, utils_1.processFind)(data, selector, options);\n                            }\n                            // Check if different or not interim\n                            if (!options.interim || !lodash_1.default.isEqual(localData, data)) {\n                                // Send again\n                                return success(data);\n                            }\n                        }\n                    };\n                    const remoteError = (err) => {\n                        // Cancel timer\n                        if (timer) {\n                            clearTimeout(timer);\n                        }\n                        if (timedOut) {\n                            return;\n                        }\n                        // If no interim, do local find\n                        if (!options.interim) {\n                            if (options.useLocalOnRemoteError) {\n                                return success(localData);\n                            }\n                            else {\n                                if (error) {\n                                    return error(err);\n                                }\n                            }\n                        }\n                        else {\n                            // Otherwise do nothing\n                            return;\n                        }\n                    };\n                    // Start timer if remote\n                    if (options.timeout) {\n                        timer = setTimeout(() => {\n                            timer = null;\n                            timedOut = true;\n                            // If no interim, do local find\n                            if (!options.interim) {\n                                if (options.useLocalOnRemoteError) {\n                                    return this.localCol.find(selector, options).fetch(success, error);\n                                }\n                                else {\n                                    if (error) {\n                                        return error(new Error(\"Remote timed out\"));\n                                    }\n                                }\n                            }\n                            else {\n                                // Otherwise do nothing\n                                return;\n                            }\n                        }, options.timeout);\n                    }\n                    return this.remoteCol.find(selector, remoteOptions).fetch(remoteSuccess, remoteError);\n                };\n                function localSuccess(localData) {\n                    // If interim, return data immediately\n                    if (options.interim) {\n                        success(localData);\n                    }\n                    return step2(localData);\n                }\n                // Always get local data first\n                return this.localCol.find(selector, options).fetch(localSuccess, error);\n            }, error);\n        }, error);\n    }\n    upsert(docs, bases, success, error) {\n        let items;\n        [items, success, error] = utils.regularizeUpsert(docs, bases, success, error);\n        return this.localCol.upsert(lodash_1.default.map(items, \"doc\"), lodash_1.default.map(items, \"base\"), (result) => success === null || success === void 0 ? void 0 : success(docs), error);\n    }\n    remove(id, success, error) {\n        return this.localCol.remove(id, function () {\n            if (success != null) {\n                return success();\n            }\n        }, error);\n    }\n    upload(success, error) {\n        const uploadUpserts = (upserts, success, error) => {\n            const upsert = lodash_1.default.first(upserts);\n            if (upsert) {\n                return this.remoteCol.upsert(upsert.doc, upsert.base, (remoteDoc) => {\n                    return this.localCol.resolveUpserts([upsert], () => {\n                        // Cache new value if present\n                        if (remoteDoc) {\n                            return this.localCol.cacheOne(remoteDoc, () => uploadUpserts(lodash_1.default.tail(upserts), success, error), error);\n                        }\n                        else {\n                            // Remove local\n                            return this.localCol.remove(upsert.doc._id, () => {\n                                // Resolve remove\n                                return this.localCol.resolveRemove(upsert.doc._id, () => uploadUpserts(lodash_1.default.tail(upserts), success, error), error);\n                            }, error);\n                        }\n                    }, error);\n                }, (err) => {\n                    // If 410 error or 403, remove document\n                    if (err.status === 410 || err.status === 403) {\n                        return this.localCol.remove(upsert.doc._id, () => {\n                            // Resolve remove\n                            return this.localCol.resolveRemove(upsert.doc._id, function () {\n                                // Continue if was 410\n                                if (err.status === 410) {\n                                    return uploadUpserts(lodash_1.default.tail(upserts), success, error);\n                                }\n                                else {\n                                    return error(err);\n                                }\n                            }, error);\n                        }, error);\n                    }\n                    else {\n                        return error(err);\n                    }\n                });\n            }\n            else {\n                return success();\n            }\n        };\n        const uploadRemoves = (removes, success, error) => {\n            const remove = lodash_1.default.first(removes);\n            if (remove) {\n                return this.remoteCol.remove(remove, () => {\n                    return this.localCol.resolveRemove(remove, () => uploadRemoves(lodash_1.default.tail(removes), success, error), error);\n                }, (err) => {\n                    // If 403 or 410, remove document\n                    if (err.status === 410 || err.status === 403) {\n                        return this.localCol.resolveRemove(remove, function () {\n                            // Continue if was 410\n                            if (err.status === 410) {\n                                return uploadRemoves(lodash_1.default.tail(removes), success, error);\n                            }\n                            else {\n                                return error(err);\n                            }\n                        }, error);\n                    }\n                    else {\n                        return error(err);\n                    }\n                });\n            }\n            else {\n                success();\n            }\n        };\n        // Get pending upserts\n        this.localCol.pendingUpserts((upserts) => {\n            // Sort upserts if sort defined\n            if (this.options.sortUpserts) {\n                upserts.sort((u1, u2) => this.options.sortUpserts(u1.doc, u2.doc));\n            }\n            return uploadUpserts(upserts, () => {\n                return this.localCol.pendingRemoves((removes) => uploadRemoves(removes, success, error), error);\n            }, error);\n        }, error);\n    }\n}\nexports.HybridCollection = HybridCollection;\n"]},"metadata":{},"sourceType":"script"}