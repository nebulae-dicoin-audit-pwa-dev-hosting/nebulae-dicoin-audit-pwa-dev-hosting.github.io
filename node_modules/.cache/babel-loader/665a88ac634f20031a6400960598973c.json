{"ast":null,"code":"/**\n * auth0-js v9.18.0\n * Author: Auth0\n * Date: 2021-11-09\n * License: MIT\n */\n!function (global, factory) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = factory() : \"function\" == typeof define && define.amd ? define(factory) : (global = global || self).CordovaAuth0Plugin = factory();\n}(this, function () {\n  \"use strict\";\n\n  var version_raw = \"9.18.0\",\n      toString = Object.prototype.toString;\n\n  function attribute(o, attr, type, text) {\n    if (type = \"array\" === type ? \"object\" : type, o && typeof o[attr] !== type) throw new Error(text);\n  }\n\n  function variable(o, type, text) {\n    if (typeof o !== type) throw new Error(text);\n  }\n\n  function value(o, values, text) {\n    if (-1 === values.indexOf(o)) throw new Error(text);\n  }\n\n  var assert = {\n    check: function check(o, config, attributes) {\n      if (config.optional && !o || variable(o, config.type, config.message), \"object\" === config.type && attributes) for (var keys = Object.keys(attributes), index = 0; index < keys.length; index++) {\n        var a = keys[index];\n        attributes[a].optional && !o[a] || attributes[a].condition && !attributes[a].condition(o) || (attribute(o, a, attributes[a].type, attributes[a].message), attributes[a].values && value(o[a], attributes[a].values, attributes[a].value_message));\n      }\n    },\n    attribute: attribute,\n    variable: variable,\n    value: value,\n    isArray: function isArray(array) {\n      return this.supportsIsArray() ? Array.isArray(array) : \"[object Array]\" === toString.call(array);\n    },\n    supportsIsArray: function supportsIsArray() {\n      return null != Array.isArray;\n    }\n  };\n\n  function objectAssignPolyfill(target) {\n    if (null == target) throw new TypeError(\"Cannot convert first argument to object\");\n\n    for (var to = Object(target), i = 1; i < arguments.length; i++) {\n      var nextSource = arguments[i];\n      if (null != nextSource) for (var keysArray = Object.keys(Object(nextSource)), nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n        var nextKey = keysArray[nextIndex],\n            desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        void 0 !== desc && desc.enumerable && (to[nextKey] = nextSource[nextKey]);\n      }\n    }\n\n    return to;\n  }\n\n  var objectAssign = {\n    get: function get() {\n      return Object.assign ? Object.assign : objectAssignPolyfill;\n    },\n    objectAssignPolyfill: objectAssignPolyfill\n  };\n\n  function pick(object, keys) {\n    return keys.reduce(function (prev, key) {\n      return object[key] && (prev[key] = object[key]), prev;\n    }, {});\n  }\n\n  function objectValues(obj) {\n    var values = [];\n\n    for (var key in obj) {\n      values.push(obj[key]);\n    }\n\n    return values;\n  }\n\n  function extend() {\n    var params = objectValues(arguments);\n    return params.unshift({}), objectAssign.get().apply(void 0, params);\n  }\n\n  function getLocationFromUrl(href) {\n    var match = href.match(/^(https?:|file:|chrome-extension:)\\/\\/(([^:/?#]*)(?::([0-9]+))?)([/]{0,1}[^?#]*)(\\?[^#]*|)(#.*|)$/);\n    return match && {\n      href: href,\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7]\n    };\n  }\n\n  function trim(options, key) {\n    var trimmed = extend(options);\n    return options[key] && (trimmed[key] = options[key].trim()), trimmed;\n  }\n\n  var objectHelper = {\n    toSnakeCase: function toSnakeCase(object, exceptions) {\n      return \"object\" != typeof object || assert.isArray(object) || null === object ? object : (exceptions = exceptions || [], Object.keys(object).reduce(function (p, key) {\n        return p[-1 === exceptions.indexOf(key) ? function (str) {\n          for (var code, newKey = \"\", index = 0, wasPrevNumber = !0, wasPrevUppercase = !0; index < str.length;) {\n            code = str.charCodeAt(index), !wasPrevUppercase && code >= 65 && code <= 90 || !wasPrevNumber && code >= 48 && code <= 57 ? (newKey += \"_\", newKey += str[index].toLowerCase()) : newKey += str[index].toLowerCase(), wasPrevNumber = code >= 48 && code <= 57, wasPrevUppercase = code >= 65 && code <= 90, index++;\n          }\n\n          return newKey;\n        }(key) : key] = toSnakeCase(object[key]), p;\n      }, {}));\n    },\n    toCamelCase: function toCamelCase(object, exceptions, options) {\n      return \"object\" != typeof object || assert.isArray(object) || null === object ? object : (exceptions = exceptions || [], options = options || {}, Object.keys(object).reduce(function (p, key) {\n        var parts,\n            newKey = -1 === exceptions.indexOf(key) ? (parts = key.split(\"_\")).reduce(function (p, c) {\n          return p + c.charAt(0).toUpperCase() + c.slice(1);\n        }, parts.shift()) : key;\n        return p[newKey] = toCamelCase(object[newKey] || object[key], [], options), options.keepOriginal && (p[key] = toCamelCase(object[key], [], options)), p;\n      }, {}));\n    },\n    blacklist: function blacklist(object, blacklistedKeys) {\n      return Object.keys(object).reduce(function (p, key) {\n        return -1 === blacklistedKeys.indexOf(key) && (p[key] = object[key]), p;\n      }, {});\n    },\n    merge: function merge(object, keys) {\n      return {\n        base: keys ? pick(object, keys) : object,\n        with: function _with(object2, keys2) {\n          return object2 = keys2 ? pick(object2, keys2) : object2, extend(this.base, object2);\n        }\n      };\n    },\n    pick: pick,\n    getKeysNotIn: function getKeysNotIn(obj, allowedKeys) {\n      var notAllowed = [];\n\n      for (var key in obj) {\n        -1 === allowedKeys.indexOf(key) && notAllowed.push(key);\n      }\n\n      return notAllowed;\n    },\n    extend: extend,\n    getOriginFromUrl: function getOriginFromUrl(url) {\n      if (url) {\n        var parsed = getLocationFromUrl(url);\n        if (!parsed) return null;\n        var origin = parsed.protocol + \"//\" + parsed.hostname;\n        return parsed.port && (origin += \":\" + parsed.port), origin;\n      }\n    },\n    getLocationFromUrl: getLocationFromUrl,\n    trimUserDetails: function trimUserDetails(options) {\n      return function (options, keys) {\n        return keys.reduce(trim, options);\n      }(options, [\"username\", \"email\", \"phoneNumber\"]);\n    },\n    updatePropertyOn: function updatePropertyOn(obj, path, value) {\n      \"string\" == typeof path && (path = path.split(\".\"));\n      var next = path[0];\n      obj.hasOwnProperty(next) && (1 === path.length ? obj[next] = value : updatePropertyOn(obj[next], path.slice(1), value));\n    }\n  };\n\n  function getWindow() {\n    return window;\n  }\n\n  var windowHandler = {\n    redirect: function redirect(url) {\n      getWindow().location = url;\n    },\n    getDocument: function getDocument() {\n      return getWindow().document;\n    },\n    getWindow: getWindow,\n    getOrigin: function getOrigin() {\n      var location = getWindow().location,\n          origin = location.origin;\n      return origin || (origin = objectHelper.getOriginFromUrl(location.href)), origin;\n    }\n  },\n      commonjsGlobal = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\n\n  function createCommonjsModule(fn, module) {\n    return fn(module = {\n      exports: {}\n    }, module.exports), module.exports;\n  }\n\n  var urlJoin = createCommonjsModule(function (module) {\n    var context, definition;\n    context = commonjsGlobal, definition = function definition() {\n      function normalize(strArray) {\n        var resultArray = [];\n        if (0 === strArray.length) return \"\";\n        if (\"string\" != typeof strArray[0]) throw new TypeError(\"Url must be a string. Received \" + strArray[0]);\n\n        if (strArray[0].match(/^[^/:]+:\\/*$/) && strArray.length > 1) {\n          var first = strArray.shift();\n          strArray[0] = first + strArray[0];\n        }\n\n        strArray[0].match(/^file:\\/\\/\\//) ? strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, \"$1:///\") : strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, \"$1://\");\n\n        for (var i = 0; i < strArray.length; i++) {\n          var component = strArray[i];\n          if (\"string\" != typeof component) throw new TypeError(\"Url must be a string. Received \" + component);\n          \"\" !== component && (i > 0 && (component = component.replace(/^[\\/]+/, \"\")), component = i < strArray.length - 1 ? component.replace(/[\\/]+$/, \"\") : component.replace(/[\\/]+$/, \"/\"), resultArray.push(component));\n        }\n\n        var str = resultArray.join(\"/\"),\n            parts = (str = str.replace(/\\/(\\?|&|#[^!])/g, \"$1\")).split(\"?\");\n        return str = parts.shift() + (parts.length > 0 ? \"?\" : \"\") + parts.join(\"&\");\n      }\n\n      return function () {\n        return normalize(\"object\" == typeof arguments[0] ? arguments[0] : [].slice.call(arguments));\n      };\n    }, module.exports ? module.exports = definition() : context.urljoin = definition();\n  }),\n      origSymbol = commonjsGlobal.Symbol,\n      ERROR_MESSAGE = \"Function.prototype.bind called on incompatible \",\n      slice = Array.prototype.slice,\n      toStr = Object.prototype.toString,\n      functionBind = Function.prototype.bind || function (that) {\n    var target = this;\n    if (\"function\" != typeof target || \"[object Function]\" !== toStr.call(target)) throw new TypeError(ERROR_MESSAGE + target);\n\n    for (var bound, args = slice.call(arguments, 1), binder = function binder() {\n      if (this instanceof bound) {\n        var result = target.apply(this, args.concat(slice.call(arguments)));\n        return Object(result) === result ? result : this;\n      }\n\n      return target.apply(that, args.concat(slice.call(arguments)));\n    }, boundLength = Math.max(0, target.length - args.length), boundArgs = [], i = 0; i < boundLength; i++) {\n      boundArgs.push(\"$\" + i);\n    }\n\n    if (bound = Function(\"binder\", \"return function (\" + boundArgs.join(\",\") + \"){ return binder.apply(this,arguments); }\")(binder), target.prototype) {\n      var Empty = function Empty() {};\n\n      Empty.prototype = target.prototype, bound.prototype = new Empty(), Empty.prototype = null;\n    }\n\n    return bound;\n  },\n      src = functionBind.call(Function.call, Object.prototype.hasOwnProperty),\n      $SyntaxError = SyntaxError,\n      $Function = Function,\n      $TypeError = TypeError,\n      getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {\n    try {\n      return $Function('\"use strict\"; return (' + expressionSyntax + \").constructor;\")();\n    } catch (e) {}\n  },\n      $gOPD = Object.getOwnPropertyDescriptor;\n\n  if ($gOPD) try {\n    $gOPD({}, \"\");\n  } catch (e) {\n    $gOPD = null;\n  }\n\n  var n,\n      throwTypeError = function throwTypeError() {\n    throw new $TypeError();\n  },\n      ThrowTypeError = $gOPD ? function () {\n    try {\n      return throwTypeError;\n    } catch (calleeThrows) {\n      try {\n        return $gOPD(arguments, \"callee\").get;\n      } catch (gOPDthrows) {\n        return throwTypeError;\n      }\n    }\n  }() : throwTypeError,\n      hasSymbols$1 = \"function\" == typeof origSymbol && \"function\" == typeof Symbol && \"symbol\" == typeof origSymbol(\"foo\") && \"symbol\" == typeof Symbol(\"bar\") && function () {\n    if (\"function\" != typeof Symbol || \"function\" != typeof Object.getOwnPropertySymbols) return !1;\n    if (\"symbol\" == typeof Symbol.iterator) return !0;\n    var obj = {},\n        sym = Symbol(\"test\"),\n        symObj = Object(sym);\n    if (\"string\" == typeof sym) return !1;\n    if (\"[object Symbol]\" !== Object.prototype.toString.call(sym)) return !1;\n    if (\"[object Symbol]\" !== Object.prototype.toString.call(symObj)) return !1;\n\n    for (sym in obj[sym] = 42, obj) {\n      return !1;\n    }\n\n    if (\"function\" == typeof Object.keys && 0 !== Object.keys(obj).length) return !1;\n    if (\"function\" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(obj).length) return !1;\n    var syms = Object.getOwnPropertySymbols(obj);\n    if (1 !== syms.length || syms[0] !== sym) return !1;\n    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return !1;\n\n    if (\"function\" == typeof Object.getOwnPropertyDescriptor) {\n      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n      if (42 !== descriptor.value || !0 !== descriptor.enumerable) return !1;\n    }\n\n    return !0;\n  }(),\n      getProto = Object.getPrototypeOf || function (x) {\n    return x.__proto__;\n  },\n      needsEval = {},\n      TypedArray = \"undefined\" == typeof Uint8Array ? void 0 : getProto(Uint8Array),\n      INTRINSICS = {\n    \"%AggregateError%\": \"undefined\" == typeof AggregateError ? void 0 : AggregateError,\n    \"%Array%\": Array,\n    \"%ArrayBuffer%\": \"undefined\" == typeof ArrayBuffer ? void 0 : ArrayBuffer,\n    \"%ArrayIteratorPrototype%\": hasSymbols$1 ? getProto([][Symbol.iterator]()) : void 0,\n    \"%AsyncFromSyncIteratorPrototype%\": void 0,\n    \"%AsyncFunction%\": needsEval,\n    \"%AsyncGenerator%\": needsEval,\n    \"%AsyncGeneratorFunction%\": needsEval,\n    \"%AsyncIteratorPrototype%\": needsEval,\n    \"%Atomics%\": \"undefined\" == typeof Atomics ? void 0 : Atomics,\n    \"%BigInt%\": \"undefined\" == typeof BigInt ? void 0 : BigInt,\n    \"%Boolean%\": Boolean,\n    \"%DataView%\": \"undefined\" == typeof DataView ? void 0 : DataView,\n    \"%Date%\": Date,\n    \"%decodeURI%\": decodeURI,\n    \"%decodeURIComponent%\": decodeURIComponent,\n    \"%encodeURI%\": encodeURI,\n    \"%encodeURIComponent%\": encodeURIComponent,\n    \"%Error%\": Error,\n    \"%eval%\": eval,\n    \"%EvalError%\": EvalError,\n    \"%Float32Array%\": \"undefined\" == typeof Float32Array ? void 0 : Float32Array,\n    \"%Float64Array%\": \"undefined\" == typeof Float64Array ? void 0 : Float64Array,\n    \"%FinalizationRegistry%\": \"undefined\" == typeof FinalizationRegistry ? void 0 : FinalizationRegistry,\n    \"%Function%\": $Function,\n    \"%GeneratorFunction%\": needsEval,\n    \"%Int8Array%\": \"undefined\" == typeof Int8Array ? void 0 : Int8Array,\n    \"%Int16Array%\": \"undefined\" == typeof Int16Array ? void 0 : Int16Array,\n    \"%Int32Array%\": \"undefined\" == typeof Int32Array ? void 0 : Int32Array,\n    \"%isFinite%\": isFinite,\n    \"%isNaN%\": isNaN,\n    \"%IteratorPrototype%\": hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : void 0,\n    \"%JSON%\": \"object\" == typeof JSON ? JSON : void 0,\n    \"%Map%\": \"undefined\" == typeof Map ? void 0 : Map,\n    \"%MapIteratorPrototype%\": \"undefined\" != typeof Map && hasSymbols$1 ? getProto(new Map()[Symbol.iterator]()) : void 0,\n    \"%Math%\": Math,\n    \"%Number%\": Number,\n    \"%Object%\": Object,\n    \"%parseFloat%\": parseFloat,\n    \"%parseInt%\": parseInt,\n    \"%Promise%\": \"undefined\" == typeof Promise ? void 0 : Promise,\n    \"%Proxy%\": \"undefined\" == typeof Proxy ? void 0 : Proxy,\n    \"%RangeError%\": RangeError,\n    \"%ReferenceError%\": ReferenceError,\n    \"%Reflect%\": \"undefined\" == typeof Reflect ? void 0 : Reflect,\n    \"%RegExp%\": RegExp,\n    \"%Set%\": \"undefined\" == typeof Set ? void 0 : Set,\n    \"%SetIteratorPrototype%\": \"undefined\" != typeof Set && hasSymbols$1 ? getProto(new Set()[Symbol.iterator]()) : void 0,\n    \"%SharedArrayBuffer%\": \"undefined\" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer,\n    \"%String%\": String,\n    \"%StringIteratorPrototype%\": hasSymbols$1 ? getProto(\"\"[Symbol.iterator]()) : void 0,\n    \"%Symbol%\": hasSymbols$1 ? Symbol : void 0,\n    \"%SyntaxError%\": $SyntaxError,\n    \"%ThrowTypeError%\": ThrowTypeError,\n    \"%TypedArray%\": TypedArray,\n    \"%TypeError%\": $TypeError,\n    \"%Uint8Array%\": \"undefined\" == typeof Uint8Array ? void 0 : Uint8Array,\n    \"%Uint8ClampedArray%\": \"undefined\" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray,\n    \"%Uint16Array%\": \"undefined\" == typeof Uint16Array ? void 0 : Uint16Array,\n    \"%Uint32Array%\": \"undefined\" == typeof Uint32Array ? void 0 : Uint32Array,\n    \"%URIError%\": URIError,\n    \"%WeakMap%\": \"undefined\" == typeof WeakMap ? void 0 : WeakMap,\n    \"%WeakRef%\": \"undefined\" == typeof WeakRef ? void 0 : WeakRef,\n    \"%WeakSet%\": \"undefined\" == typeof WeakSet ? void 0 : WeakSet\n  },\n      LEGACY_ALIASES = {\n    \"%ArrayBufferPrototype%\": [\"ArrayBuffer\", \"prototype\"],\n    \"%ArrayPrototype%\": [\"Array\", \"prototype\"],\n    \"%ArrayProto_entries%\": [\"Array\", \"prototype\", \"entries\"],\n    \"%ArrayProto_forEach%\": [\"Array\", \"prototype\", \"forEach\"],\n    \"%ArrayProto_keys%\": [\"Array\", \"prototype\", \"keys\"],\n    \"%ArrayProto_values%\": [\"Array\", \"prototype\", \"values\"],\n    \"%AsyncFunctionPrototype%\": [\"AsyncFunction\", \"prototype\"],\n    \"%AsyncGenerator%\": [\"AsyncGeneratorFunction\", \"prototype\"],\n    \"%AsyncGeneratorPrototype%\": [\"AsyncGeneratorFunction\", \"prototype\", \"prototype\"],\n    \"%BooleanPrototype%\": [\"Boolean\", \"prototype\"],\n    \"%DataViewPrototype%\": [\"DataView\", \"prototype\"],\n    \"%DatePrototype%\": [\"Date\", \"prototype\"],\n    \"%ErrorPrototype%\": [\"Error\", \"prototype\"],\n    \"%EvalErrorPrototype%\": [\"EvalError\", \"prototype\"],\n    \"%Float32ArrayPrototype%\": [\"Float32Array\", \"prototype\"],\n    \"%Float64ArrayPrototype%\": [\"Float64Array\", \"prototype\"],\n    \"%FunctionPrototype%\": [\"Function\", \"prototype\"],\n    \"%Generator%\": [\"GeneratorFunction\", \"prototype\"],\n    \"%GeneratorPrototype%\": [\"GeneratorFunction\", \"prototype\", \"prototype\"],\n    \"%Int8ArrayPrototype%\": [\"Int8Array\", \"prototype\"],\n    \"%Int16ArrayPrototype%\": [\"Int16Array\", \"prototype\"],\n    \"%Int32ArrayPrototype%\": [\"Int32Array\", \"prototype\"],\n    \"%JSONParse%\": [\"JSON\", \"parse\"],\n    \"%JSONStringify%\": [\"JSON\", \"stringify\"],\n    \"%MapPrototype%\": [\"Map\", \"prototype\"],\n    \"%NumberPrototype%\": [\"Number\", \"prototype\"],\n    \"%ObjectPrototype%\": [\"Object\", \"prototype\"],\n    \"%ObjProto_toString%\": [\"Object\", \"prototype\", \"toString\"],\n    \"%ObjProto_valueOf%\": [\"Object\", \"prototype\", \"valueOf\"],\n    \"%PromisePrototype%\": [\"Promise\", \"prototype\"],\n    \"%PromiseProto_then%\": [\"Promise\", \"prototype\", \"then\"],\n    \"%Promise_all%\": [\"Promise\", \"all\"],\n    \"%Promise_reject%\": [\"Promise\", \"reject\"],\n    \"%Promise_resolve%\": [\"Promise\", \"resolve\"],\n    \"%RangeErrorPrototype%\": [\"RangeError\", \"prototype\"],\n    \"%ReferenceErrorPrototype%\": [\"ReferenceError\", \"prototype\"],\n    \"%RegExpPrototype%\": [\"RegExp\", \"prototype\"],\n    \"%SetPrototype%\": [\"Set\", \"prototype\"],\n    \"%SharedArrayBufferPrototype%\": [\"SharedArrayBuffer\", \"prototype\"],\n    \"%StringPrototype%\": [\"String\", \"prototype\"],\n    \"%SymbolPrototype%\": [\"Symbol\", \"prototype\"],\n    \"%SyntaxErrorPrototype%\": [\"SyntaxError\", \"prototype\"],\n    \"%TypedArrayPrototype%\": [\"TypedArray\", \"prototype\"],\n    \"%TypeErrorPrototype%\": [\"TypeError\", \"prototype\"],\n    \"%Uint8ArrayPrototype%\": [\"Uint8Array\", \"prototype\"],\n    \"%Uint8ClampedArrayPrototype%\": [\"Uint8ClampedArray\", \"prototype\"],\n    \"%Uint16ArrayPrototype%\": [\"Uint16Array\", \"prototype\"],\n    \"%Uint32ArrayPrototype%\": [\"Uint32Array\", \"prototype\"],\n    \"%URIErrorPrototype%\": [\"URIError\", \"prototype\"],\n    \"%WeakMapPrototype%\": [\"WeakMap\", \"prototype\"],\n    \"%WeakSetPrototype%\": [\"WeakSet\", \"prototype\"]\n  },\n      $concat = functionBind.call(Function.call, Array.prototype.concat),\n      $spliceApply = functionBind.call(Function.apply, Array.prototype.splice),\n      $replace = functionBind.call(Function.call, String.prototype.replace),\n      $strSlice = functionBind.call(Function.call, String.prototype.slice),\n      rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g,\n      reEscapeChar = /\\\\(\\\\)?/g,\n      stringToPath = function stringToPath(string) {\n    var first = $strSlice(string, 0, 1),\n        last = $strSlice(string, -1);\n    if (\"%\" === first && \"%\" !== last) throw new $SyntaxError(\"invalid intrinsic syntax, expected closing `%`\");\n    if (\"%\" === last && \"%\" !== first) throw new $SyntaxError(\"invalid intrinsic syntax, expected opening `%`\");\n    var result = [];\n    return $replace(string, rePropName, function (match, number, quote, subString) {\n      result[result.length] = quote ? $replace(subString, reEscapeChar, \"$1\") : number || match;\n    }), result;\n  },\n      getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n    var alias,\n        intrinsicName = name;\n\n    if (src(LEGACY_ALIASES, intrinsicName) && (intrinsicName = \"%\" + (alias = LEGACY_ALIASES[intrinsicName])[0] + \"%\"), src(INTRINSICS, intrinsicName)) {\n      var value = INTRINSICS[intrinsicName];\n      if (value === needsEval && (value = function doEval(name) {\n        var value;\n        if (\"%AsyncFunction%\" === name) value = getEvalledConstructor(\"async function () {}\");else if (\"%GeneratorFunction%\" === name) value = getEvalledConstructor(\"function* () {}\");else if (\"%AsyncGeneratorFunction%\" === name) value = getEvalledConstructor(\"async function* () {}\");else if (\"%AsyncGenerator%\" === name) {\n          var fn = doEval(\"%AsyncGeneratorFunction%\");\n          fn && (value = fn.prototype);\n        } else if (\"%AsyncIteratorPrototype%\" === name) {\n          var gen = doEval(\"%AsyncGenerator%\");\n          gen && (value = getProto(gen.prototype));\n        }\n        return INTRINSICS[name] = value, value;\n      }(intrinsicName)), void 0 === value && !allowMissing) throw new $TypeError(\"intrinsic \" + name + \" exists, but is not available. Please file an issue!\");\n      return {\n        alias: alias,\n        name: intrinsicName,\n        value: value\n      };\n    }\n\n    throw new $SyntaxError(\"intrinsic \" + name + \" does not exist!\");\n  },\n      getIntrinsic = function getIntrinsic(name, allowMissing) {\n    if (\"string\" != typeof name || 0 === name.length) throw new $TypeError(\"intrinsic name must be a non-empty string\");\n    if (arguments.length > 1 && \"boolean\" != typeof allowMissing) throw new $TypeError('\"allowMissing\" argument must be a boolean');\n    var parts = stringToPath(name),\n        intrinsicBaseName = parts.length > 0 ? parts[0] : \"\",\n        intrinsic = getBaseIntrinsic(\"%\" + intrinsicBaseName + \"%\", allowMissing),\n        intrinsicRealName = intrinsic.name,\n        value = intrinsic.value,\n        skipFurtherCaching = !1,\n        alias = intrinsic.alias;\n    alias && (intrinsicBaseName = alias[0], $spliceApply(parts, $concat([0, 1], alias)));\n\n    for (var i = 1, isOwn = !0; i < parts.length; i += 1) {\n      var part = parts[i],\n          first = $strSlice(part, 0, 1),\n          last = $strSlice(part, -1);\n      if (('\"' === first || \"'\" === first || \"`\" === first || '\"' === last || \"'\" === last || \"`\" === last) && first !== last) throw new $SyntaxError(\"property names with quotes must have matching quotes\");\n      if (\"constructor\" !== part && isOwn || (skipFurtherCaching = !0), src(INTRINSICS, intrinsicRealName = \"%\" + (intrinsicBaseName += \".\" + part) + \"%\")) value = INTRINSICS[intrinsicRealName];else if (null != value) {\n        if (!(part in value)) {\n          if (!allowMissing) throw new $TypeError(\"base intrinsic for \" + name + \" exists, but the property is not available.\");\n          return;\n        }\n\n        if ($gOPD && i + 1 >= parts.length) {\n          var desc = $gOPD(value, part);\n          value = (isOwn = !!desc) && \"get\" in desc && !(\"originalValue\" in desc.get) ? desc.get : value[part];\n        } else isOwn = src(value, part), value = value[part];\n\n        isOwn && !skipFurtherCaching && (INTRINSICS[intrinsicRealName] = value);\n      }\n    }\n\n    return value;\n  },\n      callBind = createCommonjsModule(function (module) {\n    var $apply = getIntrinsic(\"%Function.prototype.apply%\"),\n        $call = getIntrinsic(\"%Function.prototype.call%\"),\n        $reflectApply = getIntrinsic(\"%Reflect.apply%\", !0) || functionBind.call($call, $apply),\n        $gOPD = getIntrinsic(\"%Object.getOwnPropertyDescriptor%\", !0),\n        $defineProperty = getIntrinsic(\"%Object.defineProperty%\", !0),\n        $max = getIntrinsic(\"%Math.max%\");\n    if ($defineProperty) try {\n      $defineProperty({}, \"a\", {\n        value: 1\n      });\n    } catch (e) {\n      $defineProperty = null;\n    }\n\n    module.exports = function (originalFunction) {\n      var func = $reflectApply(functionBind, $call, arguments);\n\n      if ($gOPD && $defineProperty) {\n        var desc = $gOPD(func, \"length\");\n        desc.configurable && $defineProperty(func, \"length\", {\n          value: 1 + $max(0, originalFunction.length - (arguments.length - 1))\n        });\n      }\n\n      return func;\n    };\n\n    var applyBind = function applyBind() {\n      return $reflectApply(functionBind, $apply, arguments);\n    };\n\n    $defineProperty ? $defineProperty(module.exports, \"apply\", {\n      value: applyBind\n    }) : module.exports.apply = applyBind;\n  }),\n      $indexOf = (callBind.apply, callBind(getIntrinsic(\"String.prototype.indexOf\"))),\n      callBound = function callBound(name, allowMissing) {\n    var intrinsic = getIntrinsic(name, !!allowMissing);\n    return \"function\" == typeof intrinsic && $indexOf(name, \".prototype.\") > -1 ? callBind(intrinsic) : intrinsic;\n  },\n      require$$0 = (n = Object.freeze({\n    __proto__: null,\n    default: {}\n  })) && n.default || n,\n      hasMap = \"function\" == typeof Map && Map.prototype,\n      mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, \"size\") : null,\n      mapSize = hasMap && mapSizeDescriptor && \"function\" == typeof mapSizeDescriptor.get ? mapSizeDescriptor.get : null,\n      mapForEach = hasMap && Map.prototype.forEach,\n      hasSet = \"function\" == typeof Set && Set.prototype,\n      setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, \"size\") : null,\n      setSize = hasSet && setSizeDescriptor && \"function\" == typeof setSizeDescriptor.get ? setSizeDescriptor.get : null,\n      setForEach = hasSet && Set.prototype.forEach,\n      weakMapHas = \"function\" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null,\n      weakSetHas = \"function\" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null,\n      weakRefDeref = \"function\" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null,\n      booleanValueOf = Boolean.prototype.valueOf,\n      objectToString = Object.prototype.toString,\n      functionToString = Function.prototype.toString,\n      match = String.prototype.match,\n      bigIntValueOf = \"function\" == typeof BigInt ? BigInt.prototype.valueOf : null,\n      gOPS = Object.getOwnPropertySymbols,\n      symToString = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? Symbol.prototype.toString : null,\n      hasShammedSymbols = \"function\" == typeof Symbol && \"object\" == typeof Symbol.iterator,\n      isEnumerable = Object.prototype.propertyIsEnumerable,\n      gPO = (\"function\" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function (O) {\n    return O.__proto__;\n  } : null),\n      inspectCustom = require$$0.custom,\n      inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null,\n      toStringTag = \"function\" == typeof Symbol && void 0 !== Symbol.toStringTag ? Symbol.toStringTag : null,\n      objectInspect = function inspect_(obj, options, depth, seen) {\n    var opts = options || {};\n    if (has(opts, \"quoteStyle\") && \"single\" !== opts.quoteStyle && \"double\" !== opts.quoteStyle) throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n    if (has(opts, \"maxStringLength\") && (\"number\" == typeof opts.maxStringLength ? opts.maxStringLength < 0 && opts.maxStringLength !== 1 / 0 : null !== opts.maxStringLength)) throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n    var customInspect = !has(opts, \"customInspect\") || opts.customInspect;\n    if (\"boolean\" != typeof customInspect && \"symbol\" !== customInspect) throw new TypeError(\"option \\\"customInspect\\\", if provided, must be `true`, `false`, or `'symbol'`\");\n    if (has(opts, \"indent\") && null !== opts.indent && \"\\t\" !== opts.indent && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError('options \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n    if (void 0 === obj) return \"undefined\";\n    if (null === obj) return \"null\";\n    if (\"boolean\" == typeof obj) return obj ? \"true\" : \"false\";\n    if (\"string\" == typeof obj) return function inspectString(str, opts) {\n      if (str.length > opts.maxStringLength) {\n        var remaining = str.length - opts.maxStringLength,\n            trailer = \"... \" + remaining + \" more character\" + (remaining > 1 ? \"s\" : \"\");\n        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;\n      }\n\n      return wrapQuotes(str.replace(/(['\\\\])/g, \"\\\\$1\").replace(/[\\x00-\\x1f]/g, lowbyte), \"single\", opts);\n    }(obj, opts);\n    if (\"number\" == typeof obj) return 0 === obj ? 1 / 0 / obj > 0 ? \"0\" : \"-0\" : String(obj);\n    if (\"bigint\" == typeof obj) return String(obj) + \"n\";\n    var maxDepth = void 0 === opts.depth ? 5 : opts.depth;\n    if (void 0 === depth && (depth = 0), depth >= maxDepth && maxDepth > 0 && \"object\" == typeof obj) return isArray$1(obj) ? \"[Array]\" : \"[Object]\";\n\n    var indent = function (opts, depth) {\n      var baseIndent;\n      if (\"\\t\" === opts.indent) baseIndent = \"\\t\";else {\n        if (!(\"number\" == typeof opts.indent && opts.indent > 0)) return null;\n        baseIndent = Array(opts.indent + 1).join(\" \");\n      }\n      return {\n        base: baseIndent,\n        prev: Array(depth + 1).join(baseIndent)\n      };\n    }(opts, depth);\n\n    if (void 0 === seen) seen = [];else if (indexOf(seen, obj) >= 0) return \"[Circular]\";\n\n    function inspect(value, from, noIndent) {\n      if (from && (seen = seen.slice()).push(from), noIndent) {\n        var newOpts = {\n          depth: opts.depth\n        };\n        return has(opts, \"quoteStyle\") && (newOpts.quoteStyle = opts.quoteStyle), inspect_(value, newOpts, depth + 1, seen);\n      }\n\n      return inspect_(value, opts, depth + 1, seen);\n    }\n\n    if (\"function\" == typeof obj) {\n      var name = function (f) {\n        if (f.name) return f.name;\n        var m = match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n        if (m) return m[1];\n        return null;\n      }(obj),\n          keys = arrObjKeys(obj, inspect);\n\n      return \"[Function\" + (name ? \": \" + name : \" (anonymous)\") + \"]\" + (keys.length > 0 ? \" { \" + keys.join(\", \") + \" }\" : \"\");\n    }\n\n    if (isSymbol(obj)) {\n      var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\\(.*\\))_[^)]*$/, \"$1\") : symToString.call(obj);\n      return \"object\" != typeof obj || hasShammedSymbols ? symString : markBoxed(symString);\n    }\n\n    if (function (x) {\n      if (!x || \"object\" != typeof x) return !1;\n      if (\"undefined\" != typeof HTMLElement && x instanceof HTMLElement) return !0;\n      return \"string\" == typeof x.nodeName && \"function\" == typeof x.getAttribute;\n    }(obj)) {\n      for (var s = \"<\" + String(obj.nodeName).toLowerCase(), attrs = obj.attributes || [], i = 0; i < attrs.length; i++) {\n        s += \" \" + attrs[i].name + \"=\" + wrapQuotes(quote(attrs[i].value), \"double\", opts);\n      }\n\n      return s += \">\", obj.childNodes && obj.childNodes.length && (s += \"...\"), s += \"</\" + String(obj.nodeName).toLowerCase() + \">\";\n    }\n\n    if (isArray$1(obj)) {\n      if (0 === obj.length) return \"[]\";\n      var xs = arrObjKeys(obj, inspect);\n      return indent && !function (xs) {\n        for (var i = 0; i < xs.length; i++) {\n          if (indexOf(xs[i], \"\\n\") >= 0) return !1;\n        }\n\n        return !0;\n      }(xs) ? \"[\" + indentedJoin(xs, indent) + \"]\" : \"[ \" + xs.join(\", \") + \" ]\";\n    }\n\n    if (function (obj) {\n      return !(\"[object Error]\" !== toStr$1(obj) || toStringTag && \"object\" == typeof obj && toStringTag in obj);\n    }(obj)) {\n      var parts = arrObjKeys(obj, inspect);\n      return 0 === parts.length ? \"[\" + String(obj) + \"]\" : \"{ [\" + String(obj) + \"] \" + parts.join(\", \") + \" }\";\n    }\n\n    if (\"object\" == typeof obj && customInspect) {\n      if (inspectSymbol && \"function\" == typeof obj[inspectSymbol]) return obj[inspectSymbol]();\n      if (\"symbol\" !== customInspect && \"function\" == typeof obj.inspect) return obj.inspect();\n    }\n\n    if (function (x) {\n      if (!mapSize || !x || \"object\" != typeof x) return !1;\n\n      try {\n        mapSize.call(x);\n\n        try {\n          setSize.call(x);\n        } catch (s) {\n          return !0;\n        }\n\n        return x instanceof Map;\n      } catch (e) {}\n\n      return !1;\n    }(obj)) {\n      var mapParts = [];\n      return mapForEach.call(obj, function (value, key) {\n        mapParts.push(inspect(key, obj, !0) + \" => \" + inspect(value, obj));\n      }), collectionOf(\"Map\", mapSize.call(obj), mapParts, indent);\n    }\n\n    if (function (x) {\n      if (!setSize || !x || \"object\" != typeof x) return !1;\n\n      try {\n        setSize.call(x);\n\n        try {\n          mapSize.call(x);\n        } catch (m) {\n          return !0;\n        }\n\n        return x instanceof Set;\n      } catch (e) {}\n\n      return !1;\n    }(obj)) {\n      var setParts = [];\n      return setForEach.call(obj, function (value) {\n        setParts.push(inspect(value, obj));\n      }), collectionOf(\"Set\", setSize.call(obj), setParts, indent);\n    }\n\n    if (function (x) {\n      if (!weakMapHas || !x || \"object\" != typeof x) return !1;\n\n      try {\n        weakMapHas.call(x, weakMapHas);\n\n        try {\n          weakSetHas.call(x, weakSetHas);\n        } catch (s) {\n          return !0;\n        }\n\n        return x instanceof WeakMap;\n      } catch (e) {}\n\n      return !1;\n    }(obj)) return weakCollectionOf(\"WeakMap\");\n    if (function (x) {\n      if (!weakSetHas || !x || \"object\" != typeof x) return !1;\n\n      try {\n        weakSetHas.call(x, weakSetHas);\n\n        try {\n          weakMapHas.call(x, weakMapHas);\n        } catch (s) {\n          return !0;\n        }\n\n        return x instanceof WeakSet;\n      } catch (e) {}\n\n      return !1;\n    }(obj)) return weakCollectionOf(\"WeakSet\");\n    if (function (x) {\n      if (!weakRefDeref || !x || \"object\" != typeof x) return !1;\n\n      try {\n        return weakRefDeref.call(x), !0;\n      } catch (e) {}\n\n      return !1;\n    }(obj)) return weakCollectionOf(\"WeakRef\");\n    if (function (obj) {\n      return !(\"[object Number]\" !== toStr$1(obj) || toStringTag && \"object\" == typeof obj && toStringTag in obj);\n    }(obj)) return markBoxed(inspect(Number(obj)));\n    if (function (obj) {\n      if (!obj || \"object\" != typeof obj || !bigIntValueOf) return !1;\n\n      try {\n        return bigIntValueOf.call(obj), !0;\n      } catch (e) {}\n\n      return !1;\n    }(obj)) return markBoxed(inspect(bigIntValueOf.call(obj)));\n    if (function (obj) {\n      return !(\"[object Boolean]\" !== toStr$1(obj) || toStringTag && \"object\" == typeof obj && toStringTag in obj);\n    }(obj)) return markBoxed(booleanValueOf.call(obj));\n    if (function (obj) {\n      return !(\"[object String]\" !== toStr$1(obj) || toStringTag && \"object\" == typeof obj && toStringTag in obj);\n    }(obj)) return markBoxed(inspect(String(obj)));\n\n    if (!function (obj) {\n      return !(\"[object Date]\" !== toStr$1(obj) || toStringTag && \"object\" == typeof obj && toStringTag in obj);\n    }(obj) && !function (obj) {\n      return !(\"[object RegExp]\" !== toStr$1(obj) || toStringTag && \"object\" == typeof obj && toStringTag in obj);\n    }(obj)) {\n      var ys = arrObjKeys(obj, inspect),\n          isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object,\n          protoTag = obj instanceof Object ? \"\" : \"null prototype\",\n          stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr$1(obj).slice(8, -1) : protoTag ? \"Object\" : \"\",\n          tag = (isPlainObject || \"function\" != typeof obj.constructor ? \"\" : obj.constructor.name ? obj.constructor.name + \" \" : \"\") + (stringTag || protoTag ? \"[\" + [].concat(stringTag || [], protoTag || []).join(\": \") + \"] \" : \"\");\n      return 0 === ys.length ? tag + \"{}\" : indent ? tag + \"{\" + indentedJoin(ys, indent) + \"}\" : tag + \"{ \" + ys.join(\", \") + \" }\";\n    }\n\n    return String(obj);\n  };\n\n  function wrapQuotes(s, defaultStyle, opts) {\n    var quoteChar = \"double\" === (opts.quoteStyle || defaultStyle) ? '\"' : \"'\";\n    return quoteChar + s + quoteChar;\n  }\n\n  function quote(s) {\n    return String(s).replace(/\"/g, \"&quot;\");\n  }\n\n  function isArray$1(obj) {\n    return !(\"[object Array]\" !== toStr$1(obj) || toStringTag && \"object\" == typeof obj && toStringTag in obj);\n  }\n\n  function isSymbol(obj) {\n    if (hasShammedSymbols) return obj && \"object\" == typeof obj && obj instanceof Symbol;\n    if (\"symbol\" == typeof obj) return !0;\n    if (!obj || \"object\" != typeof obj || !symToString) return !1;\n\n    try {\n      return symToString.call(obj), !0;\n    } catch (e) {}\n\n    return !1;\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty || function (key) {\n    return key in this;\n  };\n\n  function has(obj, key) {\n    return hasOwn.call(obj, key);\n  }\n\n  function toStr$1(obj) {\n    return objectToString.call(obj);\n  }\n\n  function indexOf(xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n\n    for (var i = 0, l = xs.length; i < l; i++) {\n      if (xs[i] === x) return i;\n    }\n\n    return -1;\n  }\n\n  function lowbyte(c) {\n    var n = c.charCodeAt(0),\n        x = {\n      8: \"b\",\n      9: \"t\",\n      10: \"n\",\n      12: \"f\",\n      13: \"r\"\n    }[n];\n    return x ? \"\\\\\" + x : \"\\\\x\" + (n < 16 ? \"0\" : \"\") + n.toString(16).toUpperCase();\n  }\n\n  function markBoxed(str) {\n    return \"Object(\" + str + \")\";\n  }\n\n  function weakCollectionOf(type) {\n    return type + \" { ? }\";\n  }\n\n  function collectionOf(type, size, entries, indent) {\n    return type + \" (\" + size + \") {\" + (indent ? indentedJoin(entries, indent) : entries.join(\", \")) + \"}\";\n  }\n\n  function indentedJoin(xs, indent) {\n    if (0 === xs.length) return \"\";\n    var lineJoiner = \"\\n\" + indent.prev + indent.base;\n    return lineJoiner + xs.join(\",\" + lineJoiner) + \"\\n\" + indent.prev;\n  }\n\n  function arrObjKeys(obj, inspect) {\n    var isArr = isArray$1(obj),\n        xs = [];\n\n    if (isArr) {\n      xs.length = obj.length;\n\n      for (var i = 0; i < obj.length; i++) {\n        xs[i] = has(obj, i) ? inspect(obj[i], obj) : \"\";\n      }\n    }\n\n    var symMap,\n        syms = \"function\" == typeof gOPS ? gOPS(obj) : [];\n\n    if (hasShammedSymbols) {\n      symMap = {};\n\n      for (var k = 0; k < syms.length; k++) {\n        symMap[\"$\" + syms[k]] = syms[k];\n      }\n    }\n\n    for (var key in obj) {\n      has(obj, key) && (isArr && String(Number(key)) === key && key < obj.length || hasShammedSymbols && symMap[\"$\" + key] instanceof Symbol || (/[^\\w$]/.test(key) ? xs.push(inspect(key, obj) + \": \" + inspect(obj[key], obj)) : xs.push(key + \": \" + inspect(obj[key], obj))));\n    }\n\n    if (\"function\" == typeof gOPS) for (var j = 0; j < syms.length; j++) {\n      isEnumerable.call(obj, syms[j]) && xs.push(\"[\" + inspect(syms[j]) + \"]: \" + inspect(obj[syms[j]], obj));\n    }\n    return xs;\n  }\n\n  var $TypeError$1 = getIntrinsic(\"%TypeError%\"),\n      $WeakMap = getIntrinsic(\"%WeakMap%\", !0),\n      $Map = getIntrinsic(\"%Map%\", !0),\n      $weakMapGet = callBound(\"WeakMap.prototype.get\", !0),\n      $weakMapSet = callBound(\"WeakMap.prototype.set\", !0),\n      $weakMapHas = callBound(\"WeakMap.prototype.has\", !0),\n      $mapGet = callBound(\"Map.prototype.get\", !0),\n      $mapSet = callBound(\"Map.prototype.set\", !0),\n      $mapHas = callBound(\"Map.prototype.has\", !0),\n      listGetNode = function listGetNode(list, key) {\n    for (var curr, prev = list; null !== (curr = prev.next); prev = curr) {\n      if (curr.key === key) return prev.next = curr.next, curr.next = list.next, list.next = curr, curr;\n    }\n  },\n      sideChannel = function sideChannel() {\n    var $wm,\n        $m,\n        $o,\n        channel = {\n      assert: function assert(key) {\n        if (!channel.has(key)) throw new $TypeError$1(\"Side channel does not contain \" + objectInspect(key));\n      },\n      get: function get(key) {\n        if ($WeakMap && key && (\"object\" == typeof key || \"function\" == typeof key)) {\n          if ($wm) return $weakMapGet($wm, key);\n        } else if ($Map) {\n          if ($m) return $mapGet($m, key);\n        } else if ($o) return function (objects, key) {\n          var node = listGetNode(objects, key);\n          return node && node.value;\n        }($o, key);\n      },\n      has: function has(key) {\n        if ($WeakMap && key && (\"object\" == typeof key || \"function\" == typeof key)) {\n          if ($wm) return $weakMapHas($wm, key);\n        } else if ($Map) {\n          if ($m) return $mapHas($m, key);\n        } else if ($o) return function (objects, key) {\n          return !!listGetNode(objects, key);\n        }($o, key);\n\n        return !1;\n      },\n      set: function set(key, value) {\n        $WeakMap && key && (\"object\" == typeof key || \"function\" == typeof key) ? ($wm || ($wm = new $WeakMap()), $weakMapSet($wm, key, value)) : $Map ? ($m || ($m = new $Map()), $mapSet($m, key, value)) : ($o || ($o = {\n          key: {},\n          next: null\n        }), function (objects, key, value) {\n          var node = listGetNode(objects, key);\n          node ? node.value = value : objects.next = {\n            key: key,\n            next: objects.next,\n            value: value\n          };\n        }($o, key, value));\n      }\n    };\n    return channel;\n  },\n      replace = String.prototype.replace,\n      percentTwenties = /%20/g,\n      Format_RFC3986 = \"RFC3986\",\n      formats = {\n    default: Format_RFC3986,\n    formatters: {\n      RFC1738: function RFC1738(value) {\n        return replace.call(value, percentTwenties, \"+\");\n      },\n      RFC3986: function RFC3986(value) {\n        return String(value);\n      }\n    },\n    RFC1738: \"RFC1738\",\n    RFC3986: Format_RFC3986\n  },\n      has$1 = Object.prototype.hasOwnProperty,\n      isArray$2 = Array.isArray,\n      hexTable = function () {\n    for (var array = [], i = 0; i < 256; ++i) {\n      array.push(\"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n  }(),\n      arrayToObject = function arrayToObject(source, options) {\n    for (var obj = options && options.plainObjects ? Object.create(null) : {}, i = 0; i < source.length; ++i) {\n      void 0 !== source[i] && (obj[i] = source[i]);\n    }\n\n    return obj;\n  },\n      utils = {\n    arrayToObject: arrayToObject,\n    assign: function assign(target, source) {\n      return Object.keys(source).reduce(function (acc, key) {\n        return acc[key] = source[key], acc;\n      }, target);\n    },\n    combine: function combine(a, b) {\n      return [].concat(a, b);\n    },\n    compact: function compact(value) {\n      for (var queue = [{\n        obj: {\n          o: value\n        },\n        prop: \"o\"\n      }], refs = [], i = 0; i < queue.length; ++i) {\n        for (var item = queue[i], obj = item.obj[item.prop], keys = Object.keys(obj), j = 0; j < keys.length; ++j) {\n          var key = keys[j],\n              val = obj[key];\n          \"object\" == typeof val && null !== val && -1 === refs.indexOf(val) && (queue.push({\n            obj: obj,\n            prop: key\n          }), refs.push(val));\n        }\n      }\n\n      return function (queue) {\n        for (; queue.length > 1;) {\n          var item = queue.pop(),\n              obj = item.obj[item.prop];\n\n          if (isArray$2(obj)) {\n            for (var compacted = [], j = 0; j < obj.length; ++j) {\n              void 0 !== obj[j] && compacted.push(obj[j]);\n            }\n\n            item.obj[item.prop] = compacted;\n          }\n        }\n      }(queue), value;\n    },\n    decode: function decode(str, decoder, charset) {\n      var strWithoutPlus = str.replace(/\\+/g, \" \");\n      if (\"iso-8859-1\" === charset) return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n\n      try {\n        return decodeURIComponent(strWithoutPlus);\n      } catch (e) {\n        return strWithoutPlus;\n      }\n    },\n    encode: function encode(str, defaultEncoder, charset, kind, format) {\n      if (0 === str.length) return str;\n      var string = str;\n      if (\"symbol\" == typeof str ? string = Symbol.prototype.toString.call(str) : \"string\" != typeof str && (string = String(str)), \"iso-8859-1\" === charset) return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n        return \"%26%23\" + parseInt($0.slice(2), 16) + \"%3B\";\n      });\n\n      for (var out = \"\", i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n        45 === c || 46 === c || 95 === c || 126 === c || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (40 === c || 41 === c) ? out += string.charAt(i) : c < 128 ? out += hexTable[c] : c < 2048 ? out += hexTable[192 | c >> 6] + hexTable[128 | 63 & c] : c < 55296 || c >= 57344 ? out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c] : (i += 1, c = 65536 + ((1023 & c) << 10 | 1023 & string.charCodeAt(i)), out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c]);\n      }\n\n      return out;\n    },\n    isBuffer: function isBuffer(obj) {\n      return !(!obj || \"object\" != typeof obj) && !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n    },\n    isRegExp: function isRegExp(obj) {\n      return \"[object RegExp]\" === Object.prototype.toString.call(obj);\n    },\n    maybeMap: function maybeMap(val, fn) {\n      if (isArray$2(val)) {\n        for (var mapped = [], i = 0; i < val.length; i += 1) {\n          mapped.push(fn(val[i]));\n        }\n\n        return mapped;\n      }\n\n      return fn(val);\n    },\n    merge: function merge(target, source, options) {\n      if (!source) return target;\n\n      if (\"object\" != typeof source) {\n        if (isArray$2(target)) target.push(source);else {\n          if (!target || \"object\" != typeof target) return [target, source];\n          (options && (options.plainObjects || options.allowPrototypes) || !has$1.call(Object.prototype, source)) && (target[source] = !0);\n        }\n        return target;\n      }\n\n      if (!target || \"object\" != typeof target) return [target].concat(source);\n      var mergeTarget = target;\n      return isArray$2(target) && !isArray$2(source) && (mergeTarget = arrayToObject(target, options)), isArray$2(target) && isArray$2(source) ? (source.forEach(function (item, i) {\n        if (has$1.call(target, i)) {\n          var targetItem = target[i];\n          targetItem && \"object\" == typeof targetItem && item && \"object\" == typeof item ? target[i] = merge(targetItem, item, options) : target.push(item);\n        } else target[i] = item;\n      }), target) : Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n        return has$1.call(acc, key) ? acc[key] = merge(acc[key], value, options) : acc[key] = value, acc;\n      }, mergeTarget);\n    }\n  },\n      has$2 = Object.prototype.hasOwnProperty,\n      arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n      return prefix + \"[]\";\n    },\n    comma: \"comma\",\n    indices: function indices(prefix, key) {\n      return prefix + \"[\" + key + \"]\";\n    },\n    repeat: function repeat(prefix) {\n      return prefix;\n    }\n  },\n      isArray$3 = Array.isArray,\n      push = Array.prototype.push,\n      pushToArray = function pushToArray(arr, valueOrArray) {\n    push.apply(arr, isArray$3(valueOrArray) ? valueOrArray : [valueOrArray]);\n  },\n      toISO = Date.prototype.toISOString,\n      defaultFormat = formats.default,\n      defaults = {\n    addQueryPrefix: !1,\n    allowDots: !1,\n    charset: \"utf-8\",\n    charsetSentinel: !1,\n    delimiter: \"&\",\n    encode: !0,\n    encoder: utils.encode,\n    encodeValuesOnly: !1,\n    format: defaultFormat,\n    formatter: formats.formatters[defaultFormat],\n    indices: !1,\n    serializeDate: function serializeDate(date) {\n      return toISO.call(date);\n    },\n    skipNulls: !1,\n    strictNullHandling: !1\n  },\n      stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel$1) {\n    var v,\n        obj = object;\n    if (sideChannel$1.has(object)) throw new RangeError(\"Cyclic object value\");\n\n    if (\"function\" == typeof filter ? obj = filter(prefix, obj) : obj instanceof Date ? obj = serializeDate(obj) : \"comma\" === generateArrayPrefix && isArray$3(obj) && (obj = utils.maybeMap(obj, function (value) {\n      return value instanceof Date ? serializeDate(value) : value;\n    })), null === obj) {\n      if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, \"key\", format) : prefix;\n      obj = \"\";\n    }\n\n    if (\"string\" == typeof (v = obj) || \"number\" == typeof v || \"boolean\" == typeof v || \"symbol\" == typeof v || \"bigint\" == typeof v || utils.isBuffer(obj)) return encoder ? [formatter(encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, \"key\", format)) + \"=\" + formatter(encoder(obj, defaults.encoder, charset, \"value\", format))] : [formatter(prefix) + \"=\" + formatter(String(obj))];\n    var objKeys,\n        values = [];\n    if (void 0 === obj) return values;\n    if (\"comma\" === generateArrayPrefix && isArray$3(obj)) objKeys = [{\n      value: obj.length > 0 ? obj.join(\",\") || null : void 0\n    }];else if (isArray$3(filter)) objKeys = filter;else {\n      var keys = Object.keys(obj);\n      objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n      var key = objKeys[i],\n          value = \"object\" == typeof key && void 0 !== key.value ? key.value : obj[key];\n\n      if (!skipNulls || null !== value) {\n        var keyPrefix = isArray$3(obj) ? \"function\" == typeof generateArrayPrefix ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? \".\" + key : \"[\" + key + \"]\");\n        sideChannel$1.set(object, !0);\n        var valueSideChannel = sideChannel();\n        pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));\n      }\n    }\n\n    return values;\n  },\n      lib_stringify = (Object.prototype.hasOwnProperty, Array.isArray, function (object, opts) {\n    var objKeys,\n        obj = object,\n        options = function (opts) {\n      if (!opts) return defaults;\n      if (null !== opts.encoder && void 0 !== opts.encoder && \"function\" != typeof opts.encoder) throw new TypeError(\"Encoder has to be a function.\");\n      var charset = opts.charset || defaults.charset;\n      if (void 0 !== opts.charset && \"utf-8\" !== opts.charset && \"iso-8859-1\" !== opts.charset) throw new TypeError(\"The charset option must be either utf-8, iso-8859-1, or undefined\");\n      var format = formats.default;\n\n      if (void 0 !== opts.format) {\n        if (!has$2.call(formats.formatters, opts.format)) throw new TypeError(\"Unknown format option provided.\");\n        format = opts.format;\n      }\n\n      var formatter = formats.formatters[format],\n          filter = defaults.filter;\n      return (\"function\" == typeof opts.filter || isArray$3(opts.filter)) && (filter = opts.filter), {\n        addQueryPrefix: \"boolean\" == typeof opts.addQueryPrefix ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: void 0 === opts.allowDots ? defaults.allowDots : !!opts.allowDots,\n        charset: charset,\n        charsetSentinel: \"boolean\" == typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel,\n        delimiter: void 0 === opts.delimiter ? defaults.delimiter : opts.delimiter,\n        encode: \"boolean\" == typeof opts.encode ? opts.encode : defaults.encode,\n        encoder: \"function\" == typeof opts.encoder ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: \"boolean\" == typeof opts.encodeValuesOnly ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: \"function\" == typeof opts.serializeDate ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: \"boolean\" == typeof opts.skipNulls ? opts.skipNulls : defaults.skipNulls,\n        sort: \"function\" == typeof opts.sort ? opts.sort : null,\n        strictNullHandling: \"boolean\" == typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling\n      };\n    }(opts);\n\n    \"function\" == typeof options.filter ? obj = (0, options.filter)(\"\", obj) : isArray$3(options.filter) && (objKeys = options.filter);\n    var arrayFormat,\n        keys = [];\n    if (\"object\" != typeof obj || null === obj) return \"\";\n    arrayFormat = opts && opts.arrayFormat in arrayPrefixGenerators ? opts.arrayFormat : opts && \"indices\" in opts ? opts.indices ? \"indices\" : \"repeat\" : \"indices\";\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n    objKeys || (objKeys = Object.keys(obj)), options.sort && objKeys.sort(options.sort);\n\n    for (var sideChannel$1 = sideChannel(), i = 0; i < objKeys.length; ++i) {\n      var key = objKeys[i];\n      options.skipNulls && null === obj[key] || pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel$1));\n    }\n\n    var joined = keys.join(options.delimiter),\n        prefix = !0 === options.addQueryPrefix ? \"?\" : \"\";\n    return options.charsetSentinel && (\"iso-8859-1\" === options.charset ? prefix += \"utf8=%26%2310003%3B&\" : prefix += \"utf8=%E2%9C%93&\"), joined.length > 0 ? prefix + joined : \"\";\n  });\n\n  function PopupHandler(webAuth) {\n    this.webAuth = webAuth, this._current_popup = null, this.options = null;\n  }\n\n  function PluginHandler(webAuth) {\n    this.webAuth = webAuth;\n  }\n\n  function CordovaPlugin() {\n    this.webAuth = null, this.version = version_raw, this.extensibilityPoints = [\"popup.authorize\", \"popup.getPopupHandler\"];\n  }\n\n  return PopupHandler.prototype.preload = function (options) {\n    var _this = this,\n        _window = windowHandler.getWindow(),\n        url = options.url || \"about:blank\",\n        popupOptions = options.popupOptions || {};\n\n    popupOptions.location = \"yes\", delete popupOptions.width, delete popupOptions.height;\n    var windowFeatures = lib_stringify(popupOptions, {\n      encode: !1,\n      delimiter: \",\"\n    });\n    return this._current_popup && !this._current_popup.closed || (this._current_popup = _window.open(url, \"_blank\", windowFeatures), this._current_popup.kill = function (success) {\n      _this._current_popup.success = success, this.close(), _this._current_popup = null;\n    }), this._current_popup;\n  }, PopupHandler.prototype.load = function (url, _, options, cb) {\n    var _this = this;\n\n    this.url = url, this.options = options, this._current_popup ? this._current_popup.location.href = url : (options.url = url, this.preload(options)), this.transientErrorHandler = function (event) {\n      _this.errorHandler(event, cb);\n    }, this.transientStartHandler = function (event) {\n      _this.startHandler(event, cb);\n    }, this.transientExitHandler = function () {\n      _this.exitHandler(cb);\n    }, this._current_popup.addEventListener(\"loaderror\", this.transientErrorHandler), this._current_popup.addEventListener(\"loadstart\", this.transientStartHandler), this._current_popup.addEventListener(\"exit\", this.transientExitHandler);\n  }, PopupHandler.prototype.errorHandler = function (event, cb) {\n    this._current_popup && (this._current_popup.kill(!0), cb({\n      error: \"window_error\",\n      errorDescription: event.message\n    }));\n  }, PopupHandler.prototype.unhook = function () {\n    this._current_popup.removeEventListener(\"loaderror\", this.transientErrorHandler), this._current_popup.removeEventListener(\"loadstart\", this.transientStartHandler), this._current_popup.removeEventListener(\"exit\", this.transientExitHandler);\n  }, PopupHandler.prototype.exitHandler = function (cb) {\n    this._current_popup && (this.unhook(), this._current_popup.success || cb({\n      error: \"window_closed\",\n      errorDescription: \"Browser window closed\"\n    }));\n  }, PopupHandler.prototype.startHandler = function (event, cb) {\n    var _this = this;\n\n    if (this._current_popup) {\n      var callbackUrl = urlJoin(\"https:\", this.webAuth.baseOptions.domain, \"/mobile\");\n\n      if (!event.url || 0 === event.url.indexOf(callbackUrl + \"#\")) {\n        var parts = event.url.split(\"#\");\n\n        if (1 !== parts.length) {\n          var opts = {\n            hash: parts.pop()\n          };\n          this.options.nonce && (opts.nonce = this.options.nonce), this.webAuth.parseHash(opts, function (error, result) {\n            (error || result) && (_this._current_popup.kill(!0), cb(error, result));\n          });\n        }\n      }\n    }\n  }, PluginHandler.prototype.processParams = function (params) {\n    return params.redirectUri = urlJoin(\"https://\" + params.domain, \"mobile\"), delete params.owp, params;\n  }, PluginHandler.prototype.getPopupHandler = function () {\n    return new PopupHandler(this.webAuth);\n  }, CordovaPlugin.prototype.setWebAuth = function (webAuth) {\n    this.webAuth = webAuth;\n  }, CordovaPlugin.prototype.supports = function (extensibilityPoint) {\n    var _window = windowHandler.getWindow();\n\n    return (!!_window.cordova || !!_window.electron) && this.extensibilityPoints.indexOf(extensibilityPoint) > -1;\n  }, CordovaPlugin.prototype.init = function () {\n    return new PluginHandler(this.webAuth);\n  }, CordovaPlugin;\n});","map":null,"metadata":{},"sourceType":"script"}