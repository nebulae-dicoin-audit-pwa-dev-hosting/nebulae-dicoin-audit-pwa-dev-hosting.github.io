{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst async_1 = __importDefault(require(\"async\"));\n\nconst utils = __importStar(require(\"./utils\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst selector_1 = require(\"./selector\"); // Do nothing callback for success\n\n\nfunction doNothing() {} // WebSQLDb adapter for minimongo DB\n// Supports sqlite plugin, if available and specified in option as {storage: 'sqlite'}\n\n\nclass WebSQLDb {\n  constructor(options, success, error) {\n    this.collections = {};\n\n    if (options.storage === \"sqlite\" && window[\"sqlitePlugin\"]) {\n      // sqlite plugin does not support db.version\n      // and since db operations can only be executed once the db is properly open\n      // we add the schema version migration to the success callback\n      window[\"sqlitePlugin\"].openDatabase({\n        name: \"minimongo_\" + options.namespace,\n        location: \"default\"\n      }, sqliteDb => {\n        console.log(\"Database open successful\");\n        this.db = sqliteDb;\n        console.log(\"Checking version\");\n        this.db.executeSql(\"PRAGMA user_version\", [], rs => {\n          const version = rs.rows.item(0).user_version;\n\n          if (version === 0) {\n            this.db.transaction(tx => {\n              tx.executeSql(`\\\nCREATE TABLE docs (\ncol TEXT NOT NULL,\nid TEXT NOT NULL,\nstate TEXT NOT NULL,\ndoc TEXT,\nbase TEXT,\nPRIMARY KEY (col, id));`, [], doNothing, (tx, err) => error(err));\n              tx.executeSql(\"PRAGMA user_version = 2\", [], doNothing, (tx, err) => error(err));\n              return success(this);\n            });\n          } else {\n            success(this);\n          }\n        }, function (err) {\n          console.log(\"version check error :: \", JSON.stringify(err));\n          error(err);\n        });\n      }, function (err) {\n        console.log(\"Error opening databse :: \", JSON.stringify(err));\n        error(err);\n      });\n    } else {\n      try {\n        // Create database\n        // TODO escape name\n        this.db = window[\"openDatabase\"](\"minimongo_\" + options.namespace, \"\", \"Minimongo:\" + options.namespace, 5 * 1024 * 1024);\n\n        if (!this.db) {\n          return error(new Error(\"Failed to create database\"));\n        }\n      } catch (ex) {\n        if (error) {\n          error(ex);\n        }\n\n        return;\n      }\n    }\n\n    const migrateToV1 = tx => tx.executeSql(`\\\nCREATE TABLE docs (\ncol TEXT NOT NULL,\nid TEXT NOT NULL,\nstate TEXT NOT NULL,\ndoc TEXT,\nPRIMARY KEY (col, id));`, [], doNothing, (tx, err) => error(err));\n\n    const migrateToV2 = tx => tx.executeSql(`\\\nALTER TABLE docs ADD COLUMN base TEXT;`, [], doNothing, (tx, err) => error(err)); // Check if at v2 version\n\n\n    const checkV2 = () => {\n      if (this.db.version === \"1.0\") {\n        return this.db.changeVersion(\"1.0\", \"2.0\", migrateToV2, error, () => {\n          if (success) {\n            return success(this);\n          }\n        });\n      } else if (this.db.version !== \"2.0\") {\n        return error(\"Unknown db version \" + this.db.version);\n      } else {\n        if (success) {\n          return success(this);\n        }\n      }\n    };\n\n    if (!options.storage) {\n      if (!this.db.version) {\n        this.db.changeVersion(\"\", \"1.0\", migrateToV1, error, checkV2);\n      } else {\n        checkV2();\n      }\n    }\n\n    return this.db;\n  }\n\n  addCollection(name, success, error) {\n    const collection = new Collection(name, this.db);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success) {\n      return success();\n    }\n  }\n\n  removeCollection(name, success, error) {\n    delete this[name];\n    delete this.collections[name]; // Remove all documents of collection\n\n    return this.db.transaction(tx => tx.executeSql(\"DELETE FROM docs WHERE col = ?\", [name], success, (tx, err) => error(err)), error);\n  }\n\n  getCollectionNames() {\n    return lodash_1.default.keys(this.collections);\n  }\n\n}\n\nexports.default = WebSQLDb; // Stores data in indexeddb store\n\nclass Collection {\n  constructor(name, db) {\n    this.name = name;\n    this.db = db;\n  }\n\n  find(selector, options) {\n    return {\n      fetch: (success, error) => {\n        return this._findFetch(selector, options, success, error);\n      }\n    };\n  }\n\n  findOne(selector, options, success, error) {\n    if (lodash_1.default.isFunction(options)) {\n      ;\n      [options, success, error] = [{}, options, success];\n    }\n\n    return this.find(selector, options).fetch(function (results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  }\n\n  _findFetch(selector, options, success, error) {\n    // Android 2.x requires error callback\n    error = error || function () {}; // Get all docs from collection\n\n\n    return this.db.readTransaction(tx => {\n      return tx.executeSql(\"SELECT * FROM docs WHERE col = ?\", [this.name], function (tx, results) {\n        const docs = [];\n\n        for (let i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          const row = results.rows.item(i);\n\n          if (row.state !== \"removed\") {\n            docs.push(JSON.parse(row.doc));\n          }\n        }\n\n        if (success != null) {\n          return success((0, utils_1.processFind)(docs, selector, options));\n        }\n      }, (tx, err) => error(err));\n    }, error);\n  }\n\n  upsert(docs, bases, success, error) {\n    let items;\n    [items, success, error] = utils.regularizeUpsert(docs, bases, success, error); // Android 2.x requires error callback\n\n    error = error || function () {};\n\n    return this.db.transaction(tx => {\n      const ids = lodash_1.default.map(items, item => item.doc._id); // Get bases\n\n      bases = {};\n      return async_1.default.eachSeries(ids, (id, callback) => {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, id], function (tx2, results) {\n          tx = tx2;\n\n          if (results.rows.length > 0) {\n            const row = results.rows.item(0);\n\n            if (row.state === \"upserted\") {\n              bases[row.id] = row.base ? JSON.parse(row.base) : null;\n            } else if (row.state === \"cached\") {\n              bases[row.id] = JSON.parse(row.doc);\n            }\n          }\n\n          return callback();\n        }, (tx, err) => error(err));\n      }, () => {\n        return (() => {\n          const result = [];\n\n          for (let item of items) {\n            var base;\n            const id = item.doc._id; // Prefer explicit base\n\n            if (item.base !== undefined) {\n              ;\n              ({\n                base\n              } = item);\n            } else if (bases[id]) {\n              base = bases[id];\n            } else {\n              base = null;\n            }\n\n            result.push(tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc, base) VALUES (?, ?, ?, ?, ?)\", [this.name, item.doc._id, \"upserted\", JSON.stringify(item.doc), JSON.stringify(base)], doNothing, (tx, err) => error(err)));\n          }\n\n          return result;\n        })();\n      });\n    }, error, function () {\n      if (success) {\n        return success(docs);\n      }\n    });\n  }\n\n  remove(id, success, error) {\n    // Special case for filter-type remove\n    if (lodash_1.default.isObject(id)) {\n      this.find(id).fetch(rows => {\n        return async_1.default.each(rows, (row, cb) => {\n          return this.remove(row._id, () => cb(), cb);\n        }, () => success());\n      }, error);\n      return;\n    } // Android 2.x requires error callback\n\n\n    error = error || function () {}; // Find record\n\n\n    return this.db.transaction(tx => {\n      return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, id], (tx, results) => {\n        if (results.rows.length > 0) {\n          // Change to removed\n          return tx.executeSql('UPDATE docs SET state=\"removed\" WHERE col = ? AND id = ?', [this.name, id], function () {\n            if (success) {\n              return success(id);\n            }\n          }, (tx, err) => error(err));\n        } else {\n          return tx.executeSql(\"INSERT INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [this.name, id, \"removed\", JSON.stringify({\n            _id: id\n          })], function () {\n            if (success) {\n              return success(id);\n            }\n          }, (tx, err) => error(err));\n        }\n      }, (tx, err) => error(err));\n    }, error);\n  }\n\n  cache(docs, selector, options, success, error) {\n    // Android 2.x requires error callback\n    error = error || function () {};\n\n    return this.db.transaction(tx => {\n      // Add all non-local that are not upserted or removed\n      return async_1.default.eachSeries(docs, (doc, callback) => {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, doc._id], (tx, results) => {\n          // Check if present and not upserted/deleted\n          if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n            const existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null; // Exclude any excluded _ids from being cached/uncached\n\n            if (options && options.exclude && options.exclude.includes(doc._id)) {\n              callback();\n              return;\n            } // If _rev present, make sure that not overwritten by lower or equal _rev\n\n\n            if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n              // Upsert\n              return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [this.name, doc._id, \"cached\", JSON.stringify(doc)], () => callback(), (tx, err) => error(err));\n            } else {\n              return callback();\n            }\n          } else {\n            return callback();\n          }\n        }, (tx, err) => error(err));\n      }, err => {\n        let sort;\n\n        if (err) {\n          if (error) {\n            error(err);\n          }\n\n          return;\n        } // Rows have been cached, now look for stale ones to remove\n\n\n        const docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n\n        if (options.sort) {\n          sort = (0, selector_1.compileSort)(options.sort);\n        } // Perform query, removing rows missing in docs from local db\n\n\n        return this.find(selector, options).fetch(results => {\n          return this.db.transaction(tx => {\n            return async_1.default.eachSeries(results, (result, callback) => {\n              // If not present in docs and is present locally and not upserted/deleted\n              return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, result._id], (tx, rows) => {\n                if (!docsMap[result._id] && rows.rows.length > 0 && rows.rows.item(0).state === \"cached\") {\n                  // Exclude any excluded _ids from being cached/uncached\n                  if (options && options.exclude && options.exclude.includes(result._id)) {\n                    callback();\n                    return;\n                  } // If at limit\n\n\n                  if (options.limit && docs.length === options.limit) {\n                    // If past end on sorted limited, ignore\n                    if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n                      return callback();\n                    } // If no sort, ignore\n\n\n                    if (!options.sort) {\n                      return callback();\n                    }\n                  } // Item is gone from server, remove locally\n\n\n                  return tx.executeSql(\"DELETE FROM docs WHERE col = ? AND id = ?\", [this.name, result._id], () => callback(), (tx, err) => error(err));\n                } else {\n                  return callback();\n                }\n              }, (tx, err) => error(err));\n            }, function (err) {\n              if (err != null) {\n                if (error != null) {\n                  error(err);\n                }\n\n                return;\n              }\n\n              if (success != null) {\n                return success();\n              }\n            });\n          }, error);\n        }, error);\n      });\n    }, error);\n  }\n\n  pendingUpserts(success, error) {\n    // Android 2.x requires error callback\n    error = error || function () {};\n\n    return this.db.readTransaction(tx => {\n      return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [this.name, \"upserted\"], function (tx, results) {\n        const docs = [];\n\n        for (let i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          const row = results.rows.item(i);\n          docs.push({\n            doc: JSON.parse(row.doc),\n            base: row.base ? JSON.parse(row.base) : null\n          });\n        }\n\n        if (success != null) {\n          return success(docs);\n        }\n      }, (tx, err) => error(err));\n    }, error);\n  }\n\n  pendingRemoves(success, error) {\n    // Android 2.x requires error callback\n    error = error || function () {};\n\n    return this.db.readTransaction(tx => {\n      return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [this.name, \"removed\"], function (tx, results) {\n        const docs = [];\n\n        for (let i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          const row = results.rows.item(i);\n          docs.push(JSON.parse(row.doc)._id);\n        }\n\n        if (success != null) {\n          return success(docs);\n        }\n      }, (tx, err) => error(err));\n    }, error);\n  }\n\n  resolveUpserts(upserts, success, error) {\n    // Android 2.x requires error callback\n    error = error || function () {}; // Find records\n\n\n    return this.db.transaction(tx => {\n      return async_1.default.eachSeries(upserts, (upsert, cb) => {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, upsert.doc._id], (tx, results) => {\n          if (results.rows.length > 0 && results.rows.item(0).state === \"upserted\") {\n            // Only safely remove upsert if doc is the same\n            if (lodash_1.default.isEqual(JSON.parse(results.rows.item(0).doc), upsert.doc)) {\n              tx.executeSql('UPDATE docs SET state=\"cached\" WHERE col = ? AND id = ?', [this.name, upsert.doc._id], doNothing, (tx, err) => error(err));\n              return cb();\n            } else {\n              tx.executeSql(\"UPDATE docs SET base=? WHERE col = ? AND id = ?\", [JSON.stringify(upsert.doc), this.name, upsert.doc._id], doNothing, (tx, err) => error(err));\n              return cb();\n            }\n          } else {\n            // Upsert removed, which is fine\n            return cb();\n          }\n        }, (tx, err) => error(err));\n      }, function (err) {\n        if (err) {\n          return error(err);\n        } // Success\n\n\n        if (success) {\n          return success();\n        }\n      });\n    }, error);\n  }\n\n  resolveRemove(id, success, error) {\n    // Android 2.x requires error callback\n    error = error || function () {}; // Find record\n\n\n    return this.db.transaction(tx => {\n      // Only safely remove if removed state\n      return tx.executeSql('DELETE FROM docs WHERE state=\"removed\" AND col = ? AND id = ?', [this.name, id], function () {\n        if (success) {\n          return success(id);\n        }\n      }, (tx, err) => error(err));\n    }, error);\n  } // Add but do not overwrite or record as upsert\n\n\n  seed(docs, success, error) {\n    if (!lodash_1.default.isArray(docs)) {\n      docs = [docs];\n    } // Android 2.x requires error callback\n\n\n    error = error || function () {};\n\n    return this.db.transaction(tx => {\n      // Add all non-local that are not upserted or removed\n      return async_1.default.eachSeries(docs, (doc, callback) => {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, doc._id], (tx, results) => {\n          // Check if present\n          if (results.rows.length === 0) {\n            // Upsert\n            return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [this.name, doc._id, \"cached\", JSON.stringify(doc)], () => callback(), (tx, err) => error(err));\n          } else {\n            return callback();\n          }\n        }, (tx, err) => error(err));\n      }, err => {\n        if (err) {\n          if (error) {\n            return error(err);\n          }\n        } else {\n          if (success) {\n            return success();\n          }\n        }\n      });\n    }, error);\n  } // Add but do not overwrite upsert/removed and do not record as upsert\n\n\n  cacheOne(doc, success, error) {\n    return this.cacheList([doc], success, error);\n  }\n\n  cacheList(docs, success, error) {\n    // Android 2.x requires error callback\n    error = error || function () {};\n\n    return this.db.transaction(tx => {\n      // Add all non-local that are not upserted or removed\n      return async_1.default.eachSeries(docs, (doc, callback) => {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, doc._id], (tx, results) => {\n          // Only insert if not present or cached\n          if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n            const existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null; // If _rev present, make sure that not overwritten by lower or equal _rev\n\n            if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n              return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [this.name, doc._id, \"cached\", JSON.stringify(doc)], () => callback(), (tx, err) => callback(err));\n            } else {\n              return callback();\n            }\n          } else {\n            return callback();\n          }\n        }, (tx, err) => callback(err));\n      }, err => {\n        if (err) {\n          if (error) {\n            return error(err);\n          }\n        } else {\n          if (success) {\n            return success(docs);\n          }\n        }\n      });\n    }, error);\n  }\n\n  uncache(selector, success, error) {\n    const compiledSelector = utils.compileDocumentSelector(selector); // Android 2.x requires error callback\n\n    error = error || function () {};\n\n    return this.db.transaction(tx => {\n      return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [this.name, \"cached\"], (tx, results) => {\n        // Determine which to remove\n        const toRemove = [];\n\n        for (let i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          const row = results.rows.item(i);\n          const doc = JSON.parse(row.doc);\n\n          if (compiledSelector(doc)) {\n            toRemove.push(doc._id);\n          }\n        } // Add all non-local that are not upserted or removed\n\n\n        return async_1.default.eachSeries(toRemove, (id, callback) => {\n          // Only safely remove if removed state\n          return tx.executeSql('DELETE FROM docs WHERE state=\"cached\" AND col = ? AND id = ?', [this.name, id], () => callback(), (tx, err) => error(err));\n        }, err => {\n          if (err) {\n            if (error) {\n              return error(err);\n            }\n          } else {\n            if (success) {\n              return success();\n            }\n          }\n        });\n      }, (tx, err) => error(err));\n    }, error);\n  }\n\n  uncacheList(ids, success, error) {\n    // Android 2.x requires error callback\n    error = error || function () {};\n\n    return this.db.transaction(tx => {\n      // Add all non-local that are not upserted or removed\n      return async_1.default.eachSeries(ids, (id, callback) => {\n        // Only safely remove if removed state\n        return tx.executeSql('DELETE FROM docs WHERE state=\"cached\" AND col = ? AND id = ?', [this.name, id], () => callback(), (tx, err) => error(err));\n      }, err => {\n        if (err) {\n          if (error) {\n            return error(err);\n          }\n        } else {\n          if (success) {\n            return success();\n          }\n        }\n      });\n    }, error);\n  }\n\n}","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/minimongo/lib/WebSQLDb.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__importDefault","exports","lodash_1","require","async_1","utils","utils_1","selector_1","doNothing","WebSQLDb","constructor","options","success","error","collections","storage","window","openDatabase","name","namespace","location","sqliteDb","console","log","db","executeSql","rs","version","rows","item","user_version","transaction","tx","err","JSON","stringify","Error","ex","migrateToV1","migrateToV2","checkV2","changeVersion","addCollection","collection","Collection","removeCollection","getCollectionNames","default","keys","find","selector","fetch","_findFetch","findOne","isFunction","results","length","readTransaction","docs","i","end","asc","row","state","push","parse","doc","processFind","upsert","bases","items","regularizeUpsert","ids","map","_id","eachSeries","id","callback","tx2","base","remove","isObject","each","cb","cache","existing","exclude","includes","_rev","sort","docsMap","fromPairs","zip","compileSort","limit","last","pendingUpserts","pendingRemoves","resolveUpserts","upserts","isEqual","resolveRemove","seed","isArray","cacheOne","cacheList","uncache","compiledSelector","compileDocumentSelector","toRemove","uncacheList"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst async_1 = __importDefault(require(\"async\"));\nconst utils = __importStar(require(\"./utils\"));\nconst utils_1 = require(\"./utils\");\nconst selector_1 = require(\"./selector\");\n// Do nothing callback for success\nfunction doNothing() { }\n// WebSQLDb adapter for minimongo DB\n// Supports sqlite plugin, if available and specified in option as {storage: 'sqlite'}\nclass WebSQLDb {\n    constructor(options, success, error) {\n        this.collections = {};\n        if (options.storage === \"sqlite\" && window[\"sqlitePlugin\"]) {\n            // sqlite plugin does not support db.version\n            // and since db operations can only be executed once the db is properly open\n            // we add the schema version migration to the success callback\n            window[\"sqlitePlugin\"].openDatabase({ name: \"minimongo_\" + options.namespace, location: \"default\" }, (sqliteDb) => {\n                console.log(\"Database open successful\");\n                this.db = sqliteDb;\n                console.log(\"Checking version\");\n                this.db.executeSql(\"PRAGMA user_version\", [], (rs) => {\n                    const version = rs.rows.item(0).user_version;\n                    if (version === 0) {\n                        this.db.transaction((tx) => {\n                            tx.executeSql(`\\\nCREATE TABLE docs (\ncol TEXT NOT NULL,\nid TEXT NOT NULL,\nstate TEXT NOT NULL,\ndoc TEXT,\nbase TEXT,\nPRIMARY KEY (col, id));`, [], doNothing, (tx, err) => error(err));\n                            tx.executeSql(\"PRAGMA user_version = 2\", [], doNothing, (tx, err) => error(err));\n                            return success(this);\n                        });\n                    }\n                    else {\n                        success(this);\n                    }\n                }, function (err) {\n                    console.log(\"version check error :: \", JSON.stringify(err));\n                    error(err);\n                });\n            }, function (err) {\n                console.log(\"Error opening databse :: \", JSON.stringify(err));\n                error(err);\n            });\n        }\n        else {\n            try {\n                // Create database\n                // TODO escape name\n                this.db = window[\"openDatabase\"](\"minimongo_\" + options.namespace, \"\", \"Minimongo:\" + options.namespace, 5 * 1024 * 1024);\n                if (!this.db) {\n                    return error(new Error(\"Failed to create database\"));\n                }\n            }\n            catch (ex) {\n                if (error) {\n                    error(ex);\n                }\n                return;\n            }\n        }\n        const migrateToV1 = (tx) => tx.executeSql(`\\\nCREATE TABLE docs (\ncol TEXT NOT NULL,\nid TEXT NOT NULL,\nstate TEXT NOT NULL,\ndoc TEXT,\nPRIMARY KEY (col, id));`, [], doNothing, (tx, err) => error(err));\n        const migrateToV2 = (tx) => tx.executeSql(`\\\nALTER TABLE docs ADD COLUMN base TEXT;`, [], doNothing, (tx, err) => error(err));\n        // Check if at v2 version\n        const checkV2 = () => {\n            if (this.db.version === \"1.0\") {\n                return this.db.changeVersion(\"1.0\", \"2.0\", migrateToV2, error, () => {\n                    if (success) {\n                        return success(this);\n                    }\n                });\n            }\n            else if (this.db.version !== \"2.0\") {\n                return error(\"Unknown db version \" + this.db.version);\n            }\n            else {\n                if (success) {\n                    return success(this);\n                }\n            }\n        };\n        if (!options.storage) {\n            if (!this.db.version) {\n                this.db.changeVersion(\"\", \"1.0\", migrateToV1, error, checkV2);\n            }\n            else {\n                checkV2();\n            }\n        }\n        return this.db;\n    }\n    addCollection(name, success, error) {\n        const collection = new Collection(name, this.db);\n        this[name] = collection;\n        this.collections[name] = collection;\n        if (success) {\n            return success();\n        }\n    }\n    removeCollection(name, success, error) {\n        delete this[name];\n        delete this.collections[name];\n        // Remove all documents of collection\n        return this.db.transaction((tx) => tx.executeSql(\"DELETE FROM docs WHERE col = ?\", [name], success, (tx, err) => error(err)), error);\n    }\n    getCollectionNames() {\n        return lodash_1.default.keys(this.collections);\n    }\n}\nexports.default = WebSQLDb;\n// Stores data in indexeddb store\nclass Collection {\n    constructor(name, db) {\n        this.name = name;\n        this.db = db;\n    }\n    find(selector, options) {\n        return {\n            fetch: (success, error) => {\n                return this._findFetch(selector, options, success, error);\n            }\n        };\n    }\n    findOne(selector, options, success, error) {\n        if (lodash_1.default.isFunction(options)) {\n            ;\n            [options, success, error] = [{}, options, success];\n        }\n        return this.find(selector, options).fetch(function (results) {\n            if (success != null) {\n                return success(results.length > 0 ? results[0] : null);\n            }\n        }, error);\n    }\n    _findFetch(selector, options, success, error) {\n        // Android 2.x requires error callback\n        error = error || function () { };\n        // Get all docs from collection\n        return this.db.readTransaction((tx) => {\n            return tx.executeSql(\"SELECT * FROM docs WHERE col = ?\", [this.name], function (tx, results) {\n                const docs = [];\n                for (let i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                    const row = results.rows.item(i);\n                    if (row.state !== \"removed\") {\n                        docs.push(JSON.parse(row.doc));\n                    }\n                }\n                if (success != null) {\n                    return success((0, utils_1.processFind)(docs, selector, options));\n                }\n            }, (tx, err) => error(err));\n        }, error);\n    }\n    upsert(docs, bases, success, error) {\n        let items;\n        [items, success, error] = utils.regularizeUpsert(docs, bases, success, error);\n        // Android 2.x requires error callback\n        error = error || function () { };\n        return this.db.transaction((tx) => {\n            const ids = lodash_1.default.map(items, (item) => item.doc._id);\n            // Get bases\n            bases = {};\n            return async_1.default.eachSeries(ids, ((id, callback) => {\n                return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, id], function (tx2, results) {\n                    tx = tx2;\n                    if (results.rows.length > 0) {\n                        const row = results.rows.item(0);\n                        if (row.state === \"upserted\") {\n                            bases[row.id] = row.base ? JSON.parse(row.base) : null;\n                        }\n                        else if (row.state === \"cached\") {\n                            bases[row.id] = JSON.parse(row.doc);\n                        }\n                    }\n                    return callback();\n                }, (tx, err) => error(err));\n            }), () => {\n                return (() => {\n                    const result = [];\n                    for (let item of items) {\n                        var base;\n                        const id = item.doc._id;\n                        // Prefer explicit base\n                        if (item.base !== undefined) {\n                            ;\n                            ({ base } = item);\n                        }\n                        else if (bases[id]) {\n                            base = bases[id];\n                        }\n                        else {\n                            base = null;\n                        }\n                        result.push(tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc, base) VALUES (?, ?, ?, ?, ?)\", [this.name, item.doc._id, \"upserted\", JSON.stringify(item.doc), JSON.stringify(base)], doNothing, (tx, err) => error(err)));\n                    }\n                    return result;\n                })();\n            });\n        }, error, function () {\n            if (success) {\n                return success(docs);\n            }\n        });\n    }\n    remove(id, success, error) {\n        // Special case for filter-type remove\n        if (lodash_1.default.isObject(id)) {\n            this.find(id).fetch((rows) => {\n                return async_1.default.each(rows, ((row, cb) => {\n                    return this.remove(row._id, () => cb(), cb);\n                }), () => success());\n            }, error);\n            return;\n        }\n        // Android 2.x requires error callback\n        error = error || function () { };\n        // Find record\n        return this.db.transaction((tx) => {\n            return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, id], (tx, results) => {\n                if (results.rows.length > 0) {\n                    // Change to removed\n                    return tx.executeSql('UPDATE docs SET state=\"removed\" WHERE col = ? AND id = ?', [this.name, id], function () {\n                        if (success) {\n                            return success(id);\n                        }\n                    }, (tx, err) => error(err));\n                }\n                else {\n                    return tx.executeSql(\"INSERT INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [this.name, id, \"removed\", JSON.stringify({ _id: id })], function () {\n                        if (success) {\n                            return success(id);\n                        }\n                    }, (tx, err) => error(err));\n                }\n            }, (tx, err) => error(err));\n        }, error);\n    }\n    cache(docs, selector, options, success, error) {\n        // Android 2.x requires error callback\n        error = error || function () { };\n        return this.db.transaction((tx) => {\n            // Add all non-local that are not upserted or removed\n            return async_1.default.eachSeries(docs, ((doc, callback) => {\n                return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, doc._id], (tx, results) => {\n                    // Check if present and not upserted/deleted\n                    if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n                        const existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null;\n                        // Exclude any excluded _ids from being cached/uncached\n                        if (options && options.exclude && options.exclude.includes(doc._id)) {\n                            callback();\n                            return;\n                        }\n                        // If _rev present, make sure that not overwritten by lower or equal _rev\n                        if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n                            // Upsert\n                            return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [this.name, doc._id, \"cached\", JSON.stringify(doc)], () => callback(), (tx, err) => error(err));\n                        }\n                        else {\n                            return callback();\n                        }\n                    }\n                    else {\n                        return callback();\n                    }\n                }, (tx, err) => error(err));\n            }), (err) => {\n                let sort;\n                if (err) {\n                    if (error) {\n                        error(err);\n                    }\n                    return;\n                }\n                // Rows have been cached, now look for stale ones to remove\n                const docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n                if (options.sort) {\n                    sort = (0, selector_1.compileSort)(options.sort);\n                }\n                // Perform query, removing rows missing in docs from local db\n                return this.find(selector, options).fetch((results) => {\n                    return this.db.transaction((tx) => {\n                        return async_1.default.eachSeries(results, ((result, callback) => {\n                            // If not present in docs and is present locally and not upserted/deleted\n                            return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, result._id], (tx, rows) => {\n                                if (!docsMap[result._id] && rows.rows.length > 0 && rows.rows.item(0).state === \"cached\") {\n                                    // Exclude any excluded _ids from being cached/uncached\n                                    if (options && options.exclude && options.exclude.includes(result._id)) {\n                                        callback();\n                                        return;\n                                    }\n                                    // If at limit\n                                    if (options.limit && docs.length === options.limit) {\n                                        // If past end on sorted limited, ignore\n                                        if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n                                            return callback();\n                                        }\n                                        // If no sort, ignore\n                                        if (!options.sort) {\n                                            return callback();\n                                        }\n                                    }\n                                    // Item is gone from server, remove locally\n                                    return tx.executeSql(\"DELETE FROM docs WHERE col = ? AND id = ?\", [this.name, result._id], () => callback(), (tx, err) => error(err));\n                                }\n                                else {\n                                    return callback();\n                                }\n                            }, (tx, err) => error(err));\n                        }), function (err) {\n                            if (err != null) {\n                                if (error != null) {\n                                    error(err);\n                                }\n                                return;\n                            }\n                            if (success != null) {\n                                return success();\n                            }\n                        });\n                    }, error);\n                }, error);\n            });\n        }, error);\n    }\n    pendingUpserts(success, error) {\n        // Android 2.x requires error callback\n        error = error || function () { };\n        return this.db.readTransaction((tx) => {\n            return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [this.name, \"upserted\"], function (tx, results) {\n                const docs = [];\n                for (let i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                    const row = results.rows.item(i);\n                    docs.push({ doc: JSON.parse(row.doc), base: row.base ? JSON.parse(row.base) : null });\n                }\n                if (success != null) {\n                    return success(docs);\n                }\n            }, (tx, err) => error(err));\n        }, error);\n    }\n    pendingRemoves(success, error) {\n        // Android 2.x requires error callback\n        error = error || function () { };\n        return this.db.readTransaction((tx) => {\n            return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [this.name, \"removed\"], function (tx, results) {\n                const docs = [];\n                for (let i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                    const row = results.rows.item(i);\n                    docs.push(JSON.parse(row.doc)._id);\n                }\n                if (success != null) {\n                    return success(docs);\n                }\n            }, (tx, err) => error(err));\n        }, error);\n    }\n    resolveUpserts(upserts, success, error) {\n        // Android 2.x requires error callback\n        error = error || function () { };\n        // Find records\n        return this.db.transaction((tx) => {\n            return async_1.default.eachSeries(upserts, ((upsert, cb) => {\n                return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, upsert.doc._id], (tx, results) => {\n                    if (results.rows.length > 0 && results.rows.item(0).state === \"upserted\") {\n                        // Only safely remove upsert if doc is the same\n                        if (lodash_1.default.isEqual(JSON.parse(results.rows.item(0).doc), upsert.doc)) {\n                            tx.executeSql('UPDATE docs SET state=\"cached\" WHERE col = ? AND id = ?', [this.name, upsert.doc._id], doNothing, (tx, err) => error(err));\n                            return cb();\n                        }\n                        else {\n                            tx.executeSql(\"UPDATE docs SET base=? WHERE col = ? AND id = ?\", [JSON.stringify(upsert.doc), this.name, upsert.doc._id], doNothing, (tx, err) => error(err));\n                            return cb();\n                        }\n                    }\n                    else {\n                        // Upsert removed, which is fine\n                        return cb();\n                    }\n                }, (tx, err) => error(err));\n            }), function (err) {\n                if (err) {\n                    return error(err);\n                }\n                // Success\n                if (success) {\n                    return success();\n                }\n            });\n        }, error);\n    }\n    resolveRemove(id, success, error) {\n        // Android 2.x requires error callback\n        error = error || function () { };\n        // Find record\n        return this.db.transaction((tx) => {\n            // Only safely remove if removed state\n            return tx.executeSql('DELETE FROM docs WHERE state=\"removed\" AND col = ? AND id = ?', [this.name, id], function () {\n                if (success) {\n                    return success(id);\n                }\n            }, (tx, err) => error(err));\n        }, error);\n    }\n    // Add but do not overwrite or record as upsert\n    seed(docs, success, error) {\n        if (!lodash_1.default.isArray(docs)) {\n            docs = [docs];\n        }\n        // Android 2.x requires error callback\n        error = error || function () { };\n        return this.db.transaction((tx) => {\n            // Add all non-local that are not upserted or removed\n            return async_1.default.eachSeries(docs, ((doc, callback) => {\n                return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, doc._id], (tx, results) => {\n                    // Check if present\n                    if (results.rows.length === 0) {\n                        // Upsert\n                        return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [this.name, doc._id, \"cached\", JSON.stringify(doc)], () => callback(), (tx, err) => error(err));\n                    }\n                    else {\n                        return callback();\n                    }\n                }, (tx, err) => error(err));\n            }), (err) => {\n                if (err) {\n                    if (error) {\n                        return error(err);\n                    }\n                }\n                else {\n                    if (success) {\n                        return success();\n                    }\n                }\n            });\n        }, error);\n    }\n    // Add but do not overwrite upsert/removed and do not record as upsert\n    cacheOne(doc, success, error) {\n        return this.cacheList([doc], success, error);\n    }\n    cacheList(docs, success, error) {\n        // Android 2.x requires error callback\n        error = error || function () { };\n        return this.db.transaction((tx) => {\n            // Add all non-local that are not upserted or removed\n            return async_1.default.eachSeries(docs, ((doc, callback) => {\n                return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [this.name, doc._id], (tx, results) => {\n                    // Only insert if not present or cached\n                    if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n                        const existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null;\n                        // If _rev present, make sure that not overwritten by lower or equal _rev\n                        if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n                            return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [this.name, doc._id, \"cached\", JSON.stringify(doc)], () => callback(), (tx, err) => callback(err));\n                        }\n                        else {\n                            return callback();\n                        }\n                    }\n                    else {\n                        return callback();\n                    }\n                }, (tx, err) => callback(err));\n            }), (err) => {\n                if (err) {\n                    if (error) {\n                        return error(err);\n                    }\n                }\n                else {\n                    if (success) {\n                        return success(docs);\n                    }\n                }\n            });\n        }, error);\n    }\n    uncache(selector, success, error) {\n        const compiledSelector = utils.compileDocumentSelector(selector);\n        // Android 2.x requires error callback\n        error = error || function () { };\n        return this.db.transaction((tx) => {\n            return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [this.name, \"cached\"], (tx, results) => {\n                // Determine which to remove\n                const toRemove = [];\n                for (let i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                    const row = results.rows.item(i);\n                    const doc = JSON.parse(row.doc);\n                    if (compiledSelector(doc)) {\n                        toRemove.push(doc._id);\n                    }\n                }\n                // Add all non-local that are not upserted or removed\n                return async_1.default.eachSeries(toRemove, ((id, callback) => {\n                    // Only safely remove if removed state\n                    return tx.executeSql('DELETE FROM docs WHERE state=\"cached\" AND col = ? AND id = ?', [this.name, id], () => callback(), (tx, err) => error(err));\n                }), (err) => {\n                    if (err) {\n                        if (error) {\n                            return error(err);\n                        }\n                    }\n                    else {\n                        if (success) {\n                            return success();\n                        }\n                    }\n                });\n            }, (tx, err) => error(err));\n        }, error);\n    }\n    uncacheList(ids, success, error) {\n        // Android 2.x requires error callback\n        error = error || function () { };\n        return this.db.transaction((tx) => {\n            // Add all non-local that are not upserted or removed\n            return async_1.default.eachSeries(ids, ((id, callback) => {\n                // Only safely remove if removed state\n                return tx.executeSql('DELETE FROM docs WHERE state=\"cached\" AND col = ? AND id = ?', [this.name, id], () => callback(), (tx, err) => error(err));\n            }), (err) => {\n                if (err) {\n                    if (error) {\n                        return error(err);\n                    }\n                }\n                else {\n                    if (success) {\n                        return success();\n                    }\n                }\n            });\n        }, error);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}