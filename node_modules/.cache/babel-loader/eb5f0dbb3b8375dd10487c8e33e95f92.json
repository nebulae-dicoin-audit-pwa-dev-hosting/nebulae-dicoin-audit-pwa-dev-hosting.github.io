{"ast":null,"code":"import calcBbox from \"@turf/bbox\";\nimport booleanPointOnLine from \"@turf/boolean-point-on-line\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Boolean-within returns true if the first geometry is completely within the second geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a)\n * must not intersect the exterior of the secondary (geometry b).\n * Boolean-within returns the exact opposite result of the `@turf/boolean-contains`.\n *\n * @name booleanWithin\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanWithin(point, line);\n * //=true\n */\n\nfunction booleanWithin(feature1, feature2) {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n\n  switch (type1) {\n    case \"Point\":\n      switch (type2) {\n        case \"MultiPoint\":\n          return isPointInMultiPoint(geom1, geom2);\n\n        case \"LineString\":\n          return booleanPointOnLine(geom1, geom2, {\n            ignoreEndVertices: true\n          });\n\n        case \"Polygon\":\n        case \"MultiPolygon\":\n          return booleanPointInPolygon(geom1, geom2, {\n            ignoreBoundary: true\n          });\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"MultiPoint\":\n          return isMultiPointInMultiPoint(geom1, geom2);\n\n        case \"LineString\":\n          return isMultiPointOnLine(geom1, geom2);\n\n        case \"Polygon\":\n        case \"MultiPolygon\":\n          return isMultiPointInPoly(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"LineString\":\n      switch (type2) {\n        case \"LineString\":\n          return isLineOnLine(geom1, geom2);\n\n        case \"Polygon\":\n        case \"MultiPolygon\":\n          return isLineInPoly(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"Polygon\":\n      switch (type2) {\n        case \"Polygon\":\n        case \"MultiPolygon\":\n          return isPolyInPoly(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\n\nfunction isPointInMultiPoint(point, multiPoint) {\n  var i;\n  var output = false;\n\n  for (i = 0; i < multiPoint.coordinates.length; i++) {\n    if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {\n      output = true;\n      break;\n    }\n  }\n\n  return output;\n}\n\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n  for (var i = 0; i < multiPoint1.coordinates.length; i++) {\n    var anyMatch = false;\n\n    for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {\n      if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {\n        anyMatch = true;\n      }\n    }\n\n    if (!anyMatch) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isMultiPointOnLine(multiPoint, lineString) {\n  var foundInsidePoint = false;\n\n  for (var i = 0; i < multiPoint.coordinates.length; i++) {\n    if (!booleanPointOnLine(multiPoint.coordinates[i], lineString)) {\n      return false;\n    }\n\n    if (!foundInsidePoint) {\n      foundInsidePoint = booleanPointOnLine(multiPoint.coordinates[i], lineString, {\n        ignoreEndVertices: true\n      });\n    }\n  }\n\n  return foundInsidePoint;\n}\n\nfunction isMultiPointInPoly(multiPoint, polygon) {\n  var output = true;\n  var oneInside = false;\n  var isInside = false;\n\n  for (var i = 0; i < multiPoint.coordinates.length; i++) {\n    isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon);\n\n    if (!isInside) {\n      output = false;\n      break;\n    }\n\n    if (!oneInside) {\n      isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon, {\n        ignoreBoundary: true\n      });\n    }\n  }\n\n  return output && isInside;\n}\n\nfunction isLineOnLine(lineString1, lineString2) {\n  for (var i = 0; i < lineString1.coordinates.length; i++) {\n    if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isLineInPoly(linestring, polygon) {\n  var polyBbox = calcBbox(polygon);\n  var lineBbox = calcBbox(linestring);\n\n  if (!doBBoxOverlap(polyBbox, lineBbox)) {\n    return false;\n  }\n\n  var foundInsidePoint = false;\n\n  for (var i = 0; i < linestring.coordinates.length - 1; i++) {\n    if (!booleanPointInPolygon(linestring.coordinates[i], polygon)) {\n      return false;\n    }\n\n    if (!foundInsidePoint) {\n      foundInsidePoint = booleanPointInPolygon(linestring.coordinates[i], polygon, {\n        ignoreBoundary: true\n      });\n    }\n\n    if (!foundInsidePoint) {\n      var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n      foundInsidePoint = booleanPointInPolygon(midpoint, polygon, {\n        ignoreBoundary: true\n      });\n    }\n  }\n\n  return foundInsidePoint;\n}\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Polygon} geometry1\n * @param {Polygon|MultiPolygon} geometry2\n * @returns {boolean} true/false\n */\n\n\nfunction isPolyInPoly(geometry1, geometry2) {\n  var poly1Bbox = calcBbox(geometry1);\n  var poly2Bbox = calcBbox(geometry2);\n\n  if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {\n    return false;\n  }\n\n  for (var i = 0; i < geometry1.coordinates[0].length; i++) {\n    if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doBBoxOverlap(bbox1, bbox2) {\n  if (bbox1[0] > bbox2[0]) return false;\n  if (bbox1[2] < bbox2[2]) return false;\n  if (bbox1[1] > bbox2[1]) return false;\n  if (bbox1[3] < bbox2[3]) return false;\n  return true;\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\n\n\nfunction compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n/**\n * getMidpoint\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {Position} midpoint of pair1 and pair2\n */\n\n\nfunction getMidpoint(pair1, pair2) {\n  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\n\nexport default booleanWithin;","map":null,"metadata":{},"sourceType":"module"}