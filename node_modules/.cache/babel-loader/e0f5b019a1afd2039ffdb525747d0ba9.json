{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HybridCollection = void 0;\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar utils = __importStar(require(\"./utils\"));\n/** Bridges a local and remote database, querying from the local first and then\n * getting the remote. Also uploads changes from local to remote.\n */\n\n\nvar HybridDb = /*#__PURE__*/function () {\n  function HybridDb(localDb, remoteDb) {\n    _classCallCheck(this, HybridDb);\n\n    this.localDb = localDb;\n    this.remoteDb = remoteDb;\n    this.collections = {};\n  }\n\n  _createClass(HybridDb, [{\n    key: \"addCollection\",\n    value: function addCollection(name, options, success, error) {\n      // Shift options over if not present\n      if (lodash_1.default.isFunction(options)) {\n        ;\n        var _ref = [{}, options, success];\n        options = _ref[0];\n        success = _ref[1];\n        error = _ref[2];\n      }\n\n      var collection = new HybridCollection(name, this.localDb[name], this.remoteDb[name], options);\n      this[name] = collection;\n      this.collections[name] = collection;\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"removeCollection\",\n    value: function removeCollection(name, success, error) {\n      delete this[name];\n      delete this.collections[name];\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"upload\",\n    value: function upload(success, error) {\n      var cols = Object.values(this.collections);\n\n      function uploadCols(cols, success, error) {\n        var col = lodash_1.default.first(cols);\n\n        if (col) {\n          col.upload(function () {\n            return uploadCols(lodash_1.default.tail(cols), success, error);\n          }, function (err) {\n            return error(err);\n          });\n        } else {\n          success();\n        }\n      }\n\n      return uploadCols(cols, success, error);\n    }\n  }, {\n    key: \"getCollectionNames\",\n    value: function getCollectionNames() {\n      return lodash_1.default.keys(this.collections);\n    }\n  }]);\n\n  return HybridDb;\n}();\n\nexports.default = HybridDb;\n\nvar HybridCollection = /*#__PURE__*/function () {\n  // Options includes\n  function HybridCollection(name, localCol, remoteCol, options) {\n    _classCallCheck(this, HybridCollection);\n\n    this.name = name;\n    this.localCol = localCol;\n    this.remoteCol = remoteCol; // Default options\n\n    this.options = options || {};\n    lodash_1.default.defaults(this.options, {\n      cacheFind: true,\n      cacheFindOne: true,\n      interim: true,\n      useLocalOnRemoteError: true,\n      shortcut: false,\n      timeout: 0,\n      sortUpserts: null // Compare function to sort upserts sent to server\n\n    });\n  }\n\n  _createClass(HybridCollection, [{\n    key: \"find\",\n    value: function find(selector) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return {\n        fetch: function fetch(success, error) {\n          return _this._findFetch(selector, options, success, error);\n        }\n      };\n    }\n  }, {\n    key: \"findOne\",\n    value: function findOne(selector, options, success, error) {\n      var _this2 = this;\n\n      if (lodash_1.default.isFunction(options)) {\n        ;\n        var _ref2 = [{}, options, success];\n        options = _ref2[0];\n        success = _ref2[1];\n        error = _ref2[2];\n      } // Merge options\n\n\n      lodash_1.default.defaults(options, this.options); // Happens after initial find\n\n      var step2 = function step2(localDoc) {\n        var findOptions = lodash_1.default.cloneDeep(options);\n        findOptions.interim = false;\n        findOptions.cacheFind = options.cacheFindOne;\n\n        if (selector._id) {\n          findOptions.limit = 1;\n        } else {\n          // Without _id specified, interaction between local and remote changes is complex\n          // For example, if the one result returned by remote is locally deleted, we have no fallback\n          // So instead we do a find with no limit and then take the first result, which is very inefficient\n          delete findOptions.limit;\n        }\n\n        return _this2.find(selector, findOptions).fetch(function (data) {\n          // Return first entry or null\n          if (data.length > 0) {\n            // Check that different from existing\n            if (!lodash_1.default.isEqual(localDoc, data[0])) {\n              return success(data[0]);\n            }\n          } else {\n            // If nothing found, always report it, as interim find doesn't return null\n            return success(null);\n          }\n        }, error);\n      }; // If interim or shortcut, get local first\n\n\n      if (options.interim || options.shortcut) {\n        return this.localCol.findOne(selector, options, function (localDoc) {\n          // If found, return\n          if (localDoc) {\n            success(lodash_1.default.cloneDeep(localDoc)); // If shortcut, we're done\n\n            if (options.shortcut) {\n              return;\n            }\n          }\n\n          return step2(localDoc);\n        }, error);\n      } else {\n        return step2(null);\n      }\n    }\n  }, {\n    key: \"_findFetch\",\n    value: function _findFetch(selector, options, success, error) {\n      var _this3 = this;\n\n      // Merge options\n      lodash_1.default.defaults(options, this.options); // Get pending removes and upserts immediately to avoid odd race conditions\n\n      return this.localCol.pendingUpserts(function (upserts) {\n        return _this3.localCol.pendingRemoves(function (removes) {\n          var step2 = function step2(localData) {\n            // Setup remote options\n            var remoteOptions = lodash_1.default.cloneDeep(options); // If caching, get all fields\n\n            if (options.cacheFind) {\n              delete remoteOptions.fields;\n            } // Add localData to options for remote find for quickfind protocol\n\n\n            remoteOptions.localData = localData; // Setup timer variables\n\n            var timer = null;\n            var timedOut = false;\n\n            var remoteSuccess = function remoteSuccess(remoteData) {\n              // Cancel timer\n              if (timer) {\n                clearTimeout(timer);\n              } // Ignore if timed out, caching asynchronously\n\n\n              if (timedOut) {\n                if (options.cacheFind) {\n                  _this3.localCol.cache(remoteData, selector, options, function () {}, error);\n                }\n\n                return;\n              }\n\n              if (options.cacheFind) {\n                // Cache locally\n                var cacheSuccess = function cacheSuccess() {\n                  // Get local data again\n                  function localSuccess2(localData2) {\n                    // Check if different or not interim\n                    if (!options.interim || !lodash_1.default.isEqual(localData, localData2)) {\n                      // Send again\n                      return success(localData2);\n                    }\n                  }\n\n                  return _this3.localCol.find(selector, options).fetch(localSuccess2, error);\n                }; // Exclude any recent upserts/removes to prevent race condition\n\n\n                var cacheOptions = lodash_1.default.extend({}, options, {\n                  exclude: removes.concat(lodash_1.default.map(upserts, function (u) {\n                    return u.doc._id;\n                  }))\n                });\n                return _this3.localCol.cache(remoteData, selector, cacheOptions, cacheSuccess, error);\n              } else {\n                // Remove local remotes\n                var data = remoteData;\n\n                if (removes.length > 0) {\n                  var removesMap = lodash_1.default.fromPairs(lodash_1.default.map(removes, function (id) {\n                    return [id, id];\n                  }));\n                  data = lodash_1.default.filter(remoteData, function (doc) {\n                    return !lodash_1.default.has(removesMap, doc._id);\n                  });\n                } // Add upserts\n\n\n                if (upserts.length > 0) {\n                  // Remove upserts from data\n                  var upsertsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(upserts, function (u) {\n                    return u.doc._id;\n                  }), lodash_1.default.map(upserts, function (u) {\n                    return u.doc._id;\n                  })));\n                  data = lodash_1.default.filter(data, function (doc) {\n                    return !lodash_1.default.has(upsertsMap, doc._id);\n                  }); // Add upserts\n\n                  data = data.concat(lodash_1.default.map(upserts, \"doc\")); // Refilter/sort/limit\n\n                  data = (0, utils_1.processFind)(data, selector, options);\n                } // Check if different or not interim\n\n\n                if (!options.interim || !lodash_1.default.isEqual(localData, data)) {\n                  // Send again\n                  return success(data);\n                }\n              }\n            };\n\n            var remoteError = function remoteError(err) {\n              // Cancel timer\n              if (timer) {\n                clearTimeout(timer);\n              }\n\n              if (timedOut) {\n                return;\n              } // If no interim, do local find\n\n\n              if (!options.interim) {\n                if (options.useLocalOnRemoteError) {\n                  return success(localData);\n                } else {\n                  if (error) {\n                    return error(err);\n                  }\n                }\n              } else {\n                // Otherwise do nothing\n                return;\n              }\n            }; // Start timer if remote\n\n\n            if (options.timeout) {\n              timer = setTimeout(function () {\n                timer = null;\n                timedOut = true; // If no interim, do local find\n\n                if (!options.interim) {\n                  if (options.useLocalOnRemoteError) {\n                    return _this3.localCol.find(selector, options).fetch(success, error);\n                  } else {\n                    if (error) {\n                      return error(new Error(\"Remote timed out\"));\n                    }\n                  }\n                } else {\n                  // Otherwise do nothing\n                  return;\n                }\n              }, options.timeout);\n            }\n\n            return _this3.remoteCol.find(selector, remoteOptions).fetch(remoteSuccess, remoteError);\n          };\n\n          function localSuccess(localData) {\n            // If interim, return data immediately\n            if (options.interim) {\n              success(localData);\n            }\n\n            return step2(localData);\n          } // Always get local data first\n\n\n          return _this3.localCol.find(selector, options).fetch(localSuccess, error);\n        }, error);\n      }, error);\n    }\n  }, {\n    key: \"upsert\",\n    value: function upsert(docs, bases, success, error) {\n      var items;\n\n      var _utils$regularizeUpse = utils.regularizeUpsert(docs, bases, success, error);\n\n      var _utils$regularizeUpse2 = _slicedToArray(_utils$regularizeUpse, 3);\n\n      items = _utils$regularizeUpse2[0];\n      success = _utils$regularizeUpse2[1];\n      error = _utils$regularizeUpse2[2];\n      return this.localCol.upsert(lodash_1.default.map(items, \"doc\"), lodash_1.default.map(items, \"base\"), function (result) {\n        return success === null || success === void 0 ? void 0 : success(docs);\n      }, error);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(id, success, error) {\n      return this.localCol.remove(id, function () {\n        if (success != null) {\n          return success();\n        }\n      }, error);\n    }\n  }, {\n    key: \"upload\",\n    value: function upload(success, error) {\n      var _this4 = this;\n\n      var uploadUpserts = function uploadUpserts(upserts, success, error) {\n        var upsert = lodash_1.default.first(upserts);\n\n        if (upsert) {\n          return _this4.remoteCol.upsert(upsert.doc, upsert.base, function (remoteDoc) {\n            return _this4.localCol.resolveUpserts([upsert], function () {\n              // Cache new value if present\n              if (remoteDoc) {\n                return _this4.localCol.cacheOne(remoteDoc, function () {\n                  return uploadUpserts(lodash_1.default.tail(upserts), success, error);\n                }, error);\n              } else {\n                // Remove local\n                return _this4.localCol.remove(upsert.doc._id, function () {\n                  // Resolve remove\n                  return _this4.localCol.resolveRemove(upsert.doc._id, function () {\n                    return uploadUpserts(lodash_1.default.tail(upserts), success, error);\n                  }, error);\n                }, error);\n              }\n            }, error);\n          }, function (err) {\n            // If 410 error or 403, remove document\n            if (err.status === 410 || err.status === 403) {\n              return _this4.localCol.remove(upsert.doc._id, function () {\n                // Resolve remove\n                return _this4.localCol.resolveRemove(upsert.doc._id, function () {\n                  // Continue if was 410\n                  if (err.status === 410) {\n                    return uploadUpserts(lodash_1.default.tail(upserts), success, error);\n                  } else {\n                    return error(err);\n                  }\n                }, error);\n              }, error);\n            } else {\n              return error(err);\n            }\n          });\n        } else {\n          return success();\n        }\n      };\n\n      var uploadRemoves = function uploadRemoves(removes, success, error) {\n        var remove = lodash_1.default.first(removes);\n\n        if (remove) {\n          return _this4.remoteCol.remove(remove, function () {\n            return _this4.localCol.resolveRemove(remove, function () {\n              return uploadRemoves(lodash_1.default.tail(removes), success, error);\n            }, error);\n          }, function (err) {\n            // If 403 or 410, remove document\n            if (err.status === 410 || err.status === 403) {\n              return _this4.localCol.resolveRemove(remove, function () {\n                // Continue if was 410\n                if (err.status === 410) {\n                  return uploadRemoves(lodash_1.default.tail(removes), success, error);\n                } else {\n                  return error(err);\n                }\n              }, error);\n            } else {\n              return error(err);\n            }\n          });\n        } else {\n          success();\n        }\n      }; // Get pending upserts\n\n\n      this.localCol.pendingUpserts(function (upserts) {\n        // Sort upserts if sort defined\n        if (_this4.options.sortUpserts) {\n          upserts.sort(function (u1, u2) {\n            return _this4.options.sortUpserts(u1.doc, u2.doc);\n          });\n        }\n\n        return uploadUpserts(upserts, function () {\n          return _this4.localCol.pendingRemoves(function (removes) {\n            return uploadRemoves(removes, success, error);\n          }, error);\n        }, error);\n      }, error);\n    }\n  }]);\n\n  return HybridCollection;\n}();\n\nexports.HybridCollection = HybridCollection;","map":null,"metadata":{},"sourceType":"script"}