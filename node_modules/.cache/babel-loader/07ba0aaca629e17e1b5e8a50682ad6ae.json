{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar utils = __importStar(require(\"./utils\"));\n\nvar jQueryHttpClient_1 = __importDefault(require(\"./jQueryHttpClient\"));\n\nvar quickfind = __importStar(require(\"./quickfind\"));\n\nvar RemoteDb = /*#__PURE__*/function () {\n  /** Url must have trailing /, can be an arrau of URLs\n   * useQuickFind enables the quickfind protocol for finds\n   * usePostFind enables POST for find\n   */\n  function RemoteDb(url, client, httpClient) {\n    var useQuickFind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var usePostFind = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    _classCallCheck(this, RemoteDb);\n\n    this.url = url;\n    this.client = client;\n    this.collections = {};\n    this.httpClient = httpClient;\n    this.useQuickFind = useQuickFind;\n    this.usePostFind = usePostFind;\n  } // Can specify url of specific collection as option.\n  // useQuickFind can be overridden in options\n  // usePostFind can be overridden in options\n\n\n  _createClass(RemoteDb, [{\n    key: \"addCollection\",\n    value: function addCollection(name) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var success = arguments.length > 2 ? arguments[2] : undefined;\n      var error = arguments.length > 3 ? arguments[3] : undefined;\n      var url;\n\n      if (lodash_1.default.isFunction(options)) {\n        ;\n        var _ref = [{}, options, success];\n        options = _ref[0];\n        success = _ref[1];\n        error = _ref[2];\n      }\n\n      if (options.url) {\n        ;\n        var _options = options;\n        url = _options.url;\n      } else {\n        if (lodash_1.default.isArray(this.url)) {\n          url = lodash_1.default.map(this.url, function (url) {\n            return url + name;\n          });\n        } else {\n          url = this.url + name;\n        }\n      }\n\n      var useQuickFind = this.useQuickFind;\n\n      if (options.useQuickFind != null) {\n        ;\n        var _options2 = options;\n        useQuickFind = _options2.useQuickFind;\n      }\n\n      var usePostFind = this.usePostFind;\n\n      if (options.usePostFind != null) {\n        ;\n        var _options3 = options;\n        usePostFind = _options3.usePostFind;\n      }\n\n      var collection = new Collection(name, url, this.client, this.httpClient, useQuickFind, usePostFind);\n      this[name] = collection;\n      this.collections[name] = collection;\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"removeCollection\",\n    value: function removeCollection(name, success, error) {\n      delete this[name];\n      delete this.collections[name];\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"getCollectionNames\",\n    value: function getCollectionNames() {\n      return lodash_1.default.keys(this.collections);\n    }\n  }]);\n\n  return RemoteDb;\n}();\n\nexports.default = RemoteDb; // Remote collection on server\n\nvar Collection = /*#__PURE__*/function () {\n  // usePostFind allows POST to <collection>/find for long selectors\n  function Collection(name, url, client, httpClient, useQuickFind, usePostFind) {\n    _classCallCheck(this, Collection);\n\n    this.name = name;\n    this.url = url;\n    this.client = client;\n    this.httpClient = httpClient || jQueryHttpClient_1.default;\n    this.useQuickFind = useQuickFind;\n    this.usePostFind = usePostFind;\n  }\n\n  _createClass(Collection, [{\n    key: \"getUrl\",\n    value: function getUrl() {\n      var url;\n\n      if (lodash_1.default.isArray(this.url)) {\n        url = this.url.pop(); // Add the URL to the front of the array\n\n        this.url.unshift(url);\n        return url;\n      }\n\n      return this.url;\n    } // error is called with jqXHR\n\n  }, {\n    key: \"find\",\n    value: function find(selector) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return {\n        fetch: function fetch(success, error) {\n          // Determine method: \"get\", \"post\" or \"quickfind\"\n          // If in quickfind and localData present and (no fields option or _rev included) and not (limit with no sort), use quickfind\n          var method;\n\n          if (_this.useQuickFind && options.localData && (!options.fields || options.fields._rev) && !(options.limit && !options.sort && !options.orderByExprs)) {\n            method = \"quickfind\"; // If selector or fields or sort is too big, use post\n          } else if (_this.usePostFind && JSON.stringify({\n            selector: selector,\n            sort: options.sort,\n            fields: options.fields\n          }).length > 500) {\n            method = \"post\";\n          } else {\n            method = \"get\";\n          }\n\n          if (method === \"get\") {\n            // Create url\n            var _params = {};\n            _params.selector = JSON.stringify(selector || {});\n\n            if (options.sort) {\n              _params.sort = JSON.stringify(options.sort);\n            }\n\n            if (options.limit) {\n              _params.limit = options.limit;\n            }\n\n            if (options.skip) {\n              _params.skip = options.skip;\n            }\n\n            if (options.fields) {\n              _params.fields = JSON.stringify(options.fields);\n            } // Advanced options for mwater-expression-based filtering and ordering\n\n\n            if (options.whereExpr) {\n              _params.whereExpr = JSON.stringify(options.whereExpr);\n            }\n\n            if (options.orderByExprs) {\n              _params.orderByExprs = JSON.stringify(options.orderByExprs);\n            }\n\n            if (_this.client) {\n              _params.client = _this.client;\n            }\n\n            _this.httpClient(\"GET\", _this.getUrl(), _params, null, success, error);\n\n            return;\n          } // Create body + params for quickfind and post\n\n\n          var body = {\n            selector: selector || {}\n          };\n\n          if (options.sort) {\n            body.sort = options.sort;\n          }\n\n          if (options.limit != null) {\n            body.limit = options.limit;\n          }\n\n          if (options.skip != null) {\n            body.skip = options.skip;\n          }\n\n          if (options.fields) {\n            body.fields = options.fields;\n          } // Advanced options for mwater-expression-based filtering and ordering\n\n\n          if (options.whereExpr) {\n            body.whereExpr = options.whereExpr;\n          }\n\n          if (options.orderByExprs) {\n            body.orderByExprs = options.orderByExprs;\n          }\n\n          var params = {};\n\n          if (_this.client) {\n            params.client = _this.client;\n          }\n\n          if (method === \"quickfind\") {\n            // Send quickfind data\n            body.quickfind = quickfind.encodeRequest(options.localData);\n\n            _this.httpClient(\"POST\", _this.getUrl() + \"/quickfind\", params, body, function (encodedResponse) {\n              return success(quickfind.decodeResponse(encodedResponse, options.localData, options.sort));\n            }, error);\n\n            return;\n          } // POST method\n\n\n          return _this.httpClient(\"POST\", _this.getUrl() + \"/find\", params, body, function (response) {\n            return success(response);\n          }, error);\n        }\n      };\n    }\n  }, {\n    key: \"findOne\",\n    value: function findOne(selector, options, success, error) {\n      if (lodash_1.default.isFunction(options)) {\n        ;\n        var _ref2 = [{}, options, success];\n        options = _ref2[0];\n        success = _ref2[1];\n        error = _ref2[2];\n      } // Create url\n\n\n      var params = {};\n\n      if (options.sort) {\n        params.sort = JSON.stringify(options.sort);\n      }\n\n      params.limit = 1;\n\n      if (this.client) {\n        params.client = this.client;\n      }\n\n      params.selector = JSON.stringify(selector || {});\n      return this.httpClient(\"GET\", this.getUrl(), params, null, function (results) {\n        if (results && results.length > 0) {\n          return success(results[0]);\n        } else {\n          return success(null);\n        }\n      }, error);\n    } // error is called with jqXHR\n\n  }, {\n    key: \"upsert\",\n    value: function upsert(docs, bases, success, error) {\n      var items;\n\n      var _utils$regularizeUpse = utils.regularizeUpsert(docs, bases, success, error);\n\n      var _utils$regularizeUpse2 = _slicedToArray(_utils$regularizeUpse, 3);\n\n      items = _utils$regularizeUpse2[0];\n      success = _utils$regularizeUpse2[1];\n      error = _utils$regularizeUpse2[2];\n      var results = []; // Check if bases present\n\n      var basesPresent = lodash_1.default.compact(lodash_1.default.map(items, \"base\")).length > 0;\n      var params = {};\n\n      if (this.client) {\n        params.client = this.client;\n      } // Handle single case\n\n\n      if (items.length === 1) {\n        // POST if no base, PATCH otherwise\n        if (basesPresent) {\n          return this.httpClient(\"PATCH\", this.getUrl(), params, items[0], function (result) {\n            if (lodash_1.default.isArray(docs)) {\n              return success([result]);\n            } else {\n              return success(result);\n            }\n          }, function (err) {\n            if (error) {\n              return error(err);\n            }\n          });\n        } else {\n          return this.httpClient(\"POST\", this.getUrl(), params, items[0].doc, function (result) {\n            if (lodash_1.default.isArray(docs)) {\n              return success([result]);\n            } else {\n              return success(result);\n            }\n          }, function (err) {\n            if (error) {\n              return error(err);\n            }\n          });\n        }\n      } else {\n        // POST if no base, PATCH otherwise\n        if (basesPresent) {\n          return this.httpClient(\"PATCH\", this.getUrl(), params, {\n            doc: lodash_1.default.map(items, \"doc\"),\n            base: lodash_1.default.map(items, \"base\")\n          }, function (result) {\n            return success(result);\n          }, function (err) {\n            if (error) {\n              return error(err);\n            }\n          });\n        } else {\n          return this.httpClient(\"POST\", this.getUrl(), params, lodash_1.default.map(items, \"doc\"), function (result) {\n            return success(result);\n          }, function (err) {\n            if (error) {\n              return error(err);\n            }\n          });\n        }\n      }\n    } // error is called with jqXHR\n\n  }, {\n    key: \"remove\",\n    value: function remove(id, success, error) {\n      if (!this.client) {\n        throw new Error(\"Client required to remove\");\n      }\n\n      var params = {\n        client: this.client\n      };\n      return this.httpClient(\"DELETE\", this.getUrl() + \"/\" + id, params, null, success, function (err) {\n        // 410 is an acceptable delete status\n        if (err.status === 410) {\n          return success();\n        } else {\n          return error(err);\n        }\n      });\n    }\n  }]);\n\n  return Collection;\n}();","map":null,"metadata":{},"sourceType":"script"}