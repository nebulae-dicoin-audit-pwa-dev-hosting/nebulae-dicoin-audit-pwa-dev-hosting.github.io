{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar async_1 = __importDefault(require(\"async\"));\n\nvar utils = __importStar(require(\"./utils\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar selector_1 = require(\"./selector\");\n\nvar LocalStorageDb = /*#__PURE__*/function () {\n  function LocalStorageDb(options, success, error) {\n    _classCallCheck(this, LocalStorageDb);\n\n    this.collections = {};\n\n    if (options && options.namespace && window.localStorage) {\n      this.namespace = options.namespace;\n    }\n\n    if (success) {\n      success(this);\n    }\n  }\n\n  _createClass(LocalStorageDb, [{\n    key: \"addCollection\",\n    value: function addCollection(name, success, error) {\n      // Set namespace for collection\n      var namespace;\n\n      if (this.namespace) {\n        namespace = this.namespace + \".\" + name;\n      }\n\n      var collection = new Collection(name, namespace);\n      this[name] = collection;\n      this.collections[name] = collection;\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"removeCollection\",\n    value: function removeCollection(name, success, error) {\n      if (this.namespace && window.localStorage) {\n        var keys = [];\n\n        for (var i = 0, end = window.localStorage.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          keys.push(window.localStorage.key(i));\n        }\n\n        for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n          var key = _keys[_i];\n          var keyToMatch = this.namespace + \".\" + name;\n\n          if (key.substring(0, keyToMatch.length) === keyToMatch) {\n            window.localStorage.removeItem(key);\n          }\n        }\n      }\n\n      delete this[name];\n      delete this.collections[name];\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"getCollectionNames\",\n    value: function getCollectionNames() {\n      return lodash_1.default.keys(this.collections);\n    }\n  }]);\n\n  return LocalStorageDb;\n}();\n\nexports.default = LocalStorageDb; // Stores data in memory, optionally backed by local storage\n\nvar Collection = /*#__PURE__*/function () {\n  function Collection(name, namespace) {\n    _classCallCheck(this, Collection);\n\n    this.name = name;\n    this.namespace = namespace;\n    this.items = {};\n    this.upserts = {}; // Pending upserts by _id. Still in items\n\n    this.removes = {}; // Pending removes by _id. No longer in items\n    // Read from local storage\n\n    if (window.localStorage && namespace != null) {\n      this.loadStorage();\n    }\n  }\n\n  _createClass(Collection, [{\n    key: \"loadStorage\",\n    value: function loadStorage() {\n      // Read items from localStorage\n      var key;\n      this.itemNamespace = this.namespace + \"_\";\n\n      for (var i = 0, end = window.localStorage.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n        key = window.localStorage.key(i);\n\n        if (key.substring(0, this.itemNamespace.length) === this.itemNamespace) {\n          var item = JSON.parse(window.localStorage[key]);\n          this.items[item._id] = item;\n        }\n      } // Read upserts\n\n\n      var upsertKeys = window.localStorage[this.namespace + \"upserts\"] ? JSON.parse(window.localStorage[this.namespace + \"upserts\"]) : [];\n\n      var _iterator = _createForOfIteratorHelper(upsertKeys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          key = _step.value;\n          this.upserts[key] = {\n            doc: this.items[key]\n          }; // Get base if present\n\n          var base = window.localStorage[this.namespace + \"upsertbase_\" + key] ? JSON.parse(window.localStorage[this.namespace + \"upsertbase_\" + key]) : null;\n          this.upserts[key].base = base;\n        } // Read removes\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var removeItems = window.localStorage[this.namespace + \"removes\"] ? JSON.parse(window.localStorage[this.namespace + \"removes\"]) : [];\n      return this.removes = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(removeItems, \"_id\"), removeItems));\n    }\n  }, {\n    key: \"find\",\n    value: function find(selector, options) {\n      var _this = this;\n\n      return {\n        fetch: function fetch(success, error) {\n          return _this._findFetch(selector, options, success, error);\n        }\n      };\n    }\n  }, {\n    key: \"findOne\",\n    value: function findOne(selector, options, success, error) {\n      if (lodash_1.default.isFunction(options)) {\n        ;\n        var _ref = [{}, options, success];\n        options = _ref[0];\n        success = _ref[1];\n        error = _ref[2];\n      }\n\n      return this.find(selector, options).fetch(function (results) {\n        if (success != null) {\n          return success(results.length > 0 ? results[0] : null);\n        }\n      }, error);\n    }\n  }, {\n    key: \"_findFetch\",\n    value: function _findFetch(selector, options, success, error) {\n      // Deep clone to prevent modification\n      if (success != null) {\n        return success((0, utils_1.processFind)(lodash_1.default.cloneDeep(lodash_1.default.values(this.items)), selector, options));\n      }\n    }\n  }, {\n    key: \"upsert\",\n    value: function upsert(docs, bases, success, error) {\n      var items;\n\n      var _utils$regularizeUpse = utils.regularizeUpsert(docs, bases, success, error);\n\n      var _utils$regularizeUpse2 = _slicedToArray(_utils$regularizeUpse, 3);\n\n      items = _utils$regularizeUpse2[0];\n      success = _utils$regularizeUpse2[1];\n      error = _utils$regularizeUpse2[2];\n      // Keep independent copies to prevent modification\n      items = JSON.parse(JSON.stringify(items));\n\n      var _iterator2 = _createForOfIteratorHelper(items),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n\n          // Fill in base\n          if (item.base === undefined) {\n            // Use existing base\n            if (this.upserts[item.doc._id]) {\n              item.base = this.upserts[item.doc._id].base;\n            } else {\n              item.base = this.items[item.doc._id] || null;\n            }\n          } // Keep independent copies\n\n\n          item = lodash_1.default.cloneDeep(item); // Replace/add\n\n          this._putItem(item.doc);\n\n          this._putUpsert(item);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (success) {\n        return success(docs);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(id, success, error) {\n      var _this2 = this;\n\n      // Special case for filter-type remove\n      if (lodash_1.default.isObject(id)) {\n        this.find(id).fetch(function (rows) {\n          return async_1.default.each(rows, function (row, cb) {\n            return _this2.remove(row._id, function () {\n              return cb();\n            }, cb);\n          }, function () {\n            return success();\n          });\n        }, error);\n        return;\n      }\n\n      if (lodash_1.default.has(this.items, id)) {\n        this._putRemove(this.items[id]);\n\n        this._deleteItem(id);\n\n        this._deleteUpsert(id);\n      } else {\n        this._putRemove({\n          _id: id\n        });\n      }\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"_putItem\",\n    value: function _putItem(doc) {\n      this.items[doc._id] = doc;\n\n      if (this.namespace) {\n        window.localStorage[this.itemNamespace + doc._id] = JSON.stringify(doc);\n      }\n    }\n  }, {\n    key: \"_deleteItem\",\n    value: function _deleteItem(id) {\n      delete this.items[id];\n\n      if (this.namespace) {\n        window.localStorage.removeItem(this.itemNamespace + id);\n      }\n    }\n  }, {\n    key: \"_putUpsert\",\n    value: function _putUpsert(upsert) {\n      this.upserts[upsert.doc._id] = upsert;\n\n      if (this.namespace) {\n        window.localStorage[this.namespace + \"upserts\"] = JSON.stringify(lodash_1.default.keys(this.upserts));\n        window.localStorage[this.namespace + \"upsertbase_\" + upsert.doc._id] = JSON.stringify(upsert.base);\n      }\n    }\n  }, {\n    key: \"_deleteUpsert\",\n    value: function _deleteUpsert(id) {\n      delete this.upserts[id];\n\n      if (this.namespace) {\n        window.localStorage[this.namespace + \"upserts\"] = JSON.stringify(lodash_1.default.keys(this.upserts));\n      }\n    }\n  }, {\n    key: \"_putRemove\",\n    value: function _putRemove(doc) {\n      this.removes[doc._id] = doc;\n\n      if (this.namespace) {\n        window.localStorage[this.namespace + \"removes\"] = JSON.stringify(lodash_1.default.values(this.removes));\n      }\n    }\n  }, {\n    key: \"_deleteRemove\",\n    value: function _deleteRemove(id) {\n      delete this.removes[id];\n\n      if (this.namespace) {\n        window.localStorage[this.namespace + \"removes\"] = JSON.stringify(lodash_1.default.values(this.removes));\n      }\n    }\n  }, {\n    key: \"cache\",\n    value: function cache(docs, selector, options, success, error) {\n      var _this3 = this;\n\n      // Add all non-local that are not upserted or removed\n      var sort;\n\n      var _iterator3 = _createForOfIteratorHelper(docs),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var doc = _step3.value;\n\n          // Exclude any excluded _ids from being cached/uncached\n          if (options && options.exclude && options.exclude.includes(doc._id)) {\n            continue;\n          }\n\n          this.cacheOne(doc, function () {}, function () {});\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n\n      if (options.sort) {\n        sort = (0, selector_1.compileSort)(options.sort);\n      } // Perform query, removing rows missing in docs from local db\n\n\n      return this.find(selector, options).fetch(function (results) {\n        var _iterator4 = _createForOfIteratorHelper(results),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var result = _step4.value;\n\n            if (!docsMap[result._id] && !lodash_1.default.has(_this3.upserts, result._id)) {\n              // Exclude any excluded _ids from being cached/uncached\n              if (options && options.exclude && options.exclude.includes(result._id)) {\n                continue;\n              } // If at limit\n\n\n              if (options.limit && docs.length === options.limit) {\n                // If past end on sorted limited, ignore\n                if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n                  continue;\n                } // If no sort, ignore\n\n\n                if (!options.sort) {\n                  continue;\n                }\n              }\n\n              _this3._deleteItem(result._id);\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        if (success != null) {\n          return success();\n        }\n      }, error);\n    }\n  }, {\n    key: \"pendingUpserts\",\n    value: function pendingUpserts(success) {\n      return success(lodash_1.default.values(this.upserts));\n    }\n  }, {\n    key: \"pendingRemoves\",\n    value: function pendingRemoves(success) {\n      return success(lodash_1.default.map(this.removes, \"_id\"));\n    }\n  }, {\n    key: \"resolveUpserts\",\n    value: function resolveUpserts(upserts, success) {\n      var _iterator5 = _createForOfIteratorHelper(upserts),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var upsert = _step5.value;\n\n          if (this.upserts[upsert.doc._id]) {\n            // Only safely remove upsert if item is unchanged\n            if (lodash_1.default.isEqual(upsert.doc, this.upserts[upsert.doc._id].doc)) {\n              this._deleteUpsert(upsert.doc._id);\n            } else {\n              // Just update base\n              this.upserts[upsert.doc._id].base = upsert.doc;\n\n              this._putUpsert(this.upserts[upsert.doc._id]);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"resolveRemove\",\n    value: function resolveRemove(id, success) {\n      this._deleteRemove(id);\n\n      if (success != null) {\n        return success();\n      }\n    } // Add but do not overwrite or record as upsert\n\n  }, {\n    key: \"seed\",\n    value: function seed(docs, success) {\n      if (!lodash_1.default.isArray(docs)) {\n        docs = [docs];\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(docs),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var doc = _step6.value;\n\n          if (!lodash_1.default.has(this.items, doc._id) && !lodash_1.default.has(this.removes, doc._id)) {\n            this._putItem(doc);\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      if (success != null) {\n        return success();\n      }\n    } // Add but do not overwrite upserts or removes\n\n  }, {\n    key: \"cacheOne\",\n    value: function cacheOne(doc, success, error) {\n      return this.cacheList([doc], success, error);\n    } // Add but do not overwrite upserts or removes\n\n  }, {\n    key: \"cacheList\",\n    value: function cacheList(docs, success, error) {\n      var _iterator7 = _createForOfIteratorHelper(docs),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var doc = _step7.value;\n\n          if (!lodash_1.default.has(this.upserts, doc._id) && !lodash_1.default.has(this.removes, doc._id)) {\n            var existing = this.items[doc._id]; // If _rev present, make sure that not overwritten by lower or equal _rev\n\n            if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n              this._putItem(doc);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"uncache\",\n    value: function uncache(selector, success, error) {\n      var compiledSelector = utils.compileDocumentSelector(selector);\n\n      var _iterator8 = _createForOfIteratorHelper(lodash_1.default.values(this.items)),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var item = _step8.value;\n\n          if (this.upserts[item._id] == null && compiledSelector(item)) {\n            this._deleteItem(item._id);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }, {\n    key: \"uncacheList\",\n    value: function uncacheList(ids, success, error) {\n      var _iterator9 = _createForOfIteratorHelper(ids),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var id = _step9.value;\n\n          if (this.upserts[id] == null) {\n            this._deleteItem(id);\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      if (success != null) {\n        return success();\n      }\n    }\n  }]);\n\n  return Collection;\n}();","map":null,"metadata":{},"sourceType":"script"}