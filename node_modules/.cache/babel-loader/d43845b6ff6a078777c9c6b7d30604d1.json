{"ast":null,"code":"import { getCoord, getCoords } from \"@turf/invariant\";\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\n\nfunction booleanPointOnLine(pt, line, options) {\n  if (options === void 0) {\n    options = {};\n  } // Normalize inputs\n\n\n  var ptCoords = getCoord(pt);\n  var lineCoords = getCoords(line); // Main\n\n  for (var i = 0; i < lineCoords.length - 1; i++) {\n    var ignoreBoundary = false;\n\n    if (options.ignoreEndVertices) {\n      if (i === 0) {\n        ignoreBoundary = \"start\";\n      }\n\n      if (i === lineCoords.length - 2) {\n        ignoreBoundary = \"end\";\n      }\n\n      if (i === 0 && i + 1 === lineCoords.length - 1) {\n        ignoreBoundary = \"both\";\n      }\n    }\n\n    if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n      return true;\n    }\n  }\n\n  return false;\n} // See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\n\n\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n  var x = pt[0];\n  var y = pt[1];\n  var x1 = lineSegmentStart[0];\n  var y1 = lineSegmentStart[1];\n  var x2 = lineSegmentEnd[0];\n  var y2 = lineSegmentEnd[1];\n  var dxc = pt[0] - x1;\n  var dyc = pt[1] - y1;\n  var dxl = x2 - x1;\n  var dyl = y2 - y1;\n  var cross = dxc * dyl - dyc * dxl;\n\n  if (epsilon !== null) {\n    if (Math.abs(cross) > epsilon) {\n      return false;\n    }\n  } else if (cross !== 0) {\n    return false;\n  }\n\n  if (!excludeBoundary) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n    }\n\n    return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n  } else if (excludeBoundary === \"start\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n    }\n\n    return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n  } else if (excludeBoundary === \"end\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n    }\n\n    return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n  } else if (excludeBoundary === \"both\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n    }\n\n    return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n  }\n\n  return false;\n}\n\nexport default booleanPointOnLine;","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/@turf/boolean-point-on-line/dist/es/index.js"],"names":["getCoord","getCoords","booleanPointOnLine","pt","line","options","ptCoords","lineCoords","i","length","ignoreBoundary","ignoreEndVertices","isPointOnLineSegment","epsilon","lineSegmentStart","lineSegmentEnd","excludeBoundary","x","y","x1","y1","x2","y2","dxc","dyc","dxl","dyl","cross","Math","abs"],"mappings":"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","sourcesContent":["import { getCoord, getCoords } from \"@turf/invariant\";\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = getCoord(pt);\n    var lineCoords = getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (epsilon !== null) {\n        if (Math.abs(cross) > epsilon) {\n            return false;\n        }\n    }\n    else if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexport default booleanPointOnLine;\n"]},"metadata":{},"sourceType":"module"}