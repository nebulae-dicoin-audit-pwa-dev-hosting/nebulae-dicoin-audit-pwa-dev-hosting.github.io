{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar async_1 = __importDefault(require(\"async\"));\n\nvar idb_wrapper_1 = __importDefault(require(\"idb-wrapper\"));\n\nvar utils = __importStar(require(\"./utils\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar selector_1 = require(\"./selector\"); // Create a database backed by IndexedDb. options must contain namespace: <string to uniquely identify database>\n\n\nvar IndexedDb = /*#__PURE__*/function () {\n  function IndexedDb(options, success, error) {\n    var _this = this;\n\n    _classCallCheck(this, IndexedDb);\n\n    this.collections = {}; // Create database\n\n    try {\n      this.store = new idb_wrapper_1.default({\n        dbVersion: 1,\n        storeName: \"minimongo_\" + options.namespace,\n        keyPath: [\"col\", \"doc._id\"],\n        autoIncrement: false,\n        onStoreReady: function onStoreReady() {\n          if (success) {\n            return success(_this);\n          }\n        },\n        onError: error,\n        indexes: [{\n          name: \"col\",\n          keyPath: \"col\",\n          unique: false,\n          multiEntry: false\n        }, {\n          name: \"col-state\",\n          keyPath: [\"col\", \"state\"],\n          unique: false,\n          multiEntry: false\n        }]\n      });\n    } catch (ex) {\n      if (error) {\n        error(ex);\n      }\n\n      return;\n    }\n  }\n\n  _createClass(IndexedDb, [{\n    key: \"addCollection\",\n    value: function addCollection(name, success, error) {\n      var collection = new IndexedDbCollection(name, this.store);\n      this[name] = collection;\n      this.collections[name] = collection;\n\n      if (success) {\n        return success();\n      }\n    }\n  }, {\n    key: \"removeCollection\",\n    value: function removeCollection(name, success, error) {\n      var _this2 = this;\n\n      delete this[name];\n      delete this.collections[name]; // Remove all documents\n\n      return this.store.query(function (matches) {\n        var keys = lodash_1.default.map(matches, function (m) {\n          return [m.col, m.doc._id];\n        });\n\n        if (keys.length > 0) {\n          return _this2.store.removeBatch(keys, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      }, {\n        index: \"col\",\n        keyRange: this.store.makeKeyRange({\n          only: name\n        }),\n        onError: error\n      });\n    }\n  }, {\n    key: \"getCollectionNames\",\n    value: function getCollectionNames() {\n      return lodash_1.default.keys(this.collections);\n    }\n  }]);\n\n  return IndexedDb;\n}();\n\nexports.default = IndexedDb; // Stores data in indexeddb store\n\nvar IndexedDbCollection = /*#__PURE__*/function () {\n  function IndexedDbCollection(name, store) {\n    _classCallCheck(this, IndexedDbCollection);\n\n    this.name = name;\n    this.store = store;\n  }\n\n  _createClass(IndexedDbCollection, [{\n    key: \"find\",\n    value: function find(selector, options) {\n      var _this3 = this;\n\n      return {\n        fetch: function fetch(success, error) {\n          return _this3._findFetch(selector, options, success, error);\n        }\n      };\n    }\n  }, {\n    key: \"findOne\",\n    value: function findOne(selector, options, success, error) {\n      if (lodash_1.default.isFunction(options)) {\n        ;\n        var _ref = [{}, options, success];\n        options = _ref[0];\n        success = _ref[1];\n        error = _ref[2];\n      }\n\n      this.find(selector, options).fetch(function (results) {\n        if (success != null) {\n          return success(results.length > 0 ? results[0] : null);\n        }\n      }, error);\n    }\n  }, {\n    key: \"_findFetch\",\n    value: function _findFetch(selector, options, success, error) {\n      // Get all docs from collection\n      return this.store.query(function (matches) {\n        // Filter removed docs\n        matches = lodash_1.default.filter(matches, function (m) {\n          return m.state !== \"removed\";\n        });\n\n        if (success != null) {\n          return success((0, utils_1.processFind)(lodash_1.default.map(matches, \"doc\"), selector, options));\n        }\n      }, {\n        index: \"col\",\n        keyRange: this.store.makeKeyRange({\n          only: this.name\n        }),\n        onError: error\n      });\n    }\n  }, {\n    key: \"upsert\",\n    value: function upsert(docs, bases, success, error) {\n      var _this4 = this;\n\n      var items;\n\n      var _utils$regularizeUpse = utils.regularizeUpsert(docs, bases, success, error);\n\n      var _utils$regularizeUpse2 = _slicedToArray(_utils$regularizeUpse, 3);\n\n      items = _utils$regularizeUpse2[0];\n      success = _utils$regularizeUpse2[1];\n      error = _utils$regularizeUpse2[2];\n      // Get bases\n      var keys = lodash_1.default.map(items, function (item) {\n        return [_this4.name, item.doc._id];\n      });\n      return this.store.getBatch(keys, function (records) {\n        var puts = lodash_1.default.map(items, function (item, i) {\n          // Prefer explicit base\n          var base;\n\n          if (item.base !== undefined) {\n            ;\n            base = item.base;\n          } else if (records[i] && records[i].doc && records[i].state === \"cached\") {\n            base = records[i].doc;\n          } else if (records[i] && records[i].doc && records[i].state === \"upserted\") {\n            ;\n            base = records[i].base;\n          } else {\n            base = null;\n          }\n\n          return {\n            col: _this4.name,\n            state: \"upserted\",\n            doc: item.doc,\n            base: base\n          };\n        });\n        return _this4.store.putBatch(puts, function () {\n          if (success) {\n            return success(docs);\n          }\n        }, error);\n      }, error);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(id, success, error) {\n      var _this5 = this;\n\n      // Special case for filter-type remove\n      if (lodash_1.default.isObject(id)) {\n        this.find(id).fetch(function (rows) {\n          return async_1.default.each(rows, function (row, cb) {\n            _this5.remove(row._id, function () {\n              return cb();\n            }, cb);\n          }, function () {\n            return success();\n          });\n        }, error);\n        return;\n      } // Find record\n\n\n      return this.store.get([this.name, id], function (record) {\n        // If not found, create placeholder record\n        if (record == null) {\n          record = {\n            col: _this5.name,\n            doc: {\n              _id: id\n            }\n          };\n        } // Set removed\n\n\n        record.state = \"removed\"; // Update\n\n        return _this5.store.put(record, function () {\n          if (success) {\n            return success();\n          }\n        }, error);\n      });\n    }\n  }, {\n    key: \"cache\",\n    value: function cache(docs, selector, options, success, error) {\n      var _this6 = this;\n\n      var step2 = function step2() {\n        // Rows have been cached, now look for stale ones to remove\n        var sort;\n        var docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n\n        if (options.sort) {\n          sort = (0, selector_1.compileSort)(options.sort);\n        } // Perform query, removing rows missing in docs from local db\n\n\n        return _this6.find(selector, options).fetch(function (results) {\n          var removes = [];\n          var keys = lodash_1.default.map(results, function (result) {\n            return [_this6.name, result._id];\n          });\n\n          if (keys.length === 0) {\n            if (success != null) {\n              success();\n            }\n\n            return;\n          }\n\n          return _this6.store.getBatch(keys, function (records) {\n            for (var i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n              var record = records[i];\n              var result = results[i]; // If not present in docs and is present locally and not upserted/deleted\n\n              if (!docsMap[result._id] && record && record.state === \"cached\") {\n                // If at limit\n                if (options.limit && docs.length === options.limit) {\n                  // If past end on sorted limited, ignore\n                  if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n                    continue;\n                  } // If no sort, ignore\n\n\n                  if (!options.sort) {\n                    continue;\n                  }\n                } // Exclude any excluded _ids from being cached/uncached\n\n\n                if (options && options.exclude && options.exclude.includes(result._id)) {\n                  continue;\n                } // Item is gone from server, remove locally\n\n\n                removes.push([_this6.name, result._id]);\n              }\n            } // If removes, handle them\n\n\n            if (removes.length > 0) {\n              return _this6.store.removeBatch(removes, function () {\n                if (success != null) {\n                  return success();\n                }\n              }, error);\n            } else {\n              if (success != null) {\n                return success();\n              }\n            }\n          }, error);\n        }, error);\n      };\n\n      if (docs.length === 0) {\n        return step2();\n      } // Create keys to get items\n\n\n      var keys = lodash_1.default.map(docs, function (doc) {\n        return [_this6.name, doc._id];\n      }); // Create batch of puts\n\n      var puts = [];\n      return this.store.getBatch(keys, function (records) {\n        // Add all non-local that are not upserted or removed\n        for (var i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          var record = records[i];\n          var doc = docs[i]; // Check if not present or not upserted/deleted\n\n          if (record == null || record.state === \"cached\") {\n            if (options && options.exclude && options.exclude.includes(doc._id)) {\n              continue;\n            } // If _rev present, make sure that not overwritten by lower or equal _rev\n\n\n            if (!record || !doc._rev || !record.doc._rev || doc._rev > record.doc._rev) {\n              puts.push({\n                col: _this6.name,\n                state: \"cached\",\n                doc: doc\n              });\n            }\n          }\n        } // Put batch\n\n\n        if (puts.length > 0) {\n          return _this6.store.putBatch(puts, step2, error);\n        } else {\n          return step2();\n        }\n      }, error);\n    }\n  }, {\n    key: \"pendingUpserts\",\n    value: function pendingUpserts(success, error) {\n      return this.store.query(function (matches) {\n        var upserts = lodash_1.default.map(matches, function (m) {\n          return {\n            doc: m.doc,\n            base: m.base || null\n          };\n        });\n\n        if (success != null) {\n          return success(upserts);\n        }\n      }, {\n        index: \"col-state\",\n        keyRange: this.store.makeKeyRange({\n          only: [this.name, \"upserted\"]\n        }),\n        onError: error\n      });\n    }\n  }, {\n    key: \"pendingRemoves\",\n    value: function pendingRemoves(success, error) {\n      return this.store.query(function (matches) {\n        if (success != null) {\n          return success(lodash_1.default.map(lodash_1.default.map(matches, \"doc\"), \"_id\"));\n        }\n      }, {\n        index: \"col-state\",\n        keyRange: this.store.makeKeyRange({\n          only: [this.name, \"removed\"]\n        }),\n        onError: error\n      });\n    }\n  }, {\n    key: \"resolveUpserts\",\n    value: function resolveUpserts(upserts, success, error) {\n      var _this7 = this;\n\n      // Get items\n      var keys = lodash_1.default.map(upserts, function (upsert) {\n        return [_this7.name, upsert.doc._id];\n      });\n      return this.store.getBatch(keys, function (records) {\n        var puts = [];\n\n        for (var i = 0, end = upserts.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          var record = records[i]; // Only safely remove upsert if doc is the same\n\n          if (record && record.state === \"upserted\") {\n            if (lodash_1.default.isEqual(record.doc, upserts[i].doc)) {\n              record.state = \"cached\";\n              puts.push(record);\n            } else {\n              record.base = upserts[i].doc;\n              puts.push(record);\n            }\n          }\n        } // Put all changed items\n\n\n        if (puts.length > 0) {\n          return _this7.store.putBatch(puts, function () {\n            if (success) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success) {\n            return success();\n          }\n        }\n      }, error);\n    }\n  }, {\n    key: \"resolveRemove\",\n    value: function resolveRemove(id, success, error) {\n      var _this8 = this;\n\n      return this.store.get([this.name, id], function (record) {\n        // Check if exists\n        if (!record) {\n          if (success != null) {\n            success();\n          }\n\n          return;\n        } // Only remove if removed\n\n\n        if (record.state === \"removed\") {\n          return _this8.store.remove([_this8.name, id], function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        }\n      });\n    } // Add but do not overwrite or record as upsert\n\n  }, {\n    key: \"seed\",\n    value: function seed(docs, success, error) {\n      var _this9 = this;\n\n      if (!lodash_1.default.isArray(docs)) {\n        docs = [docs];\n      } // Create keys to get items\n\n\n      var keys = lodash_1.default.map(docs, function (doc) {\n        return [_this9.name, doc._id];\n      }); // Create batch of puts\n\n      var puts = [];\n      return this.store.getBatch(keys, function (records) {\n        // Add all non-local that are not upserted or removed\n        for (var i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          var record = records[i];\n          var doc = docs[i]; // Check if not present\n\n          if (record == null) {\n            puts.push({\n              col: _this9.name,\n              state: \"cached\",\n              doc: doc\n            });\n          }\n        } // Put batch\n\n\n        if (puts.length > 0) {\n          return _this9.store.putBatch(puts, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      }, error);\n    } // Add but do not overwrite upsert/removed and do not record as upsert\n\n  }, {\n    key: \"cacheOne\",\n    value: function cacheOne(doc, success, error) {\n      return this.cacheList([doc], success, error);\n    }\n  }, {\n    key: \"cacheList\",\n    value: function cacheList(docs, success, error) {\n      var _this10 = this;\n\n      // Create keys to get items\n      var keys = lodash_1.default.map(docs, function (doc) {\n        return [_this10.name, doc._id];\n      }); // Create batch of puts\n\n      var puts = [];\n      return this.store.getBatch(keys, function (records) {\n        for (var i = 0, end = records.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          var record = records[i];\n          var doc = docs[i]; // If _rev present, make sure that not overwritten by lower equal _rev\n\n          if (record && doc._rev && record.doc._rev && doc._rev <= record.doc._rev) {\n            continue;\n          }\n\n          if (record == null) {\n            record = {\n              col: _this10.name,\n              state: \"cached\",\n              doc: doc\n            };\n          }\n\n          if (record.state === \"cached\") {\n            record.doc = doc;\n            puts.push(record);\n          }\n        } // Put batch\n\n\n        if (puts.length > 0) {\n          return _this10.store.putBatch(puts, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      }, error);\n    }\n  }, {\n    key: \"uncache\",\n    value: function uncache(selector, success, error) {\n      var _this11 = this;\n\n      var compiledSelector = utils.compileDocumentSelector(selector); // Get all docs from collection\n\n      return this.store.query(function (matches) {\n        // Filter ones to remove\n        matches = lodash_1.default.filter(matches, function (m) {\n          return m.state === \"cached\" && compiledSelector(m.doc);\n        });\n        var keys = lodash_1.default.map(matches, function (m) {\n          return [_this11.name, m.doc._id];\n        });\n\n        if (keys.length > 0) {\n          return _this11.store.removeBatch(keys, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      }, {\n        index: \"col\",\n        keyRange: this.store.makeKeyRange({\n          only: this.name\n        }),\n        onError: error\n      });\n    }\n  }, {\n    key: \"uncacheList\",\n    value: function uncacheList(ids, success, error) {\n      var _this12 = this;\n\n      var idIndex = lodash_1.default.keyBy(ids); // Android 2.x requires error callback\n\n      error = error || function () {}; // Get all docs from collection\n\n\n      return this.store.query(function (matches) {\n        // Filter ones to remove\n        matches = lodash_1.default.filter(matches, function (m) {\n          return m.state === \"cached\" && idIndex[m.doc._id];\n        });\n        var keys = lodash_1.default.map(matches, function (m) {\n          return [_this12.name, m.doc._id];\n        });\n\n        if (keys.length > 0) {\n          return _this12.store.removeBatch(keys, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      }, {\n        index: \"col\",\n        keyRange: this.store.makeKeyRange({\n          only: this.name\n        }),\n        onError: error\n      });\n    }\n  }]);\n\n  return IndexedDbCollection;\n}();","map":null,"metadata":{},"sourceType":"script"}