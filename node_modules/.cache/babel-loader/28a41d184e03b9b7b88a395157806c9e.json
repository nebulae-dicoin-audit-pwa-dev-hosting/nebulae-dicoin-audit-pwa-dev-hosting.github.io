{"ast":null,"code":"/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Version 1.7.2\n * Copyright (c) 2011 - 2017 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT license\n */\n(function (name, definition, global) {\n  'use strict';\n\n  if (typeof define === 'function') {\n    define(definition);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = definition();\n  } else {\n    global[name] = definition();\n  }\n})('IDBStore', function () {\n  'use strict';\n\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n\n  var defaultSuccessHandler = function () {};\n\n  var defaults = {\n    storeName: 'Store',\n    storePrefix: 'IDBWrapper-',\n    dbVersion: 1,\n    keyPath: 'id',\n    autoIncrement: true,\n    onStoreReady: function () {},\n    onError: defaultErrorHandler,\n    indexes: [],\n    implementationPreference: ['indexedDB', 'webkitIndexedDB', 'mozIndexedDB', 'shimIndexedDB']\n  };\n  /**\n   *\n   * The IDBStore constructor\n   *\n   * @constructor\n   * @name IDBStore\n   * @version 1.7.2\n   *\n   * @param {Object} [kwArgs] An options object used to configure the store and\n   *  set callbacks\n   * @param {String} [kwArgs.storeName='Store'] The name of the store\n   * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n   *  internally used to construct the name of the database, which will be\n   *  kwArgs.storePrefix + kwArgs.storeName\n   * @param {Number} [kwArgs.dbVersion=1] The version of the store\n   * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n   *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n   *  `null`\n   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n   *  automatically make sure a unique keyPath value is present on each object\n   *  that is stored.\n   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n   *  store is ready to be used.\n   * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n   *  error occurred during instantiation of the store.\n   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n   *  defining the indexes to use with the store. For every index to be used\n   *  one indexData object needs to be passed in the array.\n   *  An indexData object is defined as follows:\n   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n   *  use\n   * @param {String} kwArgs.indexes.indexData.name The name of the index\n   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n   * @param {Array} [kwArgs.implementationPreference=['indexedDB','webkitIndexedDB','mozIndexedDB','shimIndexedDB']] An array of strings naming implementations to be used, in order or preference\n   * @param {Function} [onStoreReady] A callback to be called when the store\n   * is ready to be used.\n   * @example\n   // create a store for customers with an additional index over the\n   // `lastname` property.\n   var myCustomerStore = new IDBStore({\n       dbVersion: 1,\n       storeName: 'customer-index',\n       keyPath: 'customerid',\n       autoIncrement: true,\n       onStoreReady: populateTable,\n       indexes: [\n           { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n       ]\n   });\n   * @example\n   // create a generic store\n   var myCustomerStore = new IDBStore({\n       storeName: 'my-data-store',\n       onStoreReady: function(){\n           // start working with the store.\n       }\n   });\n   */\n\n  var IDBStore = function (kwArgs, onStoreReady) {\n    if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n      onStoreReady = kwArgs;\n    }\n\n    if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n      kwArgs = {};\n    }\n\n    for (var key in defaults) {\n      this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n    }\n\n    this.dbName = this.storePrefix + this.storeName;\n    this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n    onStoreReady && (this.onStoreReady = onStoreReady);\n    var env = typeof window == 'object' ? window : self;\n    var availableImplementations = this.implementationPreference.filter(function (implName) {\n      return implName in env;\n    });\n    this.implementation = availableImplementations[0];\n    this.idb = env[this.implementation];\n    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n    this.consts = {\n      'READ_ONLY': 'readonly',\n      'READ_WRITE': 'readwrite',\n      'VERSION_CHANGE': 'versionchange',\n      'NEXT': 'next',\n      'NEXT_NO_DUPLICATE': 'nextunique',\n      'PREV': 'prev',\n      'PREV_NO_DUPLICATE': 'prevunique'\n    };\n    this.openDB();\n  };\n  /** @lends IDBStore.prototype */\n\n\n  var proto = {\n    /**\n     * A pointer to the IDBStore ctor\n     *\n     * @private\n     * @type {Function}\n     * @constructs\n     */\n    constructor: IDBStore,\n\n    /**\n     * The version of IDBStore\n     *\n     * @type {String}\n     */\n    version: '1.7.2',\n\n    /**\n     * A reference to the IndexedDB object\n     *\n     * @type {IDBDatabase}\n     */\n    db: null,\n\n    /**\n     * The full name of the IndexedDB used by IDBStore, composed of\n     * this.storePrefix + this.storeName\n     *\n     * @type {String}\n     */\n    dbName: null,\n\n    /**\n     * The version of the IndexedDB used by IDBStore\n     *\n     * @type {Number}\n     */\n    dbVersion: null,\n\n    /**\n     * A reference to the objectStore used by IDBStore\n     *\n     * @type {IDBObjectStore}\n     */\n    store: null,\n\n    /**\n     * The store name\n     *\n     * @type {String}\n     */\n    storeName: null,\n\n    /**\n     * The prefix to prepend to the store name\n     *\n     * @type {String}\n     */\n    storePrefix: null,\n\n    /**\n     * The key path\n     *\n     * @type {String}\n     */\n    keyPath: null,\n\n    /**\n     * Whether IDBStore uses autoIncrement\n     *\n     * @type {Boolean}\n     */\n    autoIncrement: null,\n\n    /**\n     * The indexes used by IDBStore\n     *\n     * @type {Array}\n     */\n    indexes: null,\n\n    /**\n     * The implemantations to try to use, in order of preference\n     *\n     * @type {Array}\n     */\n    implementationPreference: null,\n\n    /**\n     * The actual implementation being used\n     *\n     * @type {String}\n     */\n    implementation: '',\n\n    /**\n     * The callback to be called when the store is ready to be used\n     *\n     * @type {Function}\n     */\n    onStoreReady: null,\n\n    /**\n     * The callback to be called if an error occurred during instantiation\n     * of the store\n     *\n     * @type {Function}\n     */\n    onError: null,\n\n    /**\n     * The internal insertID counter\n     *\n     * @type {Number}\n     * @private\n     */\n    _insertIdCount: 0,\n\n    /**\n     * Opens an IndexedDB; called by the constructor.\n     *\n     * Will check if versions match and compare provided index configuration\n     * with existing ones, and update indexes if necessary.\n     *\n     * Will call this.onStoreReady() if everything went well and the store\n     * is ready to use, and this.onError() is something went wrong.\n     *\n     * @private\n     *\n     */\n    openDB: function () {\n      var openRequest = this.idb.open(this.dbName, this.dbVersion);\n      var preventSuccessCallback = false;\n\n      openRequest.onerror = function (errorEvent) {\n        if (hasVersionError(errorEvent)) {\n          this.onError(new Error('The version number provided is lower than the existing one.'));\n        } else {\n          var error;\n\n          if (errorEvent.target.error) {\n            error = errorEvent.target.error;\n          } else {\n            var errorMessage = 'IndexedDB unknown error occurred when opening DB ' + this.dbName + ' version ' + this.dbVersion;\n\n            if ('errorCode' in errorEvent.target) {\n              errorMessage += ' with error code ' + errorEvent.target.errorCode;\n            }\n\n            error = new Error(errorMessage);\n          }\n\n          this.onError(error);\n        }\n      }.bind(this);\n\n      openRequest.onsuccess = function (event) {\n        if (preventSuccessCallback) {\n          return;\n        }\n\n        if (this.db) {\n          this.onStoreReady();\n          return;\n        }\n\n        this.db = event.target.result;\n\n        if (typeof this.db.version == 'string') {\n          this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n          return;\n        }\n\n        if (!this.db.objectStoreNames.contains(this.storeName)) {\n          // We should never ever get here.\n          // Lets notify the user anyway.\n          this.onError(new Error('Object store couldn\\'t be created.'));\n          return;\n        }\n\n        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n        this.store = emptyTransaction.objectStore(this.storeName); // check indexes\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function (indexData) {\n          var indexName = indexData.name;\n\n          if (!indexName) {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n            return;\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if (this.hasIndex(indexName)) {\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n\n            if (!complies) {\n              preventSuccessCallback = true;\n              this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n          }\n        }, this);\n\n        if (existingIndexes.length) {\n          preventSuccessCallback = true;\n          this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n        }\n\n        preventSuccessCallback || this.onStoreReady();\n      }.bind(this);\n\n      openRequest.onupgradeneeded = function (\n      /* IDBVersionChangeEvent */\n      event) {\n        this.db = event.target.result;\n\n        if (this.db.objectStoreNames.contains(this.storeName)) {\n          this.store = event.target.transaction.objectStore(this.storeName);\n        } else {\n          var optionalParameters = {\n            autoIncrement: this.autoIncrement\n          };\n\n          if (this.keyPath !== null) {\n            optionalParameters.keyPath = this.keyPath;\n          }\n\n          this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n        }\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function (indexData) {\n          var indexName = indexData.name;\n\n          if (!indexName) {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if (this.hasIndex(indexName)) {\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n\n            if (!complies) {\n              // index differs, need to delete and re-create\n              this.store.deleteIndex(indexName);\n              this.store.createIndex(indexName, indexData.keyPath, {\n                unique: indexData.unique,\n                multiEntry: indexData.multiEntry\n              });\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            this.store.createIndex(indexName, indexData.keyPath, {\n              unique: indexData.unique,\n              multiEntry: indexData.multiEntry\n            });\n          }\n        }, this);\n\n        if (existingIndexes.length) {\n          existingIndexes.forEach(function (_indexName) {\n            this.store.deleteIndex(_indexName);\n          }, this);\n        }\n      }.bind(this);\n    },\n\n    /**\n     * Deletes the database used for this store if the IDB implementations\n     * provides that functionality.\n     *\n     * @param {Function} [onSuccess] A callback that is called if deletion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if deletion\n     *  failed.\n     */\n    deleteDatabase: function (onSuccess, onError) {\n      if (this.idb.deleteDatabase) {\n        this.db.close();\n        var deleteRequest = this.idb.deleteDatabase(this.dbName);\n        deleteRequest.onsuccess = onSuccess;\n        deleteRequest.onerror = onError;\n      } else {\n        onError(new Error('Browser does not support IndexedDB deleteDatabase!'));\n      }\n    },\n\n    /*********************\n     * data manipulation *\n     *********************/\n\n    /**\n     * Puts an object into the store. If an entry with the given id exists,\n     * it will be overwritten. This method has a different signature for inline\n     * keys and out-of-line keys; please see the examples below.\n     *\n     * @param {*} [key] The key to store. This is only needed if IDBWrapper\n     *  is set to use out-of-line keys. For inline keys - the default scenario -\n     *  this can be omitted.\n     * @param {Object} value The data object to store.\n     * @param {Function} [onSuccess] A callback that is called if insertion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if insertion\n     *  failed.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // Storing an object, using inline keys (the default scenario):\n     var myCustomer = {\n         customerid: 2346223,\n         lastname: 'Doe',\n         firstname: 'John'\n     };\n     myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n     // Note that passing success- and error-handlers is optional.\n     * @example\n     // Storing an object, using out-of-line keys:\n     var myCustomer = {\n         lastname: 'Doe',\n         firstname: 'John'\n     };\n     myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n     // Note that passing success- and error-handlers is optional.\n     */\n    put: function (key, value, onSuccess, onError) {\n      if (this.keyPath !== null) {\n        onError = onSuccess;\n        onSuccess = value;\n        value = key;\n      }\n\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null,\n          putRequest;\n      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      putTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      putTransaction.onabort = onError;\n      putTransaction.onerror = onError;\n\n      if (this.keyPath !== null) {\n        // in-line keys\n        this._addIdPropertyIfNeeded(value);\n\n        putRequest = putTransaction.objectStore(this.storeName).put(value);\n      } else {\n        // out-of-line keys\n        putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n      }\n\n      putRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      putRequest.onerror = onError;\n      return putTransaction;\n    },\n\n    /**\n     * Retrieves an object from the store. If no entry exists with the given id,\n     * the success handler will be called with null as first and only argument.\n     *\n     * @param {*} key The id of the object to fetch.\n     * @param {Function} [onSuccess] A callback that is called if fetching\n     *  was successful. Will receive the object as only argument.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    get: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null;\n      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n\n      getTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      getTransaction.onabort = onError;\n      getTransaction.onerror = onError;\n      var getRequest = getTransaction.objectStore(this.storeName).get(key);\n\n      getRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      getRequest.onerror = onError;\n      return getTransaction;\n    },\n\n    /**\n     * Removes an object from the store.\n     *\n     * @param {*} key The id of the object to remove.\n     * @param {Function} [onSuccess] A callback that is called if the removal\n     *  was successful.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    remove: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null;\n      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      removeTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      removeTransaction.onabort = onError;\n      removeTransaction.onerror = onError;\n      var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n\n      deleteRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      deleteRequest.onerror = onError;\n      return removeTransaction;\n    },\n\n    /**\n     * Runs a batch of put and/or remove operations on the store.\n     *\n     * @param {Array} dataArray An array of objects containing the operation to run\n     *  and the data object (for put operations).\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    batch: function (dataArray, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n\n      if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n        onError(new Error('dataArray argument must be of type Array.'));\n      } else if (dataArray.length === 0) {\n        return onSuccess(true);\n      }\n\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(hasSuccess);\n      };\n\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function () {\n        count--;\n\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (operation) {\n        var type = operation.type;\n        var key = operation.key;\n        var value = operation.value;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n\n          if (!called) {\n            called = true;\n            onError(err, type, key);\n          }\n        };\n\n        if (type == 'remove') {\n          var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n          deleteRequest.onsuccess = onItemSuccess;\n          deleteRequest.onerror = onItemError;\n        } else if (type == 'put') {\n          var putRequest;\n\n          if (this.keyPath !== null) {\n            // in-line keys\n            this._addIdPropertyIfNeeded(value);\n\n            putRequest = batchTransaction.objectStore(this.storeName).put(value);\n          } else {\n            // out-of-line keys\n            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n          }\n\n          putRequest.onsuccess = onItemSuccess;\n          putRequest.onerror = onItemError;\n        }\n      }, this);\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of objects and stores them in a single transaction.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    putBatch: function (dataArray, onSuccess, onError) {\n      var batchData = dataArray.map(function (item) {\n        return {\n          type: 'put',\n          value: item\n        };\n      });\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Like putBatch, takes an array of objects and stores them in a single\n     * transaction, but allows processing of the result values.  Returns the\n     * processed records containing the key for newly created records to the\n     * onSuccess calllback instead of only returning true or false for success.\n     * In addition, added the option for the caller to specify a key field that\n     * should be set to the newly created key.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Object} [options] An object containing optional options\n     * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update\n     *  with the auto-incrementing key. Defaults to the store's keyPath.\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     *\n     */\n    upsertBatch: function (dataArray, options, onSuccess, onError) {\n      // handle `dataArray, onSuccess, onError` signature\n      if (typeof options == 'function') {\n        onSuccess = options;\n        onError = onSuccess;\n        options = {};\n      }\n\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      options || (options = {});\n\n      if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n        onError(new Error('dataArray argument must be of type Array.'));\n      }\n\n      var keyField = options.keyField || this.keyPath;\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var index = 0; // assume success callbacks are executed in order\n\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      batchTransaction.oncomplete = function () {\n        if (hasSuccess) {\n          onSuccess(dataArray);\n        } else {\n          onError(false);\n        }\n      };\n\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function (event) {\n        var record = dataArray[index++];\n        record[keyField] = event.target.result;\n        count--;\n\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (record) {\n        var key = record.key;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n\n          if (!called) {\n            called = true;\n            onError(err);\n          }\n        };\n\n        var putRequest;\n\n        if (this.keyPath !== null) {\n          // in-line keys\n          this._addIdPropertyIfNeeded(record);\n\n          putRequest = batchTransaction.objectStore(this.storeName).put(record);\n        } else {\n          // out-of-line keys\n          putRequest = batchTransaction.objectStore(this.storeName).put(record, key);\n        }\n\n        putRequest.onsuccess = onItemSuccess;\n        putRequest.onerror = onItemError;\n      }, this);\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of keys and removes matching objects in a single\n     * transaction.\n     *\n     * @param {Array} keyArray An array of keys to remove\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    removeBatch: function (keyArray, onSuccess, onError) {\n      var batchData = keyArray.map(function (key) {\n        return {\n          type: 'remove',\n          key: key\n        };\n      });\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and fetches matching objects\n     *\n     * @param {Array} keyArray An array of keys identifying the objects to fetch\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @param {String} [arrayType='sparse'] The type of array to pass to the\n     *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n     *  'sparse'. This parameter specifies how to handle the situation if a get\n     *  operation did not throw an error, but there was no matching object in\n     *  the database. In most cases, 'sparse' provides the most desired\n     *  behavior. See the examples for details.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // given that there are two objects in the database with the keypath\n     // values 1 and 2, and the call looks like this:\n     myStore.getBatch([1, 5, 2], onError, function (data) { … }, arrayType);\n      // this is what the `data` array will be like:\n      // arrayType == 'sparse':\n     // data is a sparse array containing two entries and having a length of 3:\n     [Object, 2: Object]\n     0: Object\n     2: Object\n     length: 3\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter matching the index of the key in the\n     // keyArray.\n      // arrayType == 'dense':\n     // data is a dense array containing three entries and having a length of 3,\n     // where data[1] is of type undefined:\n     [Object, undefined, Object]\n     0: Object\n     1: undefined\n     2: Object\n     length: 3\n     // calling forEach on data will result in the callback being called three\n     // times, with the index parameter matching the index of the key in the\n     // keyArray, but the second call will have undefined as first argument.\n      // arrayType == 'skip':\n     // data is a dense array containing two entries and having a length of 2:\n     [Object, Object]\n     0: Object\n     1: Object\n     length: 2\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter not matching the index of the key in the\n     // keyArray.\n     */\n    getBatch: function (keyArray, onSuccess, onError, arrayType) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      arrayType || (arrayType = 'sparse');\n\n      if (Object.prototype.toString.call(keyArray) != '[object Array]') {\n        onError(new Error('keyArray argument must be of type Array.'));\n      } else if (keyArray.length === 0) {\n        return onSuccess([]);\n      }\n\n      var data = [];\n      var count = keyArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var result = null;\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function (event) {\n        if (event.target.result || arrayType == 'dense') {\n          data.push(event.target.result);\n        } else if (arrayType == 'sparse') {\n          data.length++;\n        }\n\n        count--;\n\n        if (count === 0) {\n          called = true;\n          hasSuccess = true;\n          result = data;\n        }\n      };\n\n      keyArray.forEach(function (key) {\n        var onItemError = function (err) {\n          called = true;\n          result = err;\n          onError(err);\n          batchTransaction.abort();\n        };\n\n        var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n        getRequest.onsuccess = onItemSuccess;\n        getRequest.onerror = onItemError;\n      }, this);\n      return batchTransaction;\n    },\n\n    /**\n     * Fetches all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that is called if the operation\n     *  was successful. Will receive an array of objects.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    getAll: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      var store = getAllTransaction.objectStore(this.storeName);\n\n      if (store.getAll) {\n        this._getAllNative(getAllTransaction, store, onSuccess, onError);\n      } else {\n        this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n      }\n\n      return getAllTransaction;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that have a non-standard\n     * getAll() method.\n     *\n     * @param {IDBTransaction} getAllTransaction An open READ transaction.\n     * @param {IDBObjectStore} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n      var hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n      var getAllRequest = store.getAll();\n\n      getAllRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      getAllRequest.onerror = onError;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that do not have a getAll()\n     * method.\n     *\n     * @param {IDBTransaction} getAllTransaction An open READ transaction.\n     * @param {IDBObjectStore} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n      var all = [],\n          hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n      var cursorRequest = store.openCursor();\n\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n\n        if (cursor) {\n          all.push(cursor.value);\n          cursor['continue']();\n        } else {\n          hasSuccess = true;\n          result = all;\n        }\n      };\n\n      cursorRequest.onError = onError;\n    },\n\n    /**\n     * Clears the store, i.e. deletes all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} [onError] A callback that will be called if an\n     *  error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    clear: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null;\n      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      clearTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      clearTransaction.onabort = onError;\n      clearTransaction.onerror = onError;\n      var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n\n      clearRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      clearRequest.onerror = onError;\n      return clearTransaction;\n    },\n\n    /**\n     * Checks if an id property needs to present on a object and adds one if\n     * necessary.\n     *\n     * @param {Object} dataObj The data object that is about to be stored\n     * @private\n     */\n    _addIdPropertyIfNeeded: function (dataObj) {\n      if (typeof dataObj[this.keyPath] == 'undefined') {\n        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n      }\n    },\n\n    /************\n     * indexing *\n     ************/\n\n    /**\n     * Returns a DOMStringList of index names of the store.\n     *\n     * @return {DOMStringList} The list of index names\n     */\n    getIndexList: function () {\n      return this.store.indexNames;\n    },\n\n    /**\n     * Checks if an index with the given name exists in the store.\n     *\n     * @param {String} indexName The name of the index to look for\n     * @return {Boolean} Whether the store contains an index with the given name\n     */\n    hasIndex: function (indexName) {\n      return this.store.indexNames.contains(indexName);\n    },\n\n    /**\n     * Normalizes an object containing index data and assures that all\n     * properties are set.\n     *\n     * @param {Object} indexData The index data object to normalize\n     * @param {String} indexData.name The name of the index\n     * @param {String} [indexData.keyPath] The key path of the index\n     * @param {Boolean} [indexData.unique] Whether the index is unique\n     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n     */\n    normalizeIndexData: function (indexData) {\n      indexData.keyPath = indexData.keyPath || indexData.name;\n      indexData.unique = !!indexData.unique;\n      indexData.multiEntry = !!indexData.multiEntry;\n    },\n\n    /**\n     * Checks if an actual index complies with an expected index.\n     *\n     * @param {IDBIndex} actual The actual index found in the store\n     * @param {Object} expected An Object describing an expected index\n     * @return {Boolean} Whether both index definitions are identical\n     */\n    indexComplies: function (actual, expected) {\n      var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n        // IE10 returns undefined for no multiEntry\n        if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n          return true;\n        } // Compound keys\n\n\n        if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n          var exp = expected.keyPath;\n          var act = actual.keyPath; // IE10 can't handle keyPath sequences and stores them as a string.\n          // The index will be unusable there, but let's still return true if\n          // the keyPath sequence matches.\n\n          if (typeof act == 'string') {\n            return exp.toString() == act;\n          } // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n          // as Array\n\n\n          if (!(typeof act.contains == 'function' || typeof act.indexOf == 'function')) {\n            return false;\n          }\n\n          if (act.length !== exp.length) {\n            return false;\n          }\n\n          for (var i = 0, m = exp.length; i < m; i++) {\n            if (!(act.contains && act.contains(exp[i]) || act.indexOf(exp[i] !== -1))) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n        return expected[key] == actual[key];\n      });\n      return complies;\n    },\n\n    /**********\n     * cursor *\n     **********/\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem A callback to be called for each match\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.autoContinue=true] Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @param {Boolean} [options.allowItemRejection=false] Allows the onItem\n     * function to return a Boolean to accept or reject the current item\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    iterate: function (onItem, options) {\n      options = mixin({\n        index: null,\n        order: 'ASC',\n        autoContinue: true,\n        filterDuplicates: false,\n        keyRange: null,\n        writeAccess: false,\n        onEnd: null,\n        onError: defaultErrorHandler,\n        limit: Infinity,\n        offset: 0,\n        allowItemRejection: false\n      }, options || {});\n      var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n\n      if (options.filterDuplicates) {\n        directionType += '_NO_DUPLICATE';\n      }\n\n      var hasSuccess = false;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      var recordCount = 0;\n\n      cursorTransaction.oncomplete = function () {\n        if (!hasSuccess) {\n          options.onError(null);\n          return;\n        }\n\n        if (options.onEnd) {\n          options.onEnd();\n        } else {\n          onItem(null);\n        }\n      };\n\n      cursorTransaction.onabort = options.onError;\n      cursorTransaction.onerror = options.onError;\n      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n      cursorRequest.onerror = options.onError;\n\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n\n        if (cursor) {\n          if (options.offset) {\n            cursor.advance(options.offset);\n            options.offset = 0;\n          } else {\n            var onItemReturn = onItem(cursor.value, cursor, cursorTransaction);\n\n            if (!options.allowItemRejection || onItemReturn !== false) {\n              recordCount++;\n            }\n\n            if (options.autoContinue) {\n              if (recordCount + options.offset < options.limit) {\n                cursor['continue']();\n              } else {\n                hasSuccess = true;\n              }\n            }\n          }\n        } else {\n          hasSuccess = true;\n        }\n      };\n\n      return cursorTransaction;\n    },\n\n    /**\n     * Runs a query against the store and passes an array containing matched\n     * objects to the success handler.\n     *\n     * @param {Function} onSuccess A callback to be called when the operation\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @param {Function} [options.filter=null] A custom filter function to\n     *  apply to query resuts before returning. Must return `false` to reject\n     *  an item. Can be combined with keyRanges.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    query: function (onSuccess, options) {\n      var result = [],\n          processedItems = 0;\n      options = options || {};\n      options.autoContinue = true;\n      options.writeAccess = false;\n      options.allowItemRejection = !!options.filter;\n\n      options.onEnd = function () {\n        onSuccess(result, processedItems);\n      };\n\n      return this.iterate(function (item) {\n        processedItems++;\n        var accept = options.filter ? options.filter(item) : true;\n\n        if (accept !== false) {\n          result.push(item);\n        }\n\n        return accept;\n      }, options);\n    },\n\n    /**\n     *\n     * Runs a query against the store, but only returns the number of matches\n     * instead of the matches itself.\n     *\n     * @param {Function} onSuccess A callback to be called if the opration\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    count: function (onSuccess, options) {\n      options = mixin({\n        index: null,\n        keyRange: null\n      }, options || {});\n      var onError = options.onError || defaultErrorHandler;\n      var hasSuccess = false,\n          result = null;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n\n      cursorTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      cursorTransaction.onabort = onError;\n      cursorTransaction.onerror = onError;\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      var countRequest = cursorTarget.count(options.keyRange);\n\n      countRequest.onsuccess = function (evt) {\n        hasSuccess = true;\n        result = evt.target.result;\n      };\n\n      countRequest.onError = onError;\n      return cursorTransaction;\n    },\n\n    /**************/\n\n    /* key ranges */\n\n    /**************/\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {IDBKeyRange} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function (options) {\n      /*jshint onecase:true */\n      var keyRange,\n          hasLower = typeof options.lower != 'undefined',\n          hasUpper = typeof options.upper != 'undefined',\n          isOnly = typeof options.only != 'undefined';\n\n      switch (true) {\n        case isOnly:\n          keyRange = this.keyRange.only(options.only);\n          break;\n\n        case hasLower && hasUpper:\n          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n          break;\n\n        case hasLower:\n          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n          break;\n\n        case hasUpper:\n          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n          break;\n\n        default:\n          throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n      }\n\n      return keyRange;\n    }\n  };\n  /** helpers **/\n\n  var empty = {};\n\n  function mixin(target, source) {\n    var name, s;\n\n    for (name in source) {\n      s = source[name];\n\n      if (s !== empty[name] && s !== target[name]) {\n        target[name] = s;\n      }\n    }\n\n    return target;\n  }\n\n  function hasVersionError(errorEvent) {\n    if ('error' in errorEvent.target) {\n      return errorEvent.target.error.name == 'VersionError';\n    } else if ('errorCode' in errorEvent.target) {\n      return errorEvent.target.errorCode == 12;\n    }\n\n    return false;\n  }\n\n  IDBStore.prototype = proto;\n  IDBStore.version = proto.version;\n  return IDBStore;\n}, this);","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/idb-wrapper/idbstore.js"],"names":["name","definition","global","define","module","exports","defaultErrorHandler","error","defaultSuccessHandler","defaults","storeName","storePrefix","dbVersion","keyPath","autoIncrement","onStoreReady","onError","indexes","implementationPreference","IDBStore","kwArgs","Object","prototype","toString","call","key","dbName","parseInt","env","window","self","availableImplementations","filter","implName","implementation","idb","keyRange","IDBKeyRange","webkitIDBKeyRange","mozIDBKeyRange","consts","openDB","proto","constructor","version","db","store","_insertIdCount","openRequest","open","preventSuccessCallback","onerror","errorEvent","hasVersionError","Error","target","errorMessage","errorCode","bind","onsuccess","event","result","objectStoreNames","contains","emptyTransaction","transaction","READ_ONLY","objectStore","existingIndexes","Array","slice","getIndexList","forEach","indexData","indexName","normalizeIndexData","hasIndex","actualIndex","index","complies","indexComplies","splice","indexOf","length","onupgradeneeded","optionalParameters","createObjectStore","deleteIndex","createIndex","unique","multiEntry","_indexName","deleteDatabase","onSuccess","close","deleteRequest","put","value","hasSuccess","putRequest","putTransaction","READ_WRITE","oncomplete","callback","onabort","_addIdPropertyIfNeeded","get","getTransaction","getRequest","remove","removeTransaction","batch","dataArray","count","called","batchTransaction","onItemSuccess","operation","type","onItemError","err","abort","putBatch","batchData","map","item","upsertBatch","options","keyField","record","removeBatch","keyArray","getBatch","arrayType","data","push","getAll","getAllTransaction","_getAllNative","_getAllCursor","getAllRequest","all","cursorRequest","openCursor","cursor","clear","clearTransaction","clearRequest","dataObj","Date","now","indexNames","actual","expected","every","undefined","exp","act","i","m","iterate","onItem","mixin","order","autoContinue","filterDuplicates","writeAccess","onEnd","limit","Infinity","offset","allowItemRejection","directionType","toLowerCase","cursorTransaction","cursorTarget","recordCount","advance","onItemReturn","query","processedItems","accept","countRequest","evt","makeKeyRange","hasLower","lower","hasUpper","upper","isOnly","only","bound","excludeLower","excludeUpper","lowerBound","upperBound","empty","source","s"],"mappings":"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","sourcesContent":["/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Version 1.7.2\n * Copyright (c) 2011 - 2017 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT license\n */\n\n(function (name, definition, global) {\n\n    'use strict';\n\n    if (typeof define === 'function') {\n        define(definition);\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = definition();\n    } else {\n        global[name] = definition();\n    }\n})('IDBStore', function () {\n\n    'use strict';\n\n    var defaultErrorHandler = function (error) {\n        throw error;\n    };\n    var defaultSuccessHandler = function () {\n    };\n\n    var defaults = {\n        storeName: 'Store',\n        storePrefix: 'IDBWrapper-',\n        dbVersion: 1,\n        keyPath: 'id',\n        autoIncrement: true,\n        onStoreReady: function () {\n        },\n        onError: defaultErrorHandler,\n        indexes: [],\n        implementationPreference: [\n            'indexedDB',\n            'webkitIndexedDB',\n            'mozIndexedDB',\n            'shimIndexedDB'\n        ]\n    };\n\n    /**\n     *\n     * The IDBStore constructor\n     *\n     * @constructor\n     * @name IDBStore\n     * @version 1.7.2\n     *\n     * @param {Object} [kwArgs] An options object used to configure the store and\n     *  set callbacks\n     * @param {String} [kwArgs.storeName='Store'] The name of the store\n     * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n     *  internally used to construct the name of the database, which will be\n     *  kwArgs.storePrefix + kwArgs.storeName\n     * @param {Number} [kwArgs.dbVersion=1] The version of the store\n     * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n     *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n     *  `null`\n     * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n     *  automatically make sure a unique keyPath value is present on each object\n     *  that is stored.\n     * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n     *  store is ready to be used.\n     * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n     *  error occurred during instantiation of the store.\n     * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n     *  defining the indexes to use with the store. For every index to be used\n     *  one indexData object needs to be passed in the array.\n     *  An indexData object is defined as follows:\n     * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n     *  use\n     * @param {String} kwArgs.indexes.indexData.name The name of the index\n     * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n     * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n     * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n     * @param {Array} [kwArgs.implementationPreference=['indexedDB','webkitIndexedDB','mozIndexedDB','shimIndexedDB']] An array of strings naming implementations to be used, in order or preference\n     * @param {Function} [onStoreReady] A callback to be called when the store\n     * is ready to be used.\n     * @example\n     // create a store for customers with an additional index over the\n     // `lastname` property.\n     var myCustomerStore = new IDBStore({\n         dbVersion: 1,\n         storeName: 'customer-index',\n         keyPath: 'customerid',\n         autoIncrement: true,\n         onStoreReady: populateTable,\n         indexes: [\n             { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n         ]\n     });\n     * @example\n     // create a generic store\n     var myCustomerStore = new IDBStore({\n         storeName: 'my-data-store',\n         onStoreReady: function(){\n             // start working with the store.\n         }\n     });\n     */\n    var IDBStore = function (kwArgs, onStoreReady) {\n\n        if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n            onStoreReady = kwArgs;\n        }\n        if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n            kwArgs = {};\n        }\n\n        for (var key in defaults) {\n            this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n        }\n\n        this.dbName = this.storePrefix + this.storeName;\n        this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n\n        onStoreReady && (this.onStoreReady = onStoreReady);\n\n        var env = typeof window == 'object' ? window : self;\n        var availableImplementations = this.implementationPreference.filter(function (implName) {\n            return implName in env;\n        });\n        this.implementation = availableImplementations[0];\n        this.idb = env[this.implementation];\n        this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n\n        this.consts = {\n            'READ_ONLY': 'readonly',\n            'READ_WRITE': 'readwrite',\n            'VERSION_CHANGE': 'versionchange',\n            'NEXT': 'next',\n            'NEXT_NO_DUPLICATE': 'nextunique',\n            'PREV': 'prev',\n            'PREV_NO_DUPLICATE': 'prevunique'\n        };\n\n        this.openDB();\n    };\n\n    /** @lends IDBStore.prototype */\n    var proto = {\n\n        /**\n         * A pointer to the IDBStore ctor\n         *\n         * @private\n         * @type {Function}\n         * @constructs\n         */\n        constructor: IDBStore,\n\n        /**\n         * The version of IDBStore\n         *\n         * @type {String}\n         */\n        version: '1.7.2',\n\n        /**\n         * A reference to the IndexedDB object\n         *\n         * @type {IDBDatabase}\n         */\n        db: null,\n\n        /**\n         * The full name of the IndexedDB used by IDBStore, composed of\n         * this.storePrefix + this.storeName\n         *\n         * @type {String}\n         */\n        dbName: null,\n\n        /**\n         * The version of the IndexedDB used by IDBStore\n         *\n         * @type {Number}\n         */\n        dbVersion: null,\n\n        /**\n         * A reference to the objectStore used by IDBStore\n         *\n         * @type {IDBObjectStore}\n         */\n        store: null,\n\n        /**\n         * The store name\n         *\n         * @type {String}\n         */\n        storeName: null,\n\n        /**\n         * The prefix to prepend to the store name\n         *\n         * @type {String}\n         */\n        storePrefix: null,\n\n        /**\n         * The key path\n         *\n         * @type {String}\n         */\n        keyPath: null,\n\n        /**\n         * Whether IDBStore uses autoIncrement\n         *\n         * @type {Boolean}\n         */\n        autoIncrement: null,\n\n        /**\n         * The indexes used by IDBStore\n         *\n         * @type {Array}\n         */\n        indexes: null,\n\n        /**\n         * The implemantations to try to use, in order of preference\n         *\n         * @type {Array}\n         */\n        implementationPreference: null,\n\n        /**\n         * The actual implementation being used\n         *\n         * @type {String}\n         */\n        implementation: '',\n\n        /**\n         * The callback to be called when the store is ready to be used\n         *\n         * @type {Function}\n         */\n        onStoreReady: null,\n\n        /**\n         * The callback to be called if an error occurred during instantiation\n         * of the store\n         *\n         * @type {Function}\n         */\n        onError: null,\n\n        /**\n         * The internal insertID counter\n         *\n         * @type {Number}\n         * @private\n         */\n        _insertIdCount: 0,\n\n        /**\n         * Opens an IndexedDB; called by the constructor.\n         *\n         * Will check if versions match and compare provided index configuration\n         * with existing ones, and update indexes if necessary.\n         *\n         * Will call this.onStoreReady() if everything went well and the store\n         * is ready to use, and this.onError() is something went wrong.\n         *\n         * @private\n         *\n         */\n        openDB: function () {\n\n            var openRequest = this.idb.open(this.dbName, this.dbVersion);\n            var preventSuccessCallback = false;\n\n            openRequest.onerror = function (errorEvent) {\n\n                if (hasVersionError(errorEvent)) {\n                    this.onError(new Error('The version number provided is lower than the existing one.'));\n                } else {\n                    var error;\n\n                    if (errorEvent.target.error) {\n                        error = errorEvent.target.error;\n                    } else {\n                        var errorMessage = 'IndexedDB unknown error occurred when opening DB ' + this.dbName + ' version ' + this.dbVersion;\n                        if ('errorCode' in errorEvent.target) {\n                            errorMessage += ' with error code ' + errorEvent.target.errorCode;\n                        }\n                        error = new Error(errorMessage);\n                    }\n\n                    this.onError(error);\n                }\n            }.bind(this);\n\n            openRequest.onsuccess = function (event) {\n\n                if (preventSuccessCallback) {\n                    return;\n                }\n\n                if (this.db) {\n                    this.onStoreReady();\n                    return;\n                }\n\n                this.db = event.target.result;\n\n                if (typeof this.db.version == 'string') {\n                    this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n                    return;\n                }\n\n                if (!this.db.objectStoreNames.contains(this.storeName)) {\n                    // We should never ever get here.\n                    // Lets notify the user anyway.\n                    this.onError(new Error('Object store couldn\\'t be created.'));\n                    return;\n                }\n\n                var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n                this.store = emptyTransaction.objectStore(this.storeName);\n\n                // check indexes\n                var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n                this.indexes.forEach(function (indexData) {\n                    var indexName = indexData.name;\n\n                    if (!indexName) {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create index: No index name given.'));\n                        return;\n                    }\n\n                    this.normalizeIndexData(indexData);\n\n                    if (this.hasIndex(indexName)) {\n                        // check if it complies\n                        var actualIndex = this.store.index(indexName);\n                        var complies = this.indexComplies(actualIndex, indexData);\n                        if (!complies) {\n                            preventSuccessCallback = true;\n                            this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                        }\n\n                        existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n                    } else {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                    }\n\n                }, this);\n\n                if (existingIndexes.length) {\n                    preventSuccessCallback = true;\n                    this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                }\n\n                preventSuccessCallback || this.onStoreReady();\n            }.bind(this);\n\n            openRequest.onupgradeneeded = function (/* IDBVersionChangeEvent */ event) {\n\n                this.db = event.target.result;\n\n                if (this.db.objectStoreNames.contains(this.storeName)) {\n                    this.store = event.target.transaction.objectStore(this.storeName);\n                } else {\n                    var optionalParameters = {autoIncrement: this.autoIncrement};\n                    if (this.keyPath !== null) {\n                        optionalParameters.keyPath = this.keyPath;\n                    }\n                    this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n                }\n\n                var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n                this.indexes.forEach(function (indexData) {\n                    var indexName = indexData.name;\n\n                    if (!indexName) {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create index: No index name given.'));\n                    }\n\n                    this.normalizeIndexData(indexData);\n\n                    if (this.hasIndex(indexName)) {\n                        // check if it complies\n                        var actualIndex = this.store.index(indexName);\n                        var complies = this.indexComplies(actualIndex, indexData);\n                        if (!complies) {\n                            // index differs, need to delete and re-create\n                            this.store.deleteIndex(indexName);\n                            this.store.createIndex(indexName, indexData.keyPath, {\n                                unique: indexData.unique,\n                                multiEntry: indexData.multiEntry\n                            });\n                        }\n\n                        existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n                    } else {\n                        this.store.createIndex(indexName, indexData.keyPath, {\n                            unique: indexData.unique,\n                            multiEntry: indexData.multiEntry\n                        });\n                    }\n\n                }, this);\n\n                if (existingIndexes.length) {\n                    existingIndexes.forEach(function (_indexName) {\n                        this.store.deleteIndex(_indexName);\n                    }, this);\n                }\n\n            }.bind(this);\n        },\n\n        /**\n         * Deletes the database used for this store if the IDB implementations\n         * provides that functionality.\n         *\n         * @param {Function} [onSuccess] A callback that is called if deletion\n         *  was successful.\n         * @param {Function} [onError] A callback that is called if deletion\n         *  failed.\n         */\n        deleteDatabase: function (onSuccess, onError) {\n            if (this.idb.deleteDatabase) {\n                this.db.close();\n                var deleteRequest = this.idb.deleteDatabase(this.dbName);\n                deleteRequest.onsuccess = onSuccess;\n                deleteRequest.onerror = onError;\n            } else {\n                onError(new Error('Browser does not support IndexedDB deleteDatabase!'));\n            }\n        },\n\n        /*********************\n         * data manipulation *\n         *********************/\n\n        /**\n         * Puts an object into the store. If an entry with the given id exists,\n         * it will be overwritten. This method has a different signature for inline\n         * keys and out-of-line keys; please see the examples below.\n         *\n         * @param {*} [key] The key to store. This is only needed if IDBWrapper\n         *  is set to use out-of-line keys. For inline keys - the default scenario -\n         *  this can be omitted.\n         * @param {Object} value The data object to store.\n         * @param {Function} [onSuccess] A callback that is called if insertion\n         *  was successful.\n         * @param {Function} [onError] A callback that is called if insertion\n         *  failed.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         * @example\n         // Storing an object, using inline keys (the default scenario):\n         var myCustomer = {\n             customerid: 2346223,\n             lastname: 'Doe',\n             firstname: 'John'\n         };\n         myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n         // Note that passing success- and error-handlers is optional.\n         * @example\n         // Storing an object, using out-of-line keys:\n         var myCustomer = {\n             lastname: 'Doe',\n             firstname: 'John'\n         };\n         myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n         // Note that passing success- and error-handlers is optional.\n         */\n        put: function (key, value, onSuccess, onError) {\n            if (this.keyPath !== null) {\n                onError = onSuccess;\n                onSuccess = value;\n                value = key;\n            }\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null,\n                putRequest;\n\n            var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            putTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            putTransaction.onabort = onError;\n            putTransaction.onerror = onError;\n\n            if (this.keyPath !== null) { // in-line keys\n                this._addIdPropertyIfNeeded(value);\n                putRequest = putTransaction.objectStore(this.storeName).put(value);\n            } else { // out-of-line keys\n                putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n            }\n            putRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            putRequest.onerror = onError;\n\n            return putTransaction;\n        },\n\n        /**\n         * Retrieves an object from the store. If no entry exists with the given id,\n         * the success handler will be called with null as first and only argument.\n         *\n         * @param {*} key The id of the object to fetch.\n         * @param {Function} [onSuccess] A callback that is called if fetching\n         *  was successful. Will receive the object as only argument.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        get: function (key, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            getTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getTransaction.onabort = onError;\n            getTransaction.onerror = onError;\n            var getRequest = getTransaction.objectStore(this.storeName).get(key);\n            getRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            getRequest.onerror = onError;\n\n            return getTransaction;\n        },\n\n        /**\n         * Removes an object from the store.\n         *\n         * @param {*} key The id of the object to remove.\n         * @param {Function} [onSuccess] A callback that is called if the removal\n         *  was successful.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        remove: function (key, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            removeTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            removeTransaction.onabort = onError;\n            removeTransaction.onerror = onError;\n\n            var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n            deleteRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            deleteRequest.onerror = onError;\n\n            return removeTransaction;\n        },\n\n        /**\n         * Runs a batch of put and/or remove operations on the store.\n         *\n         * @param {Array} dataArray An array of objects containing the operation to run\n         *  and the data object (for put operations).\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        batch: function (dataArray, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n                onError(new Error('dataArray argument must be of type Array.'));\n            } else if (dataArray.length === 0) {\n                return onSuccess(true);\n            }\n\n            var count = dataArray.length;\n            var called = false;\n            var hasSuccess = false;\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            batchTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(hasSuccess);\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n\n            var onItemSuccess = function () {\n                count--;\n                if (count === 0 && !called) {\n                    called = true;\n                    hasSuccess = true;\n                }\n            };\n\n            dataArray.forEach(function (operation) {\n                var type = operation.type;\n                var key = operation.key;\n                var value = operation.value;\n\n                var onItemError = function (err) {\n                    batchTransaction.abort();\n                    if (!called) {\n                        called = true;\n                        onError(err, type, key);\n                    }\n                };\n\n                if (type == 'remove') {\n                    var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n                    deleteRequest.onsuccess = onItemSuccess;\n                    deleteRequest.onerror = onItemError;\n                } else if (type == 'put') {\n                    var putRequest;\n                    if (this.keyPath !== null) { // in-line keys\n                        this._addIdPropertyIfNeeded(value);\n                        putRequest = batchTransaction.objectStore(this.storeName).put(value);\n                    } else { // out-of-line keys\n                        putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n                    }\n                    putRequest.onsuccess = onItemSuccess;\n                    putRequest.onerror = onItemError;\n                }\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Takes an array of objects and stores them in a single transaction.\n         *\n         * @param {Array} dataArray An array of objects to store\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        putBatch: function (dataArray, onSuccess, onError) {\n            var batchData = dataArray.map(function (item) {\n                return {type: 'put', value: item};\n            });\n\n            return this.batch(batchData, onSuccess, onError);\n        },\n\n        /**\n         * Like putBatch, takes an array of objects and stores them in a single\n         * transaction, but allows processing of the result values.  Returns the\n         * processed records containing the key for newly created records to the\n         * onSuccess calllback instead of only returning true or false for success.\n         * In addition, added the option for the caller to specify a key field that\n         * should be set to the newly created key.\n         *\n         * @param {Array} dataArray An array of objects to store\n         * @param {Object} [options] An object containing optional options\n         * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update\n         *  with the auto-incrementing key. Defaults to the store's keyPath.\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         *\n         */\n        upsertBatch: function (dataArray, options, onSuccess, onError) {\n            // handle `dataArray, onSuccess, onError` signature\n            if (typeof options == 'function') {\n                onSuccess = options;\n                onError = onSuccess;\n                options = {};\n            }\n\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            options || (options = {});\n\n            if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n                onError(new Error('dataArray argument must be of type Array.'));\n            }\n\n            var keyField = options.keyField || this.keyPath;\n            var count = dataArray.length;\n            var called = false;\n            var hasSuccess = false;\n            var index = 0; // assume success callbacks are executed in order\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            batchTransaction.oncomplete = function () {\n                if (hasSuccess) {\n                    onSuccess(dataArray);\n                } else {\n                    onError(false);\n                }\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n            var onItemSuccess = function (event) {\n                var record = dataArray[index++];\n                record[keyField] = event.target.result;\n\n                count--;\n                if (count === 0 && !called) {\n                    called = true;\n                    hasSuccess = true;\n                }\n            };\n\n            dataArray.forEach(function (record) {\n                var key = record.key;\n\n                var onItemError = function (err) {\n                    batchTransaction.abort();\n                    if (!called) {\n                        called = true;\n                        onError(err);\n                    }\n                };\n\n                var putRequest;\n                if (this.keyPath !== null) { // in-line keys\n                    this._addIdPropertyIfNeeded(record);\n                    putRequest = batchTransaction.objectStore(this.storeName).put(record);\n                } else { // out-of-line keys\n                    putRequest = batchTransaction.objectStore(this.storeName).put(record, key);\n                }\n                putRequest.onsuccess = onItemSuccess;\n                putRequest.onerror = onItemError;\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Takes an array of keys and removes matching objects in a single\n         * transaction.\n         *\n         * @param {Array} keyArray An array of keys to remove\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        removeBatch: function (keyArray, onSuccess, onError) {\n            var batchData = keyArray.map(function (key) {\n                return {type: 'remove', key: key};\n            });\n\n            return this.batch(batchData, onSuccess, onError);\n        },\n\n        /**\n         * Takes an array of keys and fetches matching objects\n         *\n         * @param {Array} keyArray An array of keys identifying the objects to fetch\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @param {String} [arrayType='sparse'] The type of array to pass to the\n         *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n         *  'sparse'. This parameter specifies how to handle the situation if a get\n         *  operation did not throw an error, but there was no matching object in\n         *  the database. In most cases, 'sparse' provides the most desired\n         *  behavior. See the examples for details.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         * @example\n         // given that there are two objects in the database with the keypath\n         // values 1 and 2, and the call looks like this:\n         myStore.getBatch([1, 5, 2], onError, function (data) { … }, arrayType);\n\n         // this is what the `data` array will be like:\n\n         // arrayType == 'sparse':\n         // data is a sparse array containing two entries and having a length of 3:\n         [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         // calling forEach on data will result in the callback being called two\n         // times, with the index parameter matching the index of the key in the\n         // keyArray.\n\n         // arrayType == 'dense':\n         // data is a dense array containing three entries and having a length of 3,\n         // where data[1] is of type undefined:\n         [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         // calling forEach on data will result in the callback being called three\n         // times, with the index parameter matching the index of the key in the\n         // keyArray, but the second call will have undefined as first argument.\n\n         // arrayType == 'skip':\n         // data is a dense array containing two entries and having a length of 2:\n         [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         // calling forEach on data will result in the callback being called two\n         // times, with the index parameter not matching the index of the key in the\n         // keyArray.\n         */\n        getBatch: function (keyArray, onSuccess, onError, arrayType) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            arrayType || (arrayType = 'sparse');\n\n            if (Object.prototype.toString.call(keyArray) != '[object Array]') {\n                onError(new Error('keyArray argument must be of type Array.'));\n            } else if (keyArray.length === 0) {\n                return onSuccess([]);\n            }\n\n            var data = [];\n            var count = keyArray.length;\n            var called = false;\n            var hasSuccess = false;\n            var result = null;\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            batchTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n            var onItemSuccess = function (event) {\n                if (event.target.result || arrayType == 'dense') {\n                    data.push(event.target.result);\n                } else if (arrayType == 'sparse') {\n                    data.length++;\n                }\n                count--;\n                if (count === 0) {\n                    called = true;\n                    hasSuccess = true;\n                    result = data;\n                }\n            };\n\n            keyArray.forEach(function (key) {\n\n                var onItemError = function (err) {\n                    called = true;\n                    result = err;\n                    onError(err);\n                    batchTransaction.abort();\n                };\n\n                var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n                getRequest.onsuccess = onItemSuccess;\n                getRequest.onerror = onItemError;\n\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Fetches all entries in the store.\n         *\n         * @param {Function} [onSuccess] A callback that is called if the operation\n         *  was successful. Will receive an array of objects.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        getAll: function (onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            var store = getAllTransaction.objectStore(this.storeName);\n            if (store.getAll) {\n                this._getAllNative(getAllTransaction, store, onSuccess, onError);\n            } else {\n                this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n            }\n\n            return getAllTransaction;\n        },\n\n        /**\n         * Implements getAll for IDB implementations that have a non-standard\n         * getAll() method.\n         *\n         * @param {IDBTransaction} getAllTransaction An open READ transaction.\n         * @param {IDBObjectStore} store A reference to the store.\n         * @param {Function} onSuccess A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} onError A callback that will be called if an\n         *  error occurred during the operation.\n         * @private\n         */\n        _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n            var hasSuccess = false,\n                result = null;\n\n            getAllTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getAllTransaction.onabort = onError;\n            getAllTransaction.onerror = onError;\n\n            var getAllRequest = store.getAll();\n            getAllRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            getAllRequest.onerror = onError;\n        },\n\n        /**\n         * Implements getAll for IDB implementations that do not have a getAll()\n         * method.\n         *\n         * @param {IDBTransaction} getAllTransaction An open READ transaction.\n         * @param {IDBObjectStore} store A reference to the store.\n         * @param {Function} onSuccess A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} onError A callback that will be called if an\n         *  error occurred during the operation.\n         * @private\n         */\n        _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n            var all = [],\n                hasSuccess = false,\n                result = null;\n\n            getAllTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getAllTransaction.onabort = onError;\n            getAllTransaction.onerror = onError;\n\n            var cursorRequest = store.openCursor();\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (cursor) {\n                    all.push(cursor.value);\n                    cursor['continue']();\n                }\n                else {\n                    hasSuccess = true;\n                    result = all;\n                }\n            };\n            cursorRequest.onError = onError;\n        },\n\n        /**\n         * Clears the store, i.e. deletes all entries in the store.\n         *\n         * @param {Function} [onSuccess] A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} [onError] A callback that will be called if an\n         *  error occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        clear: function (onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            clearTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            clearTransaction.onabort = onError;\n            clearTransaction.onerror = onError;\n\n            var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n            clearRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            clearRequest.onerror = onError;\n\n            return clearTransaction;\n        },\n\n        /**\n         * Checks if an id property needs to present on a object and adds one if\n         * necessary.\n         *\n         * @param {Object} dataObj The data object that is about to be stored\n         * @private\n         */\n        _addIdPropertyIfNeeded: function (dataObj) {\n            if (typeof dataObj[this.keyPath] == 'undefined') {\n                dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n            }\n        },\n\n        /************\n         * indexing *\n         ************/\n\n        /**\n         * Returns a DOMStringList of index names of the store.\n         *\n         * @return {DOMStringList} The list of index names\n         */\n        getIndexList: function () {\n            return this.store.indexNames;\n        },\n\n        /**\n         * Checks if an index with the given name exists in the store.\n         *\n         * @param {String} indexName The name of the index to look for\n         * @return {Boolean} Whether the store contains an index with the given name\n         */\n        hasIndex: function (indexName) {\n            return this.store.indexNames.contains(indexName);\n        },\n\n        /**\n         * Normalizes an object containing index data and assures that all\n         * properties are set.\n         *\n         * @param {Object} indexData The index data object to normalize\n         * @param {String} indexData.name The name of the index\n         * @param {String} [indexData.keyPath] The key path of the index\n         * @param {Boolean} [indexData.unique] Whether the index is unique\n         * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n         */\n        normalizeIndexData: function (indexData) {\n            indexData.keyPath = indexData.keyPath || indexData.name;\n            indexData.unique = !!indexData.unique;\n            indexData.multiEntry = !!indexData.multiEntry;\n        },\n\n        /**\n         * Checks if an actual index complies with an expected index.\n         *\n         * @param {IDBIndex} actual The actual index found in the store\n         * @param {Object} expected An Object describing an expected index\n         * @return {Boolean} Whether both index definitions are identical\n         */\n        indexComplies: function (actual, expected) {\n            var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n                // IE10 returns undefined for no multiEntry\n                if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n                    return true;\n                }\n                // Compound keys\n                if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n                    var exp = expected.keyPath;\n                    var act = actual.keyPath;\n\n                    // IE10 can't handle keyPath sequences and stores them as a string.\n                    // The index will be unusable there, but let's still return true if\n                    // the keyPath sequence matches.\n                    if (typeof act == 'string') {\n                        return exp.toString() == act;\n                    }\n\n                    // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n                    // as Array\n                    if (!(typeof act.contains == 'function' || typeof act.indexOf == 'function')) {\n                        return false;\n                    }\n\n                    if (act.length !== exp.length) {\n                        return false;\n                    }\n\n                    for (var i = 0, m = exp.length; i < m; i++) {\n                        if (!( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return expected[key] == actual[key];\n            });\n            return complies;\n        },\n\n        /**********\n         * cursor *\n         **********/\n\n        /**\n         * Iterates over the store using the given options and calling onItem\n         * for each entry matching the options.\n         *\n         * @param {Function} onItem A callback to be called for each match\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {String} [options.order=ASC] The order in which to provide the\n         *  results, can be 'DESC' or 'ASC'\n         * @param {Boolean} [options.autoContinue=true] Whether to automatically\n         *  iterate the cursor to the next result\n         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n         *  duplicate matches\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Boolean} [options.writeAccess=false] Whether grant write access\n         *  to the store in the onItem callback\n         * @param {Function} [options.onEnd=null] A callback to be called after\n         *  iteration has ended\n         * @param {Function} [options.onError=throw] A callback to be called\n         *  if an error occurred during the operation.\n         * @param {Number} [options.limit=Infinity] Limit the number of returned\n         *  results to this number\n         * @param {Number} [options.offset=0] Skip the provided number of results\n         *  in the resultset\n         * @param {Boolean} [options.allowItemRejection=false] Allows the onItem\n         * function to return a Boolean to accept or reject the current item\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        iterate: function (onItem, options) {\n            options = mixin({\n                index: null,\n                order: 'ASC',\n                autoContinue: true,\n                filterDuplicates: false,\n                keyRange: null,\n                writeAccess: false,\n                onEnd: null,\n                onError: defaultErrorHandler,\n                limit: Infinity,\n                offset: 0,\n                allowItemRejection: false\n            }, options || {});\n\n            var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n            if (options.filterDuplicates) {\n                directionType += '_NO_DUPLICATE';\n            }\n\n            var hasSuccess = false;\n            var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n            var cursorTarget = cursorTransaction.objectStore(this.storeName);\n            if (options.index) {\n                cursorTarget = cursorTarget.index(options.index);\n            }\n            var recordCount = 0;\n\n            cursorTransaction.oncomplete = function () {\n                if (!hasSuccess) {\n                    options.onError(null);\n                    return;\n                }\n                if (options.onEnd) {\n                    options.onEnd();\n                } else {\n                    onItem(null);\n                }\n            };\n            cursorTransaction.onabort = options.onError;\n            cursorTransaction.onerror = options.onError;\n\n            var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n            cursorRequest.onerror = options.onError;\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (cursor) {\n                    if (options.offset) {\n                        cursor.advance(options.offset);\n                        options.offset = 0;\n                    } else {\n                        var onItemReturn = onItem(cursor.value, cursor, cursorTransaction);\n                        if (!options.allowItemRejection || onItemReturn !== false) {\n                            recordCount++;\n                        }\n                        if (options.autoContinue) {\n                            if (recordCount + options.offset < options.limit) {\n                                cursor['continue']();\n                            } else {\n                                hasSuccess = true;\n                            }\n                        }\n                    }\n                } else {\n                    hasSuccess = true;\n                }\n            };\n\n            return cursorTransaction;\n        },\n\n        /**\n         * Runs a query against the store and passes an array containing matched\n         * objects to the success handler.\n         *\n         * @param {Function} onSuccess A callback to be called when the operation\n         *  was successful.\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {String} [options.order=ASC] The order in which to provide the\n         *  results, can be 'DESC' or 'ASC'\n         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n         *  duplicate matches\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Function} [options.onError=throw] A callback to be called\n         *  if an error occurred during the operation.\n         * @param {Number} [options.limit=Infinity] Limit the number of returned\n         *  results to this number\n         * @param {Number} [options.offset=0] Skip the provided number of results\n         *  in the resultset\n         * @param {Function} [options.filter=null] A custom filter function to\n         *  apply to query resuts before returning. Must return `false` to reject\n         *  an item. Can be combined with keyRanges.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        query: function (onSuccess, options) {\n            var result = [],\n                processedItems = 0;\n            options = options || {};\n            options.autoContinue = true;\n            options.writeAccess = false;\n            options.allowItemRejection = !!options.filter;\n            options.onEnd = function () {\n                onSuccess(result, processedItems);\n            };\n            return this.iterate(function (item) {\n                processedItems++;\n                var accept = options.filter ? options.filter(item) : true;\n                if (accept !== false) {\n                    result.push(item);\n                }\n                return accept;\n            }, options);\n        },\n\n        /**\n         *\n         * Runs a query against the store, but only returns the number of matches\n         * instead of the matches itself.\n         *\n         * @param {Function} onSuccess A callback to be called if the opration\n         *  was successful.\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Function} [options.onError=throw] A callback to be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        count: function (onSuccess, options) {\n\n            options = mixin({\n                index: null,\n                keyRange: null\n            }, options || {});\n\n            var onError = options.onError || defaultErrorHandler;\n\n            var hasSuccess = false,\n                result = null;\n\n            var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            cursorTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            cursorTransaction.onabort = onError;\n            cursorTransaction.onerror = onError;\n\n            var cursorTarget = cursorTransaction.objectStore(this.storeName);\n            if (options.index) {\n                cursorTarget = cursorTarget.index(options.index);\n            }\n            var countRequest = cursorTarget.count(options.keyRange);\n            countRequest.onsuccess = function (evt) {\n                hasSuccess = true;\n                result = evt.target.result;\n            };\n            countRequest.onError = onError;\n\n            return cursorTransaction;\n        },\n\n        /**************/\n        /* key ranges */\n        /**************/\n\n        /**\n         * Creates a key range using specified options. This key range can be\n         * handed over to the count() and iterate() methods.\n         *\n         * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n         *\n         * @param {Object} options The options for the key range to create\n         * @param {*} [options.lower] The lower bound\n         * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n         *  bound passed in options.lower from the key range\n         * @param {*} [options.upper] The upper bound\n         * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n         *  bound passed in options.upper from the key range\n         * @param {*} [options.only] A single key value. Use this if you need a key\n         *  range that only includes one value for a key. Providing this\n         *  property invalidates all other properties.\n         * @return {IDBKeyRange} The IDBKeyRange representing the specified options\n         */\n        makeKeyRange: function (options) {\n            /*jshint onecase:true */\n            var keyRange,\n                hasLower = typeof options.lower != 'undefined',\n                hasUpper = typeof options.upper != 'undefined',\n                isOnly = typeof options.only != 'undefined';\n\n            switch (true) {\n                case isOnly:\n                    keyRange = this.keyRange.only(options.only);\n                    break;\n                case hasLower && hasUpper:\n                    keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n                    break;\n                case hasLower:\n                    keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n                    break;\n                case hasUpper:\n                    keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n                    break;\n                default:\n                    throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n            }\n\n            return keyRange;\n\n        }\n\n    };\n\n    /** helpers **/\n    var empty = {};\n\n    function mixin (target, source) {\n        var name, s;\n        for (name in source) {\n            s = source[name];\n            if (s !== empty[name] && s !== target[name]) {\n                target[name] = s;\n            }\n        }\n        return target;\n    }\n\n    function hasVersionError(errorEvent) {\n        if ('error' in errorEvent.target) {\n            return errorEvent.target.error.name == 'VersionError';\n        } else if ('errorCode' in errorEvent.target) {\n            return errorEvent.target.errorCode == 12;\n        }\n        return false;\n    }\n\n    IDBStore.prototype = proto;\n    IDBStore.version = proto.version;\n\n    return IDBStore;\n\n}, this);\n"]},"metadata":{},"sourceType":"script"}