{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.regularizeUpsert = exports.createUid = exports.filterFields = exports.processFind = exports.cloneLocalCollection = exports.cloneLocalDb = exports.migrateLocalDb = exports.autoselectLocalDb = exports.compileDocumentSelector = void 0; // Utilities for db handling\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar async_1 = __importDefault(require(\"async\"));\n\nvar bowser_1 = __importDefault(require(\"bowser\"));\n\nvar selector_1 = require(\"./selector\");\n\nObject.defineProperty(exports, \"compileDocumentSelector\", {\n  enumerable: true,\n  get: function get() {\n    return selector_1.compileDocumentSelector;\n  }\n});\n\nvar boolean_point_in_polygon_1 = __importDefault(require(\"@turf/boolean-point-in-polygon\"));\n\nvar intersect_1 = __importDefault(require(\"@turf/intersect\"));\n\nvar boolean_crosses_1 = __importDefault(require(\"@turf/boolean-crosses\"));\n\nvar boolean_within_1 = __importDefault(require(\"@turf/boolean-within\"));\n\nvar IndexedDb_1 = __importDefault(require(\"./IndexedDb\"));\n\nvar WebSQLDb_1 = __importDefault(require(\"./WebSQLDb\"));\n\nvar LocalStorageDb_1 = __importDefault(require(\"./LocalStorageDb\"));\n\nvar MemoryDb_1 = __importDefault(require(\"./MemoryDb\"));\n\nvar HybridDb_1 = __importDefault(require(\"./HybridDb\")); // Test window.localStorage\n\n\nfunction isLocalStorageSupported() {\n  if (!window.localStorage) {\n    return false;\n  }\n\n  try {\n    window.localStorage.setItem(\"test\", \"test\");\n    window.localStorage.removeItem(\"test\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n} // Select appropriate local database, prefering IndexedDb, then WebSQLDb, then LocalStorageDb, then MemoryDb\n\n\nfunction autoselectLocalDb(options, success, error) {\n  var _a; // Get browser capabilities\n\n\n  var browser = bowser_1.default.browser; // Browsers with no localStorage support don't deserve anything better than a MemoryDb\n\n  if (!isLocalStorageSupported()) {\n    return new MemoryDb_1.default(options, success);\n  } // Always use WebSQL in cordova\n\n\n  if (window[\"cordova\"]) {\n    if (((_a = window[\"device\"]) === null || _a === void 0 ? void 0 : _a.platform) === \"iOS\" && window[\"sqlitePlugin\"]) {\n      console.log(\"Selecting WebSQLDb(sqlite) for Cordova\");\n      options.storage = \"sqlite\";\n      return new WebSQLDb_1.default(options, success, error);\n    } else {\n      console.log(\"Selecting else WebSQLDb for Cordova\"); // WebSQLDb must success in Cordova\n\n      return new WebSQLDb_1.default(options, success, error);\n    }\n  } // Use IndexedDb for ios, Safari\n\n\n  if (browser.ios || browser.safari) {\n    // Fallback to IndexedDb\n    return new IndexedDb_1.default(options, success, function (err) {\n      console.log(\"Failed to create IndexedDb: \" + (err ? err.message : undefined)); // Create memory db instead\n\n      return new MemoryDb_1.default(options, success);\n    });\n  } // Use WebSQL in Android, Chrome,  Opera, Blackberry if supports it\n\n\n  if (browser.android || browser.chrome || browser.opera || browser.blackberry) {\n    if (typeof window[\"openDatabase\"] === \"function\") {\n      console.log(\"Selecting WebSQLDb for browser\");\n      return new WebSQLDb_1.default(options, success, function (err) {\n        console.log(\"Failed to create WebSQLDb: \" + (err ? err.message : undefined)); // Fallback to IndexedDb\n\n        return new IndexedDb_1.default(options, success, function (err) {\n          console.log(\"Failed to create IndexedDb: \" + (err ? err.message : undefined)); // Create memory db instead\n\n          return new MemoryDb_1.default(options, success);\n        });\n      });\n    } else {\n      // Fallback to IndexedDb\n      console.log(\"Selecting IndexedDb for browser as WebSQL not supported\");\n      return new IndexedDb_1.default(options, success, function (err) {\n        console.log(\"Failed to create IndexedDb: \" + (err ? err.message : undefined)); // Create memory db instead\n\n        return new MemoryDb_1.default(options, success);\n      });\n    }\n  } // Use IndexedDb on Firefox >= 16\n\n\n  if (browser.firefox && browser.version >= 16) {\n    console.log(\"Selecting IndexedDb for browser\");\n    return new IndexedDb_1.default(options, success, function (err) {\n      console.log(\"Failed to create IndexedDb: \" + (err ? err.message : undefined)); // Create memory db instead\n\n      return new MemoryDb_1.default(options, success);\n    });\n  } // Use Local Storage otherwise\n\n\n  console.log(\"Selecting LocalStorageDb for fallback\");\n  return new LocalStorageDb_1.default(options, success, error);\n}\n\nexports.autoselectLocalDb = autoselectLocalDb; // Migrates a local database's pending upserts and removes from one database to another\n// Useful for upgrading from one type of database to another\n\nfunction migrateLocalDb(fromDb, toDb, success, error) {\n  // Migrate collection using a HybridDb\n  var hybridDb = new HybridDb_1.default(fromDb, toDb);\n\n  for (var name in fromDb.collections) {\n    var col = fromDb.collections[name];\n\n    if (toDb[name]) {\n      hybridDb.addCollection(name);\n    }\n  }\n\n  return hybridDb.upload(success, error);\n}\n\nexports.migrateLocalDb = migrateLocalDb;\n/** Clone a local database collection's caches, pending upserts and removes from one database to another\n * Useful for making a replica */\n\nfunction cloneLocalDb(fromDb, toDb, success, error) {\n  var name;\n\n  for (name in fromDb.collections) {\n    // TODO Assumes synchronous addCollection\n    var col = fromDb.collections[name];\n\n    if (!toDb[name]) {\n      toDb.addCollection(name);\n    }\n  } // First cache all data\n\n\n  return async_1.default.each(lodash_1.default.values(fromDb.collections), function (fromCol, cb) {\n    var toCol = toDb[fromCol.name]; // Get all items\n\n    return fromCol.find({}).fetch(function (items) {\n      // Seed items\n      return toCol.seed(items, function () {\n        // Copy upserts\n        return fromCol.pendingUpserts(function (upserts) {\n          return toCol.upsert(lodash_1.default.map(upserts, \"doc\"), lodash_1.default.map(upserts, \"base\"), function () {\n            // Copy removes\n            return fromCol.pendingRemoves(function (removes) {\n              return async_1.default.eachSeries(removes, function (remove, cb2) {\n                return toCol.remove(remove, function () {\n                  return cb2();\n                }, cb2);\n              }, cb);\n            }, cb);\n          }, cb);\n        }, cb);\n      }, cb);\n    }, cb);\n  }, function (err) {\n    if (err) {\n      return error(err);\n    }\n\n    return success();\n  });\n}\n\nexports.cloneLocalDb = cloneLocalDb;\n/** Clone a local database collection's caches, pending upserts and removes from one database to another\n * Useful for making a replica */\n\nfunction cloneLocalCollection(fromCol, toCol, success, error) {\n  // Get all items\n  return fromCol.find({}).fetch(function (items) {\n    // Seed items\n    return toCol.seed(items, function () {\n      // Copy upserts\n      return fromCol.pendingUpserts(function (upserts) {\n        return toCol.upsert(lodash_1.default.map(upserts, \"doc\"), lodash_1.default.map(upserts, \"base\"), function () {\n          // Copy removes\n          return fromCol.pendingRemoves(function (removes) {\n            var iterator = function iterator(remove, cb2) {\n              return toCol.remove(remove, function () {\n                return cb2();\n              }, cb2);\n            };\n\n            return async_1.default.eachSeries(removes, iterator, function (err) {\n              if (err) {\n                return error(err);\n              }\n\n              return success();\n            });\n          }, error);\n        }, error);\n      }, error);\n    }, error);\n  }, error);\n}\n\nexports.cloneLocalCollection = cloneLocalCollection; // Processes a find with sorting and filtering and limiting\n\nfunction processFind(items, selector, options) {\n  var filtered = lodash_1.default.filter(items, (0, selector_1.compileDocumentSelector)(selector)); // Handle geospatial operators\n\n  filtered = processNearOperator(selector, filtered);\n  filtered = processGeoIntersectsOperator(selector, filtered);\n\n  if (options && options.sort) {\n    filtered.sort((0, selector_1.compileSort)(options.sort));\n  }\n\n  if (options && options.skip) {\n    filtered = lodash_1.default.slice(filtered, options.skip);\n  }\n\n  if (options && options.limit) {\n    filtered = lodash_1.default.take(filtered, options.limit);\n  } // Apply fields if present\n\n\n  if (options && options.fields) {\n    filtered = exports.filterFields(filtered, options.fields);\n  }\n\n  return filtered;\n}\n\nexports.processFind = processFind;\n/** Include/exclude fields in mongo-style */\n\nfunction filterFields(items) {\n  var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // Handle trivial case\n  if (lodash_1.default.keys(fields).length === 0) {\n    return items;\n  } // For each item\n\n\n  return lodash_1.default.map(items, function (item) {\n    var field, obj, path, pathElem;\n    var newItem = {};\n\n    if (lodash_1.default.first(lodash_1.default.values(fields)) === 1) {\n      // Include fields\n      var _iterator = _createForOfIteratorHelper(lodash_1.default.keys(fields).concat([\"_id\"])),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          field = _step.value;\n          path = field.split(\".\"); // Determine if path exists\n\n          obj = item;\n\n          var _iterator2 = _createForOfIteratorHelper(path),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              pathElem = _step2.value;\n\n              if (obj) {\n                obj = obj[pathElem];\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          if (obj == null) {\n            continue;\n          } // Go into path, creating as necessary\n\n\n          var from = item;\n          var to = newItem;\n\n          var _iterator3 = _createForOfIteratorHelper(lodash_1.default.initial(path)),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              pathElem = _step3.value;\n              to[pathElem] = to[pathElem] || {}; // Move inside\n\n              to = to[pathElem];\n              from = from[pathElem];\n            } // Copy value\n\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          to[lodash_1.default.last(path)] = from[lodash_1.default.last(path)];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return newItem;\n    } else {\n      // Deep clone as we will be deleting keys from item to exclude fields\n      item = lodash_1.default.cloneDeep(item); // Exclude fields\n\n      var _iterator4 = _createForOfIteratorHelper(lodash_1.default.keys(fields)),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          field = _step4.value;\n          path = field.split(\".\"); // Go inside path\n\n          obj = item;\n\n          var _iterator5 = _createForOfIteratorHelper(lodash_1.default.initial(path)),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              pathElem = _step5.value;\n\n              if (obj) {\n                obj = obj[pathElem];\n              }\n            } // If not there, don't exclude\n\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          if (obj == null) {\n            continue;\n          }\n\n          delete obj[lodash_1.default.last(path)];\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return item;\n    }\n  });\n}\n\nexports.filterFields = filterFields; // Creates a unique identifier string\n\nfunction createUid() {\n  return \"xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === \"x\" ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n\nexports.createUid = createUid;\n\nfunction processNearOperator(selector, list) {\n  for (var key in selector) {\n    var value = selector[key];\n\n    if (value != null && value[\"$near\"]) {\n      var geo = value[\"$near\"][\"$geometry\"];\n\n      if (geo.type !== \"Point\") {\n        break;\n      }\n\n      list = lodash_1.default.filter(list, function (doc) {\n        return doc[key] && doc[key].type === \"Point\";\n      }); // Get distances\n\n      var distances = lodash_1.default.map(list, function (doc) {\n        return {\n          doc: doc,\n          distance: getDistanceFromLatLngInM(geo.coordinates[1], geo.coordinates[0], doc[key].coordinates[1], doc[key].coordinates[0])\n        };\n      }); // Filter non-points\n\n      distances = lodash_1.default.filter(distances, function (item) {\n        return item.distance >= 0;\n      }); // Sort by distance\n\n      distances = lodash_1.default.sortBy(distances, \"distance\"); // Filter by maxDistance\n\n      if (value[\"$near\"][\"$maxDistance\"]) {\n        distances = lodash_1.default.filter(distances, function (item) {\n          return item.distance <= value[\"$near\"][\"$maxDistance\"];\n        });\n      } // Extract docs\n\n\n      list = lodash_1.default.map(distances, \"doc\");\n    }\n  }\n\n  return list;\n}\n\nfunction pointInPolygon(point, polygon) {\n  return (0, boolean_point_in_polygon_1.default)(point, polygon);\n}\n\nfunction polygonIntersection(polygon1, polygon2) {\n  return (0, intersect_1.default)(polygon1, polygon2) != null;\n} // From http://www.movable-type.co.uk/scripts/latlong.html\n\n\nfunction getDistanceFromLatLngInM(lat1, lng1, lat2, lng2) {\n  var R = 6370986; // Radius of the earth in m\n\n  var dLat = deg2rad(lat2 - lat1); // deg2rad below\n\n  var dLng = deg2rad(lng2 - lng1);\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c; // Distance in m\n\n  return d;\n}\n\nfunction deg2rad(deg) {\n  return deg * (Math.PI / 180);\n}\n\nfunction processGeoIntersectsOperator(selector, list) {\n  for (var key in selector) {\n    var value = selector[key];\n\n    if (value != null && value[\"$geoIntersects\"]) {\n      var geo = value[\"$geoIntersects\"][\"$geometry\"]; // Can only test intersection with polygon\n\n      if (geo.type !== \"Polygon\") {\n        break;\n      } // Check within for each\n\n\n      list = lodash_1.default.filter(list, function (doc) {\n        // Ignore if null\n        if (!doc[key]) {\n          return false;\n        } // Check point or polygon\n\n\n        if (doc[key].type === \"Point\") {\n          return pointInPolygon(doc[key], geo);\n        } else if ([\"Polygon\", \"MultiPolygon\"].includes(doc[key].type)) {\n          return polygonIntersection(doc[key], geo);\n        } else if (doc[key].type === \"LineString\") {\n          return (0, boolean_crosses_1.default)(doc[key], geo) || (0, boolean_within_1.default)(doc[key], geo);\n        } else if (doc[key].type === \"MultiLineString\") {\n          // Bypass deficiencies in turf.js by splitting it up\n          var _iterator6 = _createForOfIteratorHelper(doc[key].coordinates),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var line = _step6.value;\n              var lineGeo = {\n                type: \"LineString\",\n                coordinates: line\n              };\n\n              if ((0, boolean_crosses_1.default)(lineGeo, geo) || (0, boolean_within_1.default)(lineGeo, geo)) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          return false;\n        }\n      });\n    }\n  }\n\n  return list;\n}\n/** Tidy up upsert parameters to always be a list of { doc: <doc>, base: <base> },\n * doing basic error checking and making sure that _id is present\n * Returns [items, success, error]\n */\n\n\nfunction regularizeUpsert(docs, bases, success, error) {\n  // Handle case of bases not present\n  if (lodash_1.default.isFunction(bases)) {\n    ;\n    var _ref = [undefined, bases, success];\n    bases = _ref[0];\n    success = _ref[1];\n    error = _ref[2];\n  } // Handle single upsert\n\n\n  if (!lodash_1.default.isArray(docs)) {\n    docs = [docs];\n    bases = [bases];\n  } else {\n    bases = bases || [];\n  } // Make into list of { doc: .., base: }\n\n\n  var items = lodash_1.default.map(docs, function (doc, i) {\n    return {\n      doc: doc,\n      base: i < bases.length ? bases[i] : undefined\n    };\n  }); // Set _id\n\n  var _iterator7 = _createForOfIteratorHelper(items),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var item = _step7.value;\n\n      if (!item.doc._id) {\n        item.doc._id = exports.createUid();\n      }\n\n      if (item.base && !item.base._id) {\n        throw new Error(\"Base needs _id\");\n      }\n\n      if (item.base && item.base._id !== item.doc._id) {\n        throw new Error(\"Base needs same _id\");\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return [items, success, error];\n}\n\nexports.regularizeUpsert = regularizeUpsert;","map":null,"metadata":{},"sourceType":"script"}