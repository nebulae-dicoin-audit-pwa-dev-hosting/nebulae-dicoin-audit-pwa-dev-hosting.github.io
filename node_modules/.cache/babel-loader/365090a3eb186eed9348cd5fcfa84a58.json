{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeResponse = exports.encodeResponse = exports.encodeRequest = void 0;\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst js_sha1_1 = __importDefault(require(\"js-sha1\"));\n\nconst selector_1 = require(\"./selector\");\n/*\n\nQuickfind protocol allows sending information about which rows are already present locally to minimize\nnetwork traffic.\n\nProtocal has 3 phases:\n\nencodeRequest: Done on client. Summarize which rows are already present locally by sharding and then hashing _id:_rev|\nencodeResponse: Done on server. Given complete server list and results of encodeRequest, create list of changes, sharded by first two characters of _id\ndecodeResponse: Done on client. Given encoded response and local list, recreate complete list from server.\n\nInteraction of sort, limit and fields:\n\n- fields present: _rev might be missing. Do not use quickfind\n- limit with no sort: This gives unstable results. Do not use quickfind\n- sort: final rows need to be re-sorted. Since fields not present, is possible.\n- no sort, no limit: always sort by _id\n\n*/\n// Characters to shard by of _id\n\n\nconst shardLength = 2; // Given an array of client rows, create a summary of which rows are present\n\nfunction encodeRequest(clientRows) {\n  // Index by shard\n  clientRows = lodash_1.default.groupBy(clientRows, row => row._id.substr(0, shardLength)); // Hash each one\n\n  const request = lodash_1.default.mapValues(clientRows, rows => hashRows(rows));\n  return request;\n}\n\nexports.encodeRequest = encodeRequest; // Given an array of rows on the server and an encoded request, create encoded response\n\nfunction encodeResponse(serverRows, encodedRequest) {\n  // Index by shard\n  serverRows = lodash_1.default.groupBy(serverRows, row => row._id.substr(0, shardLength)); // Include any that are in encoded request but not present\n\n  for (let key in encodedRequest) {\n    const value = encodedRequest[key];\n\n    if (!serverRows[key]) {\n      serverRows[key] = [];\n    }\n  } // Only keep ones where different from encoded request\n\n\n  const response = lodash_1.default.pickBy(serverRows, (rows, key) => hashRows(rows) !== encodedRequest[key]);\n  return response;\n}\n\nexports.encodeResponse = encodeResponse; // Given encoded response and array of client rows, create array of server rows\n\nfunction decodeResponse(encodedResponse, clientRows, sort) {\n  // Index by shard\n  clientRows = lodash_1.default.groupBy(clientRows, row => row._id.substr(0, shardLength)); // Overwrite with response\n\n  let serverRows = lodash_1.default.extend(clientRows, encodedResponse); // Flatten\n\n  serverRows = lodash_1.default.flatten(lodash_1.default.values(serverRows)); // Sort\n\n  if (sort) {\n    serverRows.sort((0, selector_1.compileSort)(sort));\n  } else {\n    serverRows = lodash_1.default.sortBy(serverRows, \"_id\");\n  }\n\n  return serverRows;\n}\n\nexports.decodeResponse = decodeResponse;\n\nfunction hashRows(rows) {\n  const hash = js_sha1_1.default.create();\n\n  for (let row of lodash_1.default.sortBy(rows, \"_id\")) {\n    hash.update(row._id + \":\" + (row._rev || \"\") + \"|\");\n  } // 80 bits is enough for uniqueness\n\n\n  return hash.hex().substr(0, 20);\n}","map":{"version":3,"sources":["/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/minimongo/lib/quickfind.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","decodeResponse","encodeResponse","encodeRequest","lodash_1","require","js_sha1_1","selector_1","shardLength","clientRows","default","groupBy","row","_id","substr","request","mapValues","rows","hashRows","serverRows","encodedRequest","key","response","pickBy","encodedResponse","sort","extend","flatten","values","compileSort","sortBy","hash","create","update","_rev","hex"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeResponse = exports.encodeResponse = exports.encodeRequest = void 0;\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst js_sha1_1 = __importDefault(require(\"js-sha1\"));\nconst selector_1 = require(\"./selector\");\n/*\n\nQuickfind protocol allows sending information about which rows are already present locally to minimize\nnetwork traffic.\n\nProtocal has 3 phases:\n\nencodeRequest: Done on client. Summarize which rows are already present locally by sharding and then hashing _id:_rev|\nencodeResponse: Done on server. Given complete server list and results of encodeRequest, create list of changes, sharded by first two characters of _id\ndecodeResponse: Done on client. Given encoded response and local list, recreate complete list from server.\n\nInteraction of sort, limit and fields:\n\n- fields present: _rev might be missing. Do not use quickfind\n- limit with no sort: This gives unstable results. Do not use quickfind\n- sort: final rows need to be re-sorted. Since fields not present, is possible.\n- no sort, no limit: always sort by _id\n\n*/\n// Characters to shard by of _id\nconst shardLength = 2;\n// Given an array of client rows, create a summary of which rows are present\nfunction encodeRequest(clientRows) {\n    // Index by shard\n    clientRows = lodash_1.default.groupBy(clientRows, (row) => row._id.substr(0, shardLength));\n    // Hash each one\n    const request = lodash_1.default.mapValues(clientRows, (rows) => hashRows(rows));\n    return request;\n}\nexports.encodeRequest = encodeRequest;\n// Given an array of rows on the server and an encoded request, create encoded response\nfunction encodeResponse(serverRows, encodedRequest) {\n    // Index by shard\n    serverRows = lodash_1.default.groupBy(serverRows, (row) => row._id.substr(0, shardLength));\n    // Include any that are in encoded request but not present\n    for (let key in encodedRequest) {\n        const value = encodedRequest[key];\n        if (!serverRows[key]) {\n            serverRows[key] = [];\n        }\n    }\n    // Only keep ones where different from encoded request\n    const response = lodash_1.default.pickBy(serverRows, (rows, key) => hashRows(rows) !== encodedRequest[key]);\n    return response;\n}\nexports.encodeResponse = encodeResponse;\n// Given encoded response and array of client rows, create array of server rows\nfunction decodeResponse(encodedResponse, clientRows, sort) {\n    // Index by shard\n    clientRows = lodash_1.default.groupBy(clientRows, (row) => row._id.substr(0, shardLength));\n    // Overwrite with response\n    let serverRows = lodash_1.default.extend(clientRows, encodedResponse);\n    // Flatten\n    serverRows = lodash_1.default.flatten(lodash_1.default.values(serverRows));\n    // Sort\n    if (sort) {\n        serverRows.sort((0, selector_1.compileSort)(sort));\n    }\n    else {\n        serverRows = lodash_1.default.sortBy(serverRows, \"_id\");\n    }\n    return serverRows;\n}\nexports.decodeResponse = decodeResponse;\nfunction hashRows(rows) {\n    const hash = js_sha1_1.default.create();\n    for (let row of lodash_1.default.sortBy(rows, \"_id\")) {\n        hash.update(row._id + \":\" + (row._rev || \"\") + \"|\");\n    }\n    // 80 bits is enough for uniqueness\n    return hash.hex().substr(0, 20);\n}\n"]},"metadata":{},"sourceType":"script"}