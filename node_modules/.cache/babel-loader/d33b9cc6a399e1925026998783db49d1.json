{"ast":null,"code":"import lineIntersect from \"@turf/line-intersect\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { getGeom } from \"@turf/invariant\";\nimport { point } from \"@turf/helpers\";\n/**\n * Boolean-Crosses returns True if the intersection results in a geometry whose dimension is one less than\n * the maximum dimension of the two source geometries and the intersection set is interior to\n * both source geometries.\n *\n * Boolean-Crosses returns t (TRUE) for only multipoint/polygon, multipoint/linestring, linestring/linestring, linestring/polygon, and linestring/multipolygon comparisons.\n *\n * @name booleanCrosses\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line1 = turf.lineString([[-2, 2], [4, 2]]);\n * var line2 = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * var cross = turf.booleanCrosses(line1, line2);\n * //=true\n */\n\nfunction booleanCrosses(feature1, feature2) {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n\n  switch (type1) {\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"LineString\":\n          return doMultiPointAndLineStringCross(geom1, geom2);\n\n        case \"Polygon\":\n          return doesMultiPointCrossPoly(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"LineString\":\n      switch (type2) {\n        case \"MultiPoint\":\n          // An inverse operation\n          return doMultiPointAndLineStringCross(geom2, geom1);\n\n        case \"LineString\":\n          return doLineStringsCross(geom1, geom2);\n\n        case \"Polygon\":\n          return doLineStringAndPolygonCross(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"Polygon\":\n      switch (type2) {\n        case \"MultiPoint\":\n          // An inverse operation\n          return doesMultiPointCrossPoly(geom2, geom1);\n\n        case \"LineString\":\n          // An inverse operation\n          return doLineStringAndPolygonCross(geom2, geom1);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\n\nfunction doMultiPointAndLineStringCross(multiPoint, lineString) {\n  var foundIntPoint = false;\n  var foundExtPoint = false;\n  var pointLength = multiPoint.coordinates.length;\n  var i = 0;\n\n  while (i < pointLength && !foundIntPoint && !foundExtPoint) {\n    for (var i2 = 0; i2 < lineString.coordinates.length - 1; i2++) {\n      var incEndVertices = true;\n\n      if (i2 === 0 || i2 === lineString.coordinates.length - 2) {\n        incEndVertices = false;\n      }\n\n      if (isPointOnLineSegment(lineString.coordinates[i2], lineString.coordinates[i2 + 1], multiPoint.coordinates[i], incEndVertices)) {\n        foundIntPoint = true;\n      } else {\n        foundExtPoint = true;\n      }\n    }\n\n    i++;\n  }\n\n  return foundIntPoint && foundExtPoint;\n}\n\nfunction doLineStringsCross(lineString1, lineString2) {\n  var doLinesIntersect = lineIntersect(lineString1, lineString2);\n\n  if (doLinesIntersect.features.length > 0) {\n    for (var i = 0; i < lineString1.coordinates.length - 1; i++) {\n      for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {\n        var incEndVertices = true;\n\n        if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {\n          incEndVertices = false;\n        }\n\n        if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction doLineStringAndPolygonCross(lineString, polygon) {\n  var line = polygonToLine(polygon);\n  var doLinesIntersect = lineIntersect(lineString, line);\n\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction doesMultiPointCrossPoly(multiPoint, polygon) {\n  var foundIntPoint = false;\n  var foundExtPoint = false;\n  var pointLength = multiPoint.coordinates.length;\n\n  for (var i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {\n    if (booleanPointInPolygon(point(multiPoint.coordinates[i]), polygon)) {\n      foundIntPoint = true;\n    } else {\n      foundExtPoint = true;\n    }\n  }\n\n  return foundExtPoint && foundIntPoint;\n}\n/**\n * Is a point on a line segment\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {number[]} lineSegmentStart coord pair of start of line\n * @param {number[]} lineSegmentEnd coord pair of end of line\n * @param {number[]} pt coord pair of point to check\n * @param {boolean} incEnd whether the point is allowed to fall on the line ends\n * @returns {boolean} true/false\n */\n\n\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {\n  var dxc = pt[0] - lineSegmentStart[0];\n  var dyc = pt[1] - lineSegmentStart[1];\n  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  var cross = dxc * dyl - dyc * dxl;\n\n  if (cross !== 0) {\n    return false;\n  }\n\n  if (incEnd) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n\n    return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  } else {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];\n    }\n\n    return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];\n  }\n}\n\nexport default booleanCrosses;","map":null,"metadata":{},"sourceType":"module"}