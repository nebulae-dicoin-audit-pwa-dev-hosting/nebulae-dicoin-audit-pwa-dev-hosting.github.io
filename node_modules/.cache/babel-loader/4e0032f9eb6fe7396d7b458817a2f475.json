{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compileSort = exports.compileDocumentSelector = void 0;\n/*\n========================================\nMeteor is licensed under the MIT License\n========================================\n\nCopyright (C) 2011--2012 Meteor Development Group\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n====================================================================\nThis license applies to all code in Meteor that is not an externally\nmaintained library. Externally maintained libraries have their own\nlicenses, included below:\n====================================================================\n\n*/\n\nvar EJSON_1 = __importDefault(require(\"./EJSON\"));\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar LocalCollection = {}; // Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as\n// arrays.\n\nvar isArray = function isArray(x) {\n  return lodash_1.default.isArray(x) && !EJSON_1.default.isBinary(x);\n};\n\nvar _anyIfArray = function _anyIfArray(x, f) {\n  if (isArray(x)) return lodash_1.default.some(x, f);\n  return f(x);\n};\n\nvar _anyIfArrayPlus = function _anyIfArrayPlus(x, f) {\n  if (f(x)) return true;\n  return isArray(x) && lodash_1.default.some(x, f);\n};\n\nvar hasOperators = function hasOperators(valueSelector) {\n  var theseAreOperators = undefined;\n\n  for (var selKey in valueSelector) {\n    var thisIsOperator = selKey.substr(0, 1) === \"$\";\n\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      throw new Error(\"Inconsistent selector: \" + valueSelector);\n    }\n  }\n\n  return !!theseAreOperators; // {} has no operators\n};\n\nvar compileValueSelector = function compileValueSelector(valueSelector) {\n  if (valueSelector == null) {\n    // undefined or null\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return x == null; // undefined or null\n      });\n    };\n  } // Selector is a non-null primitive (and not an array or RegExp either).\n\n\n  if (!lodash_1.default.isObject(valueSelector)) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return x === valueSelector;\n      });\n    };\n  }\n\n  if (valueSelector instanceof RegExp) {\n    return function (value) {\n      if (value === undefined) return false;\n      return _anyIfArray(value, function (x) {\n        return valueSelector.test(x);\n      });\n    };\n  } // Arrays match either identical arrays or arrays that contain it as a value.\n\n\n  if (isArray(valueSelector)) {\n    return function (value) {\n      if (!isArray(value)) return false;\n      return _anyIfArrayPlus(value, function (x) {\n        return LocalCollection._f._equal(valueSelector, x);\n      });\n    };\n  } // It's an object, but not an array or regexp.\n\n\n  if (hasOperators(valueSelector)) {\n    var operatorFunctions = [];\n    lodash_1.default.each(valueSelector, function (operand, operator) {\n      if (!lodash_1.default.has(VALUE_OPERATORS, operator)) throw new Error(\"Unrecognized operator: \" + operator);\n      operatorFunctions.push(VALUE_OPERATORS[operator](operand, valueSelector[\"$options\"]));\n    });\n    return function (value) {\n      return lodash_1.default.every(operatorFunctions, function (f) {\n        return f(value);\n      });\n    };\n  } // It's a literal; compare value (or element of value array) directly to the\n  // selector.\n\n\n  return function (value) {\n    return _anyIfArray(value, function (x) {\n      return LocalCollection._f._equal(valueSelector, x);\n    });\n  };\n}; // XXX can factor out common logic below\n\n\nvar LOGICAL_OPERATORS = {\n  $and: function $and(subSelector) {\n    if (!isArray(subSelector) || lodash_1.default.isEmpty(subSelector)) throw Error(\"$and/$or/$nor must be nonempty array\");\n    var subSelectorFunctions = lodash_1.default.map(subSelector, compileDocumentSelector);\n    return function (doc) {\n      return lodash_1.default.every(subSelectorFunctions, function (f) {\n        return f(doc);\n      });\n    };\n  },\n  $or: function $or(subSelector) {\n    if (!isArray(subSelector) || lodash_1.default.isEmpty(subSelector)) throw Error(\"$and/$or/$nor must be nonempty array\");\n    var subSelectorFunctions = lodash_1.default.map(subSelector, compileDocumentSelector);\n    return function (doc) {\n      return lodash_1.default.some(subSelectorFunctions, function (f) {\n        return f(doc);\n      });\n    };\n  },\n  $nor: function $nor(subSelector) {\n    if (!isArray(subSelector) || lodash_1.default.isEmpty(subSelector)) throw Error(\"$and/$or/$nor must be nonempty array\");\n    var subSelectorFunctions = lodash_1.default.map(subSelector, compileDocumentSelector);\n    return function (doc) {\n      return lodash_1.default.every(subSelectorFunctions, function (f) {\n        return !f(doc);\n      });\n    };\n  },\n  $where: function $where(selectorValue) {\n    if (!(selectorValue instanceof Function)) {\n      selectorValue = Function(\"return \" + selectorValue);\n    }\n\n    return function (doc) {\n      return selectorValue.call(doc);\n    };\n  }\n};\nvar VALUE_OPERATORS = {\n  $in: function $in(operand) {\n    if (!isArray(operand)) throw new Error(\"Argument to $in must be array\"); // Create index if all strings\n\n    var index = null;\n    if (lodash_1.default.every(operand, lodash_1.default.isString)) index = lodash_1.default.keyBy(operand);\n    return function (value) {\n      return _anyIfArrayPlus(value, function (x) {\n        if (lodash_1.default.isString(x) && index !== null) return index[x] != undefined;\n        return lodash_1.default.some(operand, function (operandElt) {\n          return LocalCollection._f._equal(operandElt, x);\n        });\n      });\n    };\n  },\n  $all: function $all(operand) {\n    if (!isArray(operand)) throw new Error(\"Argument to $all must be array\");\n    return function (value) {\n      if (!isArray(value)) return false;\n      return lodash_1.default.every(operand, function (operandElt) {\n        return lodash_1.default.some(value, function (valueElt) {\n          return LocalCollection._f._equal(operandElt, valueElt);\n        });\n      });\n    };\n  },\n  $lt: function $lt(operand) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._cmp(x, operand) < 0;\n      });\n    };\n  },\n  $lte: function $lte(operand) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._cmp(x, operand) <= 0;\n      });\n    };\n  },\n  $gt: function $gt(operand) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._cmp(x, operand) > 0;\n      });\n    };\n  },\n  $gte: function $gte(operand) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._cmp(x, operand) >= 0;\n      });\n    };\n  },\n  $ne: function $ne(operand) {\n    return function (value) {\n      return !_anyIfArrayPlus(value, function (x) {\n        return LocalCollection._f._equal(x, operand);\n      });\n    };\n  },\n  $nin: function $nin(operand) {\n    if (!isArray(operand)) throw new Error(\"Argument to $nin must be array\");\n    var inFunction = VALUE_OPERATORS.$in(operand);\n    return function (value) {\n      // Field doesn't exist, so it's not-in operand\n      if (value === undefined) return true;\n      return !inFunction(value);\n    };\n  },\n  $exists: function $exists(operand) {\n    return function (value) {\n      return operand === (value !== undefined);\n    };\n  },\n  $mod: function $mod(operand) {\n    var divisor = operand[0],\n        remainder = operand[1];\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return x % divisor === remainder;\n      });\n    };\n  },\n  $size: function $size(operand) {\n    return function (value) {\n      return isArray(value) && operand === value.length;\n    };\n  },\n  $type: function $type(operand) {\n    return function (value) {\n      // A nonexistent field is of no type.\n      if (value === undefined) return false; // Definitely not _anyIfArrayPlus: $type: 4 only matches arrays that have\n      // arrays as elements according to the Mongo docs.\n\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._type(x) === operand;\n      });\n    };\n  },\n  $regex: function $regex(operand, options) {\n    if (options !== undefined) {\n      // Options passed in $options (even the empty string) always overrides\n      // options in the RegExp object itself.\n      // Be clear that we only support the JS-supported options, not extended\n      // ones (eg, Mongo supports x and s). Ideally we would implement x and s\n      // by transforming the regexp, but not today...\n      if (/[^gim]/.test(options)) throw new Error(\"Only the i, m, and g regexp options are supported\");\n      var regexSource = operand instanceof RegExp ? operand.source : operand;\n      operand = new RegExp(regexSource, options);\n    } else if (!(operand instanceof RegExp)) {\n      operand = new RegExp(operand);\n    }\n\n    return function (value) {\n      if (value === undefined) return false;\n      return _anyIfArray(value, function (x) {\n        return operand.test(x);\n      });\n    };\n  },\n  $options: function $options(operand) {\n    // evaluation happens at the $regex function above\n    return function (value) {\n      return true;\n    };\n  },\n  $elemMatch: function $elemMatch(operand) {\n    var matcher = compileDocumentSelector(operand);\n    return function (value) {\n      if (!isArray(value)) return false;\n      return lodash_1.default.some(value, function (x) {\n        return matcher(x);\n      });\n    };\n  },\n  $not: function $not(operand) {\n    var matcher = compileValueSelector(operand);\n    return function (value) {\n      return !matcher(value);\n    };\n  },\n  $near: function $near(operand) {\n    // Always returns true. Must be handled in post-filter/sort/limit\n    return function (value) {\n      return true;\n    };\n  },\n  $geoIntersects: function $geoIntersects(operand) {\n    // Always returns true. Must be handled in post-filter/sort/limit\n    return function (value) {\n      return true;\n    };\n  }\n}; // helpers used by compiled selector code\n\nLocalCollection._f = {\n  // XXX for _all and _in, consider building 'inquery' at compile time..\n  _type: function _type(v) {\n    if (typeof v === \"number\") return 1;\n    if (typeof v === \"string\") return 2;\n    if (typeof v === \"boolean\") return 8;\n    if (isArray(v)) return 4;\n    if (v === null) return 10;\n    if (v instanceof RegExp) return 11;\n    if (typeof v === \"function\") // note that typeof(/x/) === \"function\"\n      return 13;\n    if (v instanceof Date) return 9;\n    if (EJSON_1.default.isBinary(v)) return 5;\n    return 3; // object\n    // XXX support some/all of these:\n    // 14, symbol\n    // 15, javascript code with scope\n    // 16, 18: 32-bit/64-bit integer\n    // 17, timestamp\n    // 255, minkey\n    // 127, maxkey\n  },\n  // deep equality test: use for literal document and array matches\n  _equal: function _equal(a, b) {\n    return EJSON_1.default.equals(a, b, {\n      keyOrderSensitive: true\n    });\n  },\n  // maps a type code to a value that can be used to sort values of\n  // different types\n  _typeorder: function _typeorder(t) {\n    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types\n    // XXX what is the correct sort position for Javascript code?\n    // ('100' in the matrix below)\n    // XXX minkey/maxkey\n    return [-1, 1, 2, 3, 4, 5, -1, 6, 7, 8, 0, 9, -1, 100, 2, 100, 1, 8, 1 // 64-bit int\n    ][t];\n  },\n  // compare two values of unknown type according to BSON ordering\n  // semantics. (as an extension, consider 'undefined' to be less than\n  // any other value.) return negative if a is less, positive if b is\n  // less, or 0 if equal\n  _cmp: function _cmp(a, b) {\n    if (a === undefined) return b === undefined ? 0 : -1;\n    if (b === undefined) return 1;\n\n    var ta = LocalCollection._f._type(a);\n\n    var tb = LocalCollection._f._type(b);\n\n    var oa = LocalCollection._f._typeorder(ta);\n\n    var ob = LocalCollection._f._typeorder(tb);\n\n    if (oa !== ob) return oa < ob ? -1 : 1;\n    if (ta !== tb) // XXX need to implement this if we implement Symbol or integers, or\n      // Timestamp\n      throw Error(\"Missing type coercion logic in _cmp\");\n\n    if (ta === 7) {\n      // ObjectID\n      // Convert to string.\n      ta = tb = 2;\n      a = a.toHexString();\n      b = b.toHexString();\n    }\n\n    if (ta === 9) {\n      // Date\n      // Convert to millis.\n      ta = tb = 1;\n      a = a.getTime();\n      b = b.getTime();\n    }\n\n    if (ta === 1) // double\n      return a - b;\n    if (tb === 2) // string\n      return a < b ? -1 : a === b ? 0 : 1;\n\n    if (ta === 3) {\n      // Object\n      // this could be much more efficient in the expected case ...\n      var to_array = function to_array(obj) {\n        var ret = [];\n\n        for (var key in obj) {\n          ret.push(key);\n          ret.push(obj[key]);\n        }\n\n        return ret;\n      };\n\n      return LocalCollection._f._cmp(to_array(a), to_array(b));\n    }\n\n    if (ta === 4) {\n      // Array\n      for (var i = 0;; i++) {\n        if (i === a.length) return i === b.length ? 0 : -1;\n        if (i === b.length) return 1;\n\n        var s = LocalCollection._f._cmp(a[i], b[i]);\n\n        if (s !== 0) return s;\n      }\n    }\n\n    if (ta === 5) {\n      // binary\n      // Surprisingly, a small binary blob is always less than a large one in\n      // Mongo.\n      if (a.length !== b.length) return a.length - b.length;\n\n      for (i = 0; i < a.length; i++) {\n        if (a[i] < b[i]) return -1;\n        if (a[i] > b[i]) return 1;\n      }\n\n      return 0;\n    }\n\n    if (ta === 8) {\n      // boolean\n      if (a) return b ? 0 : 1;\n      return b ? -1 : 0;\n    }\n\n    if (ta === 10) // null\n      return 0;\n    if (ta === 11) // regexp\n      throw Error(\"Sorting not supported on regular expression\"); // XXX\n    // 13: javascript code\n    // 14: symbol\n    // 15: javascript code with scope\n    // 16: 32-bit integer\n    // 17: timestamp\n    // 18: 64-bit integer\n    // 255: minkey\n    // 127: maxkey\n\n    if (ta === 13) // javascript code\n      throw Error(\"Sorting not supported on Javascript code\"); // XXX\n\n    throw Error(\"Unknown type to sort\");\n  }\n}; // For unit tests. True if the given document matches the given\n// selector.\n\nLocalCollection._matches = function (selector, doc) {\n  return LocalCollection._compileSelector(selector)(doc);\n}; // _makeLookupFunction(key) returns a lookup function.\n//\n// A lookup function takes in a document and returns an array of matching\n// values.  This array has more than one element if any segment of the key other\n// than the last one is an array.  ie, any arrays found when doing non-final\n// lookups result in this function \"branching\"; each element in the returned\n// array represents the value found at this branch. If any branch doesn't have a\n// final value for the full key, its element in the returned list will be\n// undefined. It always returns a non-empty array.\n//\n// _makeLookupFunction('a.x')({a: {x: 1}}) returns [1]\n// _makeLookupFunction('a.x')({a: {x: [1]}}) returns [[1]]\n// _makeLookupFunction('a.x')({a: 5})  returns [undefined]\n// _makeLookupFunction('a.x')({a: [{x: 1},\n//                                 {x: [2]},\n//                                 {y: 3}]})\n//   returns [1, [2], undefined]\n\n\nLocalCollection._makeLookupFunction = function (key) {\n  var dotLocation = key.indexOf(\".\");\n  var first, lookupRest, nextIsNumeric;\n\n  if (dotLocation === -1) {\n    first = key;\n  } else {\n    first = key.substr(0, dotLocation);\n    var rest = key.substr(dotLocation + 1);\n    lookupRest = LocalCollection._makeLookupFunction(rest); // Is the next (perhaps final) piece numeric (ie, an array lookup?)\n\n    nextIsNumeric = /^\\d+(\\.|$)/.test(rest);\n  }\n\n  return function (doc) {\n    if (doc == null) // null or undefined\n      return [undefined];\n    var firstLevel = doc[first]; // We don't \"branch\" at the final level.\n\n    if (!lookupRest) return [firstLevel]; // It's an empty array, and we're not done: we won't find anything.\n\n    if (isArray(firstLevel) && firstLevel.length === 0) return [undefined]; // For each result at this level, finish the lookup on the rest of the key,\n    // and return everything we find. Also, if the next result is a number,\n    // don't branch here.\n    //\n    // Technically, in MongoDB, we should be able to handle the case where\n    // objects have numeric keys, but Mongo doesn't actually handle this\n    // consistently yet itself, see eg\n    // https://jira.mongodb.org/browse/SERVER-2898\n    // https://github.com/mongodb/mongo/blob/master/jstests/array_match2.js\n\n    if (!isArray(firstLevel) || nextIsNumeric) firstLevel = [firstLevel];\n    return Array.prototype.concat.apply([], lodash_1.default.map(firstLevel, lookupRest));\n  };\n};\n/** Compile a document selector (query) to a lambda function */\n\n\nfunction compileDocumentSelector(docSelector) {\n  var perKeySelectors = [];\n  lodash_1.default.each(docSelector, function (subSelector, key) {\n    if (key.substr(0, 1) === \"$\") {\n      // Outer operators are either logical operators (they recurse back into\n      // this function), or $where.\n      if (!lodash_1.default.has(LOGICAL_OPERATORS, key)) throw new Error(\"Unrecognized logical operator: \" + key);\n      perKeySelectors.push(LOGICAL_OPERATORS[key](subSelector));\n    } else {\n      var lookUpByIndex = LocalCollection._makeLookupFunction(key);\n\n      var valueSelectorFunc = compileValueSelector(subSelector);\n      perKeySelectors.push(function (doc) {\n        var branchValues = lookUpByIndex(doc); // We apply the selector to each \"branched\" value and return true if any\n        // match. This isn't 100% consistent with MongoDB; eg, see:\n        // https://jira.mongodb.org/browse/SERVER-8585\n\n        return lodash_1.default.some(branchValues, valueSelectorFunc);\n      });\n    }\n  });\n  return function (doc) {\n    return lodash_1.default.every(perKeySelectors, function (f) {\n      return f(doc);\n    });\n  };\n}\n\nexports.compileDocumentSelector = compileDocumentSelector; // Given a selector, return a function that takes one argument, a\n// document, and returns true if the document matches the selector,\n// else false.\n\nLocalCollection._compileSelector = function (selector) {\n  // you can pass a literal function instead of a selector\n  if (selector instanceof Function) return function (doc) {\n    return selector.call(doc);\n  }; // shorthand -- scalars match _id\n\n  if (LocalCollection._selectorIsId(selector)) {\n    return function (doc) {\n      return EJSON_1.default.equals(doc._id, selector);\n    };\n  } // protect against dangerous selectors.  falsey and {_id: falsey} are both\n  // likely programmer error, and not what you want, particularly for\n  // destructive operations.\n\n\n  if (!selector || \"_id\" in selector && !selector._id) return function (doc) {\n    return false;\n  }; // Top level can't be an array or true or binary.\n\n  if (typeof selector === \"boolean\" || isArray(selector) || EJSON_1.default.isBinary(selector)) throw new Error(\"Invalid selector: \" + selector);\n  return compileDocumentSelector(selector);\n}; // Give a sort spec, which can be in any of these forms:\n//   {\"key1\": 1, \"key2\": -1}\n//   [[\"key1\", \"asc\"], [\"key2\", \"desc\"]]\n//   [\"key1\", [\"key2\", \"desc\"]]\n//\n// (.. with the first form being dependent on the key enumeration\n// behavior of your javascript VM, which usually does what you mean in\n// this case if the key names don't look like integers ..)\n//\n// return a function that takes two objects, and returns -1 if the\n// first object comes first in order, 1 if the second object comes\n// first, or 0 if neither object comes before the other.\n\n\nLocalCollection._compileSort = function (spec) {\n  var sortSpecParts = [];\n\n  if (spec instanceof Array) {\n    for (var i = 0; i < spec.length; i++) {\n      if (typeof spec[i] === \"string\") {\n        sortSpecParts.push({\n          lookup: LocalCollection._makeLookupFunction(spec[i]),\n          ascending: true\n        });\n      } else {\n        sortSpecParts.push({\n          lookup: LocalCollection._makeLookupFunction(spec[i][0]),\n          ascending: spec[i][1] !== \"desc\"\n        });\n      }\n    }\n  } else if (typeof spec === \"object\") {\n    for (var key in spec) {\n      sortSpecParts.push({\n        lookup: LocalCollection._makeLookupFunction(key),\n        ascending: spec[key] >= 0\n      });\n    }\n  } else {\n    throw Error(\"Bad sort specification: \" + JSON.stringify(spec));\n  }\n\n  if (sortSpecParts.length === 0) return function () {\n    return 0;\n  }; // reduceValue takes in all the possible values for the sort key along various\n  // branches, and returns the min or max value (according to the bool\n  // findMin). Each value can itself be an array, and we look at its values\n  // too. (ie, we do a single level of flattening on branchValues, then find the\n  // min/max.)\n\n  var reduceValue = function reduceValue(branchValues, findMin) {\n    var reduced;\n    var first = true; // Iterate over all the values found in all the branches, and if a value is\n    // an array itself, iterate over the values in the array separately.\n\n    lodash_1.default.each(branchValues, function (branchValue) {\n      // Value not an array? Pretend it is.\n      if (!isArray(branchValue)) branchValue = [branchValue]; // Value is an empty array? Pretend it was missing, since that's where it\n      // should be sorted.\n\n      if (isArray(branchValue) && branchValue.length === 0) branchValue = [undefined];\n      lodash_1.default.each(branchValue, function (value) {\n        // We should get here at least once: lookup functions return non-empty\n        // arrays, so the outer loop runs at least once, and we prevented\n        // branchValue from being an empty array.\n        if (first) {\n          reduced = value;\n          first = false;\n        } else {\n          // Compare the value we found to the value we found so far, saving it\n          // if it's less (for an ascending sort) or more (for a descending\n          // sort).\n          var cmp = LocalCollection._f._cmp(reduced, value);\n\n          if (findMin && cmp > 0 || !findMin && cmp < 0) reduced = value;\n        }\n      });\n    });\n    return reduced;\n  };\n\n  return function (a, b) {\n    for (var i = 0; i < sortSpecParts.length; ++i) {\n      var specPart = sortSpecParts[i];\n      var aValue = reduceValue(specPart.lookup(a), specPart.ascending);\n      var bValue = reduceValue(specPart.lookup(b), specPart.ascending);\n\n      var compare = LocalCollection._f._cmp(aValue, bValue);\n\n      if (compare !== 0) return specPart.ascending ? compare : -compare;\n    }\n\n    return 0;\n  };\n};\n\nexports.compileSort = LocalCollection._compileSort;","map":null,"metadata":{},"sourceType":"script"}