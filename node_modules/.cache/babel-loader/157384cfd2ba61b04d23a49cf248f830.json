{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sebastianmolano/NebulaE/Projects/GTPC/dicon-audit-pwa/frontend/dicon-audit-pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar async_1 = __importDefault(require(\"async\"));\n\nvar utils = __importStar(require(\"./utils\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar selector_1 = require(\"./selector\"); // Do nothing callback for success\n\n\nfunction doNothing() {} // WebSQLDb adapter for minimongo DB\n// Supports sqlite plugin, if available and specified in option as {storage: 'sqlite'}\n\n\nvar WebSQLDb = /*#__PURE__*/function () {\n  function WebSQLDb(options, success, error) {\n    var _this = this;\n\n    _classCallCheck(this, WebSQLDb);\n\n    this.collections = {};\n\n    if (options.storage === \"sqlite\" && window[\"sqlitePlugin\"]) {\n      // sqlite plugin does not support db.version\n      // and since db operations can only be executed once the db is properly open\n      // we add the schema version migration to the success callback\n      window[\"sqlitePlugin\"].openDatabase({\n        name: \"minimongo_\" + options.namespace,\n        location: \"default\"\n      }, function (sqliteDb) {\n        console.log(\"Database open successful\");\n        _this.db = sqliteDb;\n        console.log(\"Checking version\");\n\n        _this.db.executeSql(\"PRAGMA user_version\", [], function (rs) {\n          var version = rs.rows.item(0).user_version;\n\n          if (version === 0) {\n            _this.db.transaction(function (tx) {\n              tx.executeSql(\"CREATE TABLE docs (\\ncol TEXT NOT NULL,\\nid TEXT NOT NULL,\\nstate TEXT NOT NULL,\\ndoc TEXT,\\nbase TEXT,\\nPRIMARY KEY (col, id));\", [], doNothing, function (tx, err) {\n                return error(err);\n              });\n              tx.executeSql(\"PRAGMA user_version = 2\", [], doNothing, function (tx, err) {\n                return error(err);\n              });\n              return success(_this);\n            });\n          } else {\n            success(_this);\n          }\n        }, function (err) {\n          console.log(\"version check error :: \", JSON.stringify(err));\n          error(err);\n        });\n      }, function (err) {\n        console.log(\"Error opening databse :: \", JSON.stringify(err));\n        error(err);\n      });\n    } else {\n      try {\n        // Create database\n        // TODO escape name\n        this.db = window[\"openDatabase\"](\"minimongo_\" + options.namespace, \"\", \"Minimongo:\" + options.namespace, 5 * 1024 * 1024);\n\n        if (!this.db) {\n          return error(new Error(\"Failed to create database\"));\n        }\n      } catch (ex) {\n        if (error) {\n          error(ex);\n        }\n\n        return;\n      }\n    }\n\n    var migrateToV1 = function migrateToV1(tx) {\n      return tx.executeSql(\"CREATE TABLE docs (\\ncol TEXT NOT NULL,\\nid TEXT NOT NULL,\\nstate TEXT NOT NULL,\\ndoc TEXT,\\nPRIMARY KEY (col, id));\", [], doNothing, function (tx, err) {\n        return error(err);\n      });\n    };\n\n    var migrateToV2 = function migrateToV2(tx) {\n      return tx.executeSql(\"ALTER TABLE docs ADD COLUMN base TEXT;\", [], doNothing, function (tx, err) {\n        return error(err);\n      });\n    }; // Check if at v2 version\n\n\n    var checkV2 = function checkV2() {\n      if (_this.db.version === \"1.0\") {\n        return _this.db.changeVersion(\"1.0\", \"2.0\", migrateToV2, error, function () {\n          if (success) {\n            return success(_this);\n          }\n        });\n      } else if (_this.db.version !== \"2.0\") {\n        return error(\"Unknown db version \" + _this.db.version);\n      } else {\n        if (success) {\n          return success(_this);\n        }\n      }\n    };\n\n    if (!options.storage) {\n      if (!this.db.version) {\n        this.db.changeVersion(\"\", \"1.0\", migrateToV1, error, checkV2);\n      } else {\n        checkV2();\n      }\n    }\n\n    return this.db;\n  }\n\n  _createClass(WebSQLDb, [{\n    key: \"addCollection\",\n    value: function addCollection(name, success, error) {\n      var collection = new Collection(name, this.db);\n      this[name] = collection;\n      this.collections[name] = collection;\n\n      if (success) {\n        return success();\n      }\n    }\n  }, {\n    key: \"removeCollection\",\n    value: function removeCollection(name, success, error) {\n      delete this[name];\n      delete this.collections[name]; // Remove all documents of collection\n\n      return this.db.transaction(function (tx) {\n        return tx.executeSql(\"DELETE FROM docs WHERE col = ?\", [name], success, function (tx, err) {\n          return error(err);\n        });\n      }, error);\n    }\n  }, {\n    key: \"getCollectionNames\",\n    value: function getCollectionNames() {\n      return lodash_1.default.keys(this.collections);\n    }\n  }]);\n\n  return WebSQLDb;\n}();\n\nexports.default = WebSQLDb; // Stores data in indexeddb store\n\nvar Collection = /*#__PURE__*/function () {\n  function Collection(name, db) {\n    _classCallCheck(this, Collection);\n\n    this.name = name;\n    this.db = db;\n  }\n\n  _createClass(Collection, [{\n    key: \"find\",\n    value: function find(selector, options) {\n      var _this2 = this;\n\n      return {\n        fetch: function fetch(success, error) {\n          return _this2._findFetch(selector, options, success, error);\n        }\n      };\n    }\n  }, {\n    key: \"findOne\",\n    value: function findOne(selector, options, success, error) {\n      if (lodash_1.default.isFunction(options)) {\n        ;\n        var _ref = [{}, options, success];\n        options = _ref[0];\n        success = _ref[1];\n        error = _ref[2];\n      }\n\n      return this.find(selector, options).fetch(function (results) {\n        if (success != null) {\n          return success(results.length > 0 ? results[0] : null);\n        }\n      }, error);\n    }\n  }, {\n    key: \"_findFetch\",\n    value: function _findFetch(selector, options, success, error) {\n      var _this3 = this;\n\n      // Android 2.x requires error callback\n      error = error || function () {}; // Get all docs from collection\n\n\n      return this.db.readTransaction(function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ?\", [_this3.name], function (tx, results) {\n          var docs = [];\n\n          for (var i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n            var row = results.rows.item(i);\n\n            if (row.state !== \"removed\") {\n              docs.push(JSON.parse(row.doc));\n            }\n          }\n\n          if (success != null) {\n            return success((0, utils_1.processFind)(docs, selector, options));\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      }, error);\n    }\n  }, {\n    key: \"upsert\",\n    value: function upsert(docs, bases, success, error) {\n      var _this4 = this;\n\n      var items;\n\n      var _utils$regularizeUpse = utils.regularizeUpsert(docs, bases, success, error);\n\n      var _utils$regularizeUpse2 = _slicedToArray(_utils$regularizeUpse, 3);\n\n      items = _utils$regularizeUpse2[0];\n      success = _utils$regularizeUpse2[1];\n      error = _utils$regularizeUpse2[2];\n\n      // Android 2.x requires error callback\n      error = error || function () {};\n\n      return this.db.transaction(function (tx) {\n        var ids = lodash_1.default.map(items, function (item) {\n          return item.doc._id;\n        }); // Get bases\n\n        bases = {};\n        return async_1.default.eachSeries(ids, function (id, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this4.name, id], function (tx2, results) {\n            tx = tx2;\n\n            if (results.rows.length > 0) {\n              var row = results.rows.item(0);\n\n              if (row.state === \"upserted\") {\n                bases[row.id] = row.base ? JSON.parse(row.base) : null;\n              } else if (row.state === \"cached\") {\n                bases[row.id] = JSON.parse(row.doc);\n              }\n            }\n\n            return callback();\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function () {\n          return function () {\n            var result = [];\n\n            var _iterator = _createForOfIteratorHelper(items),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var item = _step.value;\n                var base;\n                var id = item.doc._id; // Prefer explicit base\n\n                if (item.base !== undefined) {\n                  ;\n                  base = item.base;\n                } else if (bases[id]) {\n                  base = bases[id];\n                } else {\n                  base = null;\n                }\n\n                result.push(tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc, base) VALUES (?, ?, ?, ?, ?)\", [_this4.name, item.doc._id, \"upserted\", JSON.stringify(item.doc), JSON.stringify(base)], doNothing, function (tx, err) {\n                  return error(err);\n                }));\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            return result;\n          }();\n        });\n      }, error, function () {\n        if (success) {\n          return success(docs);\n        }\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(id, success, error) {\n      var _this5 = this;\n\n      // Special case for filter-type remove\n      if (lodash_1.default.isObject(id)) {\n        this.find(id).fetch(function (rows) {\n          return async_1.default.each(rows, function (row, cb) {\n            return _this5.remove(row._id, function () {\n              return cb();\n            }, cb);\n          }, function () {\n            return success();\n          });\n        }, error);\n        return;\n      } // Android 2.x requires error callback\n\n\n      error = error || function () {}; // Find record\n\n\n      return this.db.transaction(function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this5.name, id], function (tx, results) {\n          if (results.rows.length > 0) {\n            // Change to removed\n            return tx.executeSql('UPDATE docs SET state=\"removed\" WHERE col = ? AND id = ?', [_this5.name, id], function () {\n              if (success) {\n                return success(id);\n              }\n            }, function (tx, err) {\n              return error(err);\n            });\n          } else {\n            return tx.executeSql(\"INSERT INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this5.name, id, \"removed\", JSON.stringify({\n              _id: id\n            })], function () {\n              if (success) {\n                return success(id);\n              }\n            }, function (tx, err) {\n              return error(err);\n            });\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      }, error);\n    }\n  }, {\n    key: \"cache\",\n    value: function cache(docs, selector, options, success, error) {\n      var _this6 = this;\n\n      // Android 2.x requires error callback\n      error = error || function () {};\n\n      return this.db.transaction(function (tx) {\n        // Add all non-local that are not upserted or removed\n        return async_1.default.eachSeries(docs, function (doc, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this6.name, doc._id], function (tx, results) {\n            // Check if present and not upserted/deleted\n            if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n              var existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null; // Exclude any excluded _ids from being cached/uncached\n\n              if (options && options.exclude && options.exclude.includes(doc._id)) {\n                callback();\n                return;\n              } // If _rev present, make sure that not overwritten by lower or equal _rev\n\n\n              if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n                // Upsert\n                return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this6.name, doc._id, \"cached\", JSON.stringify(doc)], function () {\n                  return callback();\n                }, function (tx, err) {\n                  return error(err);\n                });\n              } else {\n                return callback();\n              }\n            } else {\n              return callback();\n            }\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function (err) {\n          var sort;\n\n          if (err) {\n            if (error) {\n              error(err);\n            }\n\n            return;\n          } // Rows have been cached, now look for stale ones to remove\n\n\n          var docsMap = lodash_1.default.fromPairs(lodash_1.default.zip(lodash_1.default.map(docs, \"_id\"), docs));\n\n          if (options.sort) {\n            sort = (0, selector_1.compileSort)(options.sort);\n          } // Perform query, removing rows missing in docs from local db\n\n\n          return _this6.find(selector, options).fetch(function (results) {\n            return _this6.db.transaction(function (tx) {\n              return async_1.default.eachSeries(results, function (result, callback) {\n                // If not present in docs and is present locally and not upserted/deleted\n                return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this6.name, result._id], function (tx, rows) {\n                  if (!docsMap[result._id] && rows.rows.length > 0 && rows.rows.item(0).state === \"cached\") {\n                    // Exclude any excluded _ids from being cached/uncached\n                    if (options && options.exclude && options.exclude.includes(result._id)) {\n                      callback();\n                      return;\n                    } // If at limit\n\n\n                    if (options.limit && docs.length === options.limit) {\n                      // If past end on sorted limited, ignore\n                      if (options.sort && sort(result, lodash_1.default.last(docs)) >= 0) {\n                        return callback();\n                      } // If no sort, ignore\n\n\n                      if (!options.sort) {\n                        return callback();\n                      }\n                    } // Item is gone from server, remove locally\n\n\n                    return tx.executeSql(\"DELETE FROM docs WHERE col = ? AND id = ?\", [_this6.name, result._id], function () {\n                      return callback();\n                    }, function (tx, err) {\n                      return error(err);\n                    });\n                  } else {\n                    return callback();\n                  }\n                }, function (tx, err) {\n                  return error(err);\n                });\n              }, function (err) {\n                if (err != null) {\n                  if (error != null) {\n                    error(err);\n                  }\n\n                  return;\n                }\n\n                if (success != null) {\n                  return success();\n                }\n              });\n            }, error);\n          }, error);\n        });\n      }, error);\n    }\n  }, {\n    key: \"pendingUpserts\",\n    value: function pendingUpserts(success, error) {\n      var _this7 = this;\n\n      // Android 2.x requires error callback\n      error = error || function () {};\n\n      return this.db.readTransaction(function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [_this7.name, \"upserted\"], function (tx, results) {\n          var docs = [];\n\n          for (var i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n            var row = results.rows.item(i);\n            docs.push({\n              doc: JSON.parse(row.doc),\n              base: row.base ? JSON.parse(row.base) : null\n            });\n          }\n\n          if (success != null) {\n            return success(docs);\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      }, error);\n    }\n  }, {\n    key: \"pendingRemoves\",\n    value: function pendingRemoves(success, error) {\n      var _this8 = this;\n\n      // Android 2.x requires error callback\n      error = error || function () {};\n\n      return this.db.readTransaction(function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [_this8.name, \"removed\"], function (tx, results) {\n          var docs = [];\n\n          for (var i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n            var row = results.rows.item(i);\n            docs.push(JSON.parse(row.doc)._id);\n          }\n\n          if (success != null) {\n            return success(docs);\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      }, error);\n    }\n  }, {\n    key: \"resolveUpserts\",\n    value: function resolveUpserts(upserts, success, error) {\n      var _this9 = this;\n\n      // Android 2.x requires error callback\n      error = error || function () {}; // Find records\n\n\n      return this.db.transaction(function (tx) {\n        return async_1.default.eachSeries(upserts, function (upsert, cb) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this9.name, upsert.doc._id], function (tx, results) {\n            if (results.rows.length > 0 && results.rows.item(0).state === \"upserted\") {\n              // Only safely remove upsert if doc is the same\n              if (lodash_1.default.isEqual(JSON.parse(results.rows.item(0).doc), upsert.doc)) {\n                tx.executeSql('UPDATE docs SET state=\"cached\" WHERE col = ? AND id = ?', [_this9.name, upsert.doc._id], doNothing, function (tx, err) {\n                  return error(err);\n                });\n                return cb();\n              } else {\n                tx.executeSql(\"UPDATE docs SET base=? WHERE col = ? AND id = ?\", [JSON.stringify(upsert.doc), _this9.name, upsert.doc._id], doNothing, function (tx, err) {\n                  return error(err);\n                });\n                return cb();\n              }\n            } else {\n              // Upsert removed, which is fine\n              return cb();\n            }\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function (err) {\n          if (err) {\n            return error(err);\n          } // Success\n\n\n          if (success) {\n            return success();\n          }\n        });\n      }, error);\n    }\n  }, {\n    key: \"resolveRemove\",\n    value: function resolveRemove(id, success, error) {\n      var _this10 = this;\n\n      // Android 2.x requires error callback\n      error = error || function () {}; // Find record\n\n\n      return this.db.transaction(function (tx) {\n        // Only safely remove if removed state\n        return tx.executeSql('DELETE FROM docs WHERE state=\"removed\" AND col = ? AND id = ?', [_this10.name, id], function () {\n          if (success) {\n            return success(id);\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      }, error);\n    } // Add but do not overwrite or record as upsert\n\n  }, {\n    key: \"seed\",\n    value: function seed(docs, success, error) {\n      var _this11 = this;\n\n      if (!lodash_1.default.isArray(docs)) {\n        docs = [docs];\n      } // Android 2.x requires error callback\n\n\n      error = error || function () {};\n\n      return this.db.transaction(function (tx) {\n        // Add all non-local that are not upserted or removed\n        return async_1.default.eachSeries(docs, function (doc, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this11.name, doc._id], function (tx, results) {\n            // Check if present\n            if (results.rows.length === 0) {\n              // Upsert\n              return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this11.name, doc._id, \"cached\", JSON.stringify(doc)], function () {\n                return callback();\n              }, function (tx, err) {\n                return error(err);\n              });\n            } else {\n              return callback();\n            }\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function (err) {\n          if (err) {\n            if (error) {\n              return error(err);\n            }\n          } else {\n            if (success) {\n              return success();\n            }\n          }\n        });\n      }, error);\n    } // Add but do not overwrite upsert/removed and do not record as upsert\n\n  }, {\n    key: \"cacheOne\",\n    value: function cacheOne(doc, success, error) {\n      return this.cacheList([doc], success, error);\n    }\n  }, {\n    key: \"cacheList\",\n    value: function cacheList(docs, success, error) {\n      var _this12 = this;\n\n      // Android 2.x requires error callback\n      error = error || function () {};\n\n      return this.db.transaction(function (tx) {\n        // Add all non-local that are not upserted or removed\n        return async_1.default.eachSeries(docs, function (doc, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this12.name, doc._id], function (tx, results) {\n            // Only insert if not present or cached\n            if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n              var existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null; // If _rev present, make sure that not overwritten by lower or equal _rev\n\n              if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n                return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this12.name, doc._id, \"cached\", JSON.stringify(doc)], function () {\n                  return callback();\n                }, function (tx, err) {\n                  return callback(err);\n                });\n              } else {\n                return callback();\n              }\n            } else {\n              return callback();\n            }\n          }, function (tx, err) {\n            return callback(err);\n          });\n        }, function (err) {\n          if (err) {\n            if (error) {\n              return error(err);\n            }\n          } else {\n            if (success) {\n              return success(docs);\n            }\n          }\n        });\n      }, error);\n    }\n  }, {\n    key: \"uncache\",\n    value: function uncache(selector, success, error) {\n      var _this13 = this;\n\n      var compiledSelector = utils.compileDocumentSelector(selector); // Android 2.x requires error callback\n\n      error = error || function () {};\n\n      return this.db.transaction(function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [_this13.name, \"cached\"], function (tx, results) {\n          // Determine which to remove\n          var toRemove = [];\n\n          for (var i = 0, end = results.rows.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n            var row = results.rows.item(i);\n            var doc = JSON.parse(row.doc);\n\n            if (compiledSelector(doc)) {\n              toRemove.push(doc._id);\n            }\n          } // Add all non-local that are not upserted or removed\n\n\n          return async_1.default.eachSeries(toRemove, function (id, callback) {\n            // Only safely remove if removed state\n            return tx.executeSql('DELETE FROM docs WHERE state=\"cached\" AND col = ? AND id = ?', [_this13.name, id], function () {\n              return callback();\n            }, function (tx, err) {\n              return error(err);\n            });\n          }, function (err) {\n            if (err) {\n              if (error) {\n                return error(err);\n              }\n            } else {\n              if (success) {\n                return success();\n              }\n            }\n          });\n        }, function (tx, err) {\n          return error(err);\n        });\n      }, error);\n    }\n  }, {\n    key: \"uncacheList\",\n    value: function uncacheList(ids, success, error) {\n      var _this14 = this;\n\n      // Android 2.x requires error callback\n      error = error || function () {};\n\n      return this.db.transaction(function (tx) {\n        // Add all non-local that are not upserted or removed\n        return async_1.default.eachSeries(ids, function (id, callback) {\n          // Only safely remove if removed state\n          return tx.executeSql('DELETE FROM docs WHERE state=\"cached\" AND col = ? AND id = ?', [_this14.name, id], function () {\n            return callback();\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function (err) {\n          if (err) {\n            if (error) {\n              return error(err);\n            }\n          } else {\n            if (success) {\n              return success();\n            }\n          }\n        });\n      }, error);\n    }\n  }]);\n\n  return Collection;\n}();","map":null,"metadata":{},"sourceType":"script"}